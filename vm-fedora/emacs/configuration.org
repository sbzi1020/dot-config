Title: My Emacs Configuration
#+PROPERTY: header-args:emacs-lisp :tangle ./init.el
#+auto_tangle: t

* README

** Installation

*** 1. MacOS

You should install =Emacs Plus= to support all missing features in =Mac version=!!!

https://github.com/d12frosted/homebrew-emacs-plus

You can choose to install different versions:

#+BEGIN_SRC bash
  # brew tap d12frosted/emacs-plus
  # brew install emacs-plus    [options] # install the latest release (Emacs 29)
  # brew install emacs-plus@30 [options] # install Emacs 30 (master)
  # brew install emacs-plus@29 [options] # install Emacs 29
  # brew install emacs-plus@28 [options] # install Emacs 28
  # brew install emacs-plus@27 [options] # install Emacs 27
  # brew install emacs-plus@26 [options] # install Emacs 26
#+END_SRC


By default (without any addition options) this formula install Cocoa version of Emacs with support of =gnutls=, =imagemagick= (not included by default with =emacs-plus@29= and =emacs-plus@30=), =librsvg=, =libxml2=, dynamic modules and multicolor fonts. Please see the list of available options to disable any bit of default behaviour or add even more stuff.

Any I prefer install with the following options/features:

| Option                    | Description                                                                             |
|---------------------------+-----------------------------------------------------------------------------------------|
| --with-native-comp        | Native compilation, super important for solving the performance issue.                  |
| --with-imagemagick        | build with imagemagick support.                                                         |
| --with-modern-yellow-icon | More icons you can choose form  https://github.com/d12frosted/homebrew-emacs-plus#icons |


#+BEGIN_SRC bash
  brew tap d12frosted/emacs-plus

  brew install emacs-plus \
      --with-native-comp \
      --with-imagemagick \
      --with-modern-yellow-icon
#+END_SRC


And you got 2 ways to confirm that it's the =Native compilation= verison:

A. Open emacs and run the following =LISP= command:

    #+BEGIN_SRC emacs-lisp :tangle no
      (native-comp-available-p)
    #+END_SRC

    If it returns =t=, that mean YES, that's the =Native compilation= version:)


B. Open emacs and run the following =LISP= command:

    #+BEGIN_SRC emacs-lisp :tangle no
      (describe-variable 'system-configuration-features (current-buffer) nil)
    #+END_SRC

    If the output contains =NATIVE_COMP=, that mean YES, that's the =Native compilation= version:)


*** 2. Arch Linux

#+BEGIN_SRC bash
  # doas pacman --refresh --sync emacs

  # You should install the native compilation built-in version!!!
  doas pacman --refresh --sync emacs-nativecomp
#+END_SRC

If you see the following error when you run =emacs=:

#+BEGIN_SRC bash
  /usr/lib/libc.so.6: Version "GBLIC_X.Y.Z" not found
#+END_SRC

then you should re-install (upgrade) =glibc= to the corect version:

#+BEGIN_SRC bash
  doas pacman --refresh --sync glibc
#+END_SRC


Here is how to check the version you installed whether =native compilation= or not:

Open =emacs= and run ~(native-comp-available-p)~, if it returns =t= that means YES, =nil= is not.


** About the default configuration file and its location

1. In =MacOS=, the default configuration file locates in =~/.emacs.d=

   If you want to use =~/.config/emacs= instead of =~/.emacs.d=, then you HAVE TO remove =~/.emacs.d=.
   Otherwise, it won't load the =~/.config/emacs/init.el=!

2. I use =org-auto-tangle= package, so it generates the updated =./init.el= and =./early-init.el= automatically when this file has been saved.

   You can see the following messages print out to =*Messages*= buffer every time when saving this file.

   #+BEGIN_SRC emacs-lisp :tangle no
     ;; Tangling /home/wison/.config/emacs/configuration.org...
     ;; Tangling "/home/wison/.config/emacs/configuration.org" completed after 0.35 seconds
   #+END_SRC


** First time to run =Emacs=

You better to run the =Emacs= in daemon mode, as the it takes time to download all packages for the first time.

Actually, you should add the debug flag like this:

#+BEGIN_SRC bash
  emacs --daemon --debug-init
#+END_SRC

Then you can see the detail debug log. Also, sometimes it will fail to connect to =melpa.org/443=, if you
see the following error:

#+BEGIN_SRC bash
  Contacting host: stable.melpa.org:443

  # Ignore output
  ...... 

  # Finally, fail to install some pacakges
  Error (use-package): Failed to install org-bullets: melpa.org/443 Temporary failure in name resolution
#+END_SRC

So, you need to kill the existing =emacs= process and re-run =emacs --daemon --debug-init= command again
until you see it runs successfully like this:

#+BEGIN_SRC bash
  emacs --daemon --debug-init

  # Warning: due to a long standing Gtk+ bug
  # https://gitlab.gnome.org/GNOME/gtk/issues/221
  # Emacs might crash when run in daemon mode and the X11 connection is unexpectedly lost.
  # Using an Emacs configured with --with-x-toolkit=lucid does not have this problem.
  # Loading /home/wison/.config/emacs/settings.el (source)...
  # Loading /home/wison/.config/emacs/settings.el (source)...done
  # Loaded /home/wison/.config/emacs/settings.el
  # Loading /home/wison/.config/emacs/package.el (source)...
  # Loading /home/wison/.config/emacs/package.el (source)...done
  # Loaded /home/wison/.config/emacs/package.el
  # Loading /home/wison/.config/emacs/evil.el (source)...
  # Loading /home/wison/.config/emacs/evil.el (source)...done
  # Loaded /home/wison/.config/emacs/evil.el
  # Starting Emacs daemon.

#+END_SRC


** How to run =Emacs=

You can run emacs in different ways:

**** Run =Eamcs= as a server

For runing as a server:

#+BEGIN_SRC bash
  #
  # Run emacs as a server in background, same with 'emacs --bg-daemon'
  #
  emacs --daemon

  #
  # Run emacs as a server in foreground, good for debugging to see all console output
  #
  emacs --fg-daemon

  #
  # Run emacs as a named server in background, then you can have multiple server instances
  #
  emacs --daemon=XXX
  emacs --daemon=YYY
  emacs --daemon=ZZZ
#+END_SRC

When you run multiple named server instances, you can describe-variable on ~server-socket-dir~ to confirm the server socket folder, that folder contains all named server socket files.


After that, you can use ~emacsclient~ to communicate with the server:

#+BEGIN_SRC bash
  #
  # Open emacs in GUI mode
  #
  # As that's GUI program, you better to run it in background to avoid holding the current console
  #
  # -c, --create-frame: Create a new frame instead of trying to use the current Emacs frame
  # -a: if Emacs server doesn't run yet, then fallback to the given EDITOR)
  #
  emacsclient -c -a "nvim" &

  # Open emacs in terminal mode
  emacsclient -t
#+END_SRC


And you can kill the emacs server like this

#+BEGIN_SRC bash
  emacsclient -e \("kill-emacs"\)

  # If you only want to kill the given server instance
  emacsclient -e \("kill-emacs"\) --socket-name=XXX
#+END_SRC


**** Run =Emacs= as stand-alone instance


#+BEGIN_SRC bash
  # Open emacs in GUI mode
  emacs &

  # Open emacs in terminal mode
  # emacs -nw
  emacs --no-window-system
#+END_SRC



** How to export code block content into a given file (=*.el=)

All configuration contents in this file will be exported to ~init.el~ and ~early-init.el~ by running ~org-babel-tangle~ command, it exports all code blocks to the given file. You have a few ways to control how to export:

*** Specific each code block to export to the given file

~#+begin_src emacs-lisp :tangle ./A.el~
~#+end_src~

~#+begin_src emacs-lisp :tangle ./B.el~
~#+end_src~


*** Add property to define default export file

Or you can add the following property before the first headline of this line

~#+PROPERTY: header-args:emacs-lisp :tangle ./init-example.el~

It acts as a default tangle target, then you only need to specific in the code block.

But if you want to export to a different file, you can specific like this:

~#+begin_src emacs-lisp :tangle ./another.el~
~#+end_src~


Or you want to temporary disable/ignore tangle for the particular code block, then you can specific like this:

~#+begin_src emacs-lisp :tangle no
~#+end_src~

But keep that in mind, =you have to re-open this file to take affect if you changed the default tangle file!!!=


** Install =Treesitter langauge grammar=

You need to evaluate the following command to install all treesitter language grammars.

#+begin_src emacs-lisp :tangle no
  (mapc #'treesit-install-language-grammar (mapcar #'car treesit-language-source-alist))
#+end_src


** Learn how to use ~use-package~

https://github.com/jwiegley/use-package#getting-started


** Edit =emacs-lisp= source code in =org-mode=

When editing =emacs-lisp= source code your =org= file inside the =emacs-lisp= code block like this:

#+BEGIN_SRC emacs-lisp :tangle no
  (message "Hey:)")
#+END_SRC

You can press ~C-c '~ inside the code block to open a source code editing window in the =emacs-lisp= major mode (or any major mode you specified following by the =#+BEGIN_SRC=), then your =company-mode= and =eglot-mode= wll work well!!!

Then you don't need to switch to the =*scratch*= to edit your code for having the better coding experience and switch back:)


** How to run shell command in =Emacs=

You can run any emacs-lisp expressions in =evil commmand mode= which means you type ~:~ and follow by your emacs-lisp expression.

Also, you can run a shell commmand by ~:!~ and then follow by your shell command.

In the =dired-mode=, you can run a shell command by ~!~ or ~&~:

+ ~!~ runs the command ~dired-do-shell-command~ to execute your shell command.
+ ~&~ runs the command ~dired-do-async-shell-command~ to execute your shell command asynchronously.

And 2 things you need to know:

1. The shell command result will print out in the echo area or open a new buffer (depending on the output length).

2. You =SHOULD NOT= run any shell command that asks for interactive with =vim-keybindings=, as the command will halt and your keystrokes only go into the evil mode and operate inside the buffer (not passing to the shell command)!!!


** How to handle =org table=

Here, I only list the most convenient parts that I'm interested in, for more details, please have a look [[https://orgmode.org/manual/Built_002din-Table-Editor.html][here]].

Here are the default org table commands and behaviors:

*** Auto create table heading line and the first row

When finishing typing the following header line (=C= is your cursor position):

=|Name|Description|C=

Then you can press ~C-c RET~, it calls the ~org-ctrl-c-ret~ command to add the =hline= and first row like this:

| Name | Description |
|------+-------------|
| C    |             |

And =C= is your new cursor position, then you can keep typing.


*** Use =TAB= and =RET= to jump

When you got a table like the following (=C= is your cursor position):

| Name | Description |
|------+-------------|
| C    |             |

Then you can press ~TAB~ or ~RET~ to switch between columns and rows. Bascially, it calls ~org-cycle~ command. The main purpose of ~org-cycle~ is outline visibility cycling, but it also invokes other actions:

When inside a table, re-align the table and move to the next field.

But it works in different ways in =evil-mode=:


**** Move to the next column (create new row when hitting the most-right column)

| Name | Description |
|------+-------------|
|    C |           1 |
|    2 |           3 |
|    4 |             |

Suppose you have the above table, then in =Normal= mode, you press =RET= to call ~org-cycle~ command. Your cursor should jump like this:

C -> 1 -> 2 -> 3 -> 4


**** Move to the next column but next row (create new row when hitting the most-right column)

| Name | Description |
|------+-------------|
|    C |             |
|    1 |             |
|    2 |             |
|    3 |             |
|    4 |             |

Suppose you have the above table, then in =Insert= mode, you press =RET= to call ~org-return~ command. Your cursor should jump like this:

C -> 1 -> 2 -> 3 -> 4

Jump to next row and same column!!!

But if you want to jump to next column (in the same row) in =Insert= mode, you can press =TAB= to call =org-cycl=.


** How to handle =org= mode link manually

**** how to create link

Under the hook, org link format just like this =[[LINK_URL][DESCRIPTION_TO_DISPLAY]]=.

You can type from left to right, it won't show as a =Link= until you type the final =]= character.


**** How to edit created link

After created a link, you CAN'T see the =[[][]]= original text as it hides by the =org-hide-emphasis-markers= settings in =~/.config/color_theme.org=.

But you can go to the end of the link text and delete the last =]= character, then the original text
shows back (as that's broken link format) like this:

[[https://link][Hey]

Then you can change the URL or the DESCRIPTION part and add back the final =]= character, link shows back again.


** Default keybindings in =Emacs=

Although you install =Evil= package to enable =Vim Keybindings=, but sometimes your evil keybindings still won't work in some sort of the major modes.

So, you need to use the default =Emacs= keybindings in those siutations, what's why you better to know some of them from the very beginning.

Here are the common keybindings you should know about when dealing with =Emacs= :

| Keybindgins      | Description                                                                                 |
|------------------+---------------------------------------------------------------------------------------------|
| [Run function]   |                                                                                             |
| =M-x=              | M means the meta-key, it's ALT or CMD (in MacOS), it calls ~execute-extended-command~         |
|                  |                                                                                             |
| [Close and exit] |                                                                                             |
| =C-x C-c=          | Bascially, exit =Emacs=, will ask you save unsaved buffer.                                    |
| =C-x 4 0=          | Call =kill-buffer-and-window= to close current window and buffer.                             |
|                  |                                                                                             |
| [File & Dired]   |                                                                                             |
| =C-x C-f=          | Call =find-file=.                                                                             |
| =C-x d=            | Call =dired=                                                                                  |
|                  |                                                                                             |
| [Window]         |                                                                                             |
| =C-x 0=            | Call =delete-window= to close current window, but NOT close the buffer.                       |
| =C-x 1=            | Call =delete-other-windows= to kill all other windows except the current window               |
| =C-x 2=            | Call =split-window-below= to split the window up and down direction                           |
| =C-x 3=            | Call =split-window-right= to split window on the right                                        |
|                  |                                                                                             |
| [Org mode]       |                                                                                             |
| =<tab>=            | Call =org-cycle= to fold or unfold the point at heading sub-tree                              |
| =<backtab>=        | Call =org-shifttab= to fold or unfold all heading sub-tree                                    |
| =M-RET=            | Call =org-meta-return= to add the next heading/list/item with the correct level               |
| C-j              | Call =org-forward-heading-same-level= to jump down to next (same level) heading.              |
| C-k              | Call =org-backward-heading-same-level= to jump up to next (same level) heading.               |
| M-j              | Call =outline-move-subtree-down= to move current heading down to next (same level).           |
| M-k              | Call =outline-move-subtree-up=  to move current heading up to next (same level).              |
| =S-<left>=         | Call =org-shiftleft= to change item bullet type, move table cell to left, switch heading      |
| =S-<right>=        | Call =org-shiftright= to change item bullet type, move table cell to right, switch heading    |
|                  | Call =consult-org-heading= to list all org file heading into minibuffer                       |
| =C-c '=            | Call =org-edit-special= to open the src editing window (with LSP support!!!)                  |
| =C-c '=            | Call =org-edit-src-exit= to accept the change and exit                                        |
| =C-c C-k=          | Call =org-edit-src-abort= to abort and exit                                                   |
| =C-c C-x C-v=      | Call =org-toggle-inline-images= to toggle image link to show image                            |
|                  |                                                                                             |
| [Org mode link]  |                                                                                             |
| =C-c C-l=          | Calls the ~org-insert-link~ to create or edit a link                                          |
| =C-c C-o=          | Calls the ~org-open-at-point~ to open a thing at point                                        |
|                  |                                                                                             |
| [Org mode table] |                                                                                             |
| =C-c RET=          | Calls the ~org-ctrl-c-ret~ command to add the =hline= and first row                             |
| =C-c C-c=          | Calls ~org-ctrl-c-ctrl-c~ to re-align table, same result like calling ~org-table-align~         |
| =<N> RET=          | Calls ~org-cycle~ to re-align the table and move to the next field.                           |
| =<I> TAB=          | Calls ~org-cycle~ to re-align the table and move to the next field.                           |
| =<I> RET=          | Calls ~org-return~ to re-align the table and move to the same column but next rows.           |
|                  |                                                                                             |
| [Dired]          |                                                                                             |
| =C-x d=            | Call =dired=                                                                                  |
| =(=                | Call =dired-hide-details-mode= to toggle detail mode                                          |
| =^=                | Call =dired-up-directory=                                                                     |
| =RET=              | Call =dired-find-file=                                                                        |
| =g o=              | Call =dired-find-file-other-window= to open the file in separated window                      |
| =m=                | Call =dired-mark= on file at point                                                            |
| =u=                | Call =dired-unmark= on file at point                                                          |
| =U=                | Call =dired-unmark-all-marks=                                                                 |
| =t=                | Call =dired-toggle-marks= to mark or unmark all files                                         |
| =M=                | Call =dired-do-chmod= to run ~chmod~                                                            |
| =C=                | Call =dired-do-copy=                                                                          |
| =R=                | Call =dired-do-rename= to rename or move file or directory                                    |
| =D=                | Call =dired-do-delete=                                                                        |
| =C-x C-q=          | Call =dired-toggle-read-only= to turn the buffer into =wdired-change-to-wdired-mode=            |
| =C-c C-k=          | Call =wdired-abort-changes= to discard changes in =wdired-change-to-wdired-mode=                |
| =C-c C-c=          | Call =wdired-finish-edit= to accept changes in =wdired-change-to-wdired-mode=                   |
|                  | Call =make-empty-file= to create empty file                                                   |
|                  | Call =mkdir= or =make-directory= to create directories                                          |
| =C-j=              | Call =image-next-file= to render next image (image-mode)                                      |
| =C-k=              | Call =image-previous-file= to render previous image (image-mode)                              |
| =!=                | Call =dired-do-shell-command= reads a shell command on the marked files.                      |
| =&=                | Call =dired-do-async-shell-command= reads a shell command on the marked files asynchronously. |
|                  |                                                                                             |
| [Shell command]  |                                                                                             |
| =:=                | Runs the command =evil-ex= (found in =evil-motion-state-map=) to evaluate LISP expression       |
| =:!=               | Runs the command =evil-shell-command= on a given shell command                                |
|                  |                                                                                             |
| [Image Dired]    |                                                                                             |
|                  | Call =image-dired=                                                                            |
| =RET=              | Call =image-dired-display-thumbnail-original-image=                                           |
| =C-j=              | Call =image-next-file= to render next image (image-dired-image-mode)                          |
| =C-k=              | Call =image-previous-file= to render previous image (image-dired-image-mode)                  |
| =-=                | Call =image-decrease-size= to zoom out the rendered image                                     |
| =+=                | Call =image-increase-size= to zoom out the rendered image                                     |
|                  | Call =image-transform-fit-to-window= to zoom out the rendered image                           |
|                  |                                                                                             |
| [Color]          |                                                                                             |
|                  | Call =list-colors-display=                                                                    |
|                  |                                                                                             |
| [Faces]          |                                                                                             |
|                  | Call =list-faces-display=                                                                     |
|                  |                                                                                             |
| [Theme]          |                                                                                             |
|                  | Call ~consult-theme~ to preview theme                                                         |
| [Misc]           |                                                                                             |
|                  | Call ~restart-emacs~ to restart emacs instance                                                |
|                  | Call ~emacs-init-time~ to print the emacs start time                                          |
|                  |                                                                                             |


** How to customize keybindgins

*** Concepts: Key, Mode, Keymap and Hook

**** 1. Key

Usually, you should use ~(kbd KEY)~ to present a key combination that you want to bind.

One important point to note is that you must surround special keys with =<= and =>=. That includes Function-Keys, Arrow keys and Home row keys, like so: =<home>=, =<f8>=, =<up>=, =<down>=, =<tab>=, =<backtab>=, and =<return>=.

And you can evalute the ~(kbd KEY)~ function to see its value like below:

#+begin_src emacs-lisp :tangle no
  ;; (message "(kbd \"TAB\"): %s" (kbd "TAB"))
  ;; (message "(kbd \"<tab>\"): %s" (kbd "<tab>"))

  ;; (message "(kbd \"S-TAB\"): %s" (kbd "S-TAB"))
  ;; (message "(kbd \"S-<tab>\"): %s" (kbd "S-<tab>"))
  ;; (message "(kbd \"<backtab\"): %s" (kbd "<backtab"))

  ;; (message "(kbd \"RET\"): %s" (kbd "RET"))
  ;; (message "(kbd \"<return>\"): %s" (kbd "<return>"))

  ;; (message "(kbd \"S-RET\"): %s" (kbd "S-RET"))
  ;; (message "(kbd \"S-<return>\"): %s" (kbd "S-<return>"))
#+end_src

Then you can see the value in =*Messages*= buffer like this:

=(kbd "TAB"):=
=(kbd "<tab>"): [tab]=
=(kbd "S-TAB"): [33554441]=
=(kbd "S-<tab>"): [S-tab]=
=(kbd "<backtab"): <backtab>=
=(kbd "RET"): 
=(kbd "<return>"): [return]=
=(kbd "S-RET"): [33554445]=
=(kbd "S-<return>"): [S-return]=

So, there are the stuffs you lean:

- ="TAB"= is different with ="<tab>"=, ="RET"= is different with ="<return>"=.
- You should choose ="<tab>"=, ="<return>"= instead of ="TAB"= and ="RET"= for most of the cases.


More examples:

| Key                | Description         |
|--------------------+---------------------|
| ~(kbd "<tab>")~      | Tab key             |
| ~(kbd "<backtab>")~  | Shift + Tab         |
| ~(kbd "<return>")~   | Return key          |
| ~(kbd "S-<return>")~ | Shfit + Return key  |
| ~(kbd "s-m")~        | Super-m             |
| ~(kbd "H-m")~        | Hyper-m             |
| ~(kbd "A-m")~        | Alt-m               |
| ~(kbd "C-x C-o")~    | Ctrl-C, then Ctrl-O |
| ~(kbd "<leader>df")~ | Space then d then f |


**** 2. Modifer keys

There are a few rules when using modifer key in =Emacs=:

1) Control-modified alphabetical characters are =case-insensitive=, that's why:

   - =C-a= is the same with =C-A=
   - =C-z= is the same with =C-Z=

2) Control-modified non-alphabetical characters are =case-sensitive=, that's why:

   - =C-2= is the NOT the same with =C-@= (even that's the key physical key but with or without a =Shift= key pressed)

3) Meta-modified, Alt-modified, Hyper-modified are =case-sensitive= all the time, that's why:
   
   - =M-a= is different with =M-A=
   - =A-a= is different with =A-A=
   - =s-a= is different with =s-A=

4) Not all terminal emulators support =Shift (S-)=, =Super (s-)=, =Hyper (H-)=, and =Alt (A-)=, that said you can use those modifier keys in =GUI= version but NOT in =terminal= version!!!


 One more trick about knowing whether the given key combination is valid or not is that you can use run the ~(key-valid-p "KEY_STRING_HERE")~ function, it returns =t= if key is valid or returns =nil= if key is invalid.

 For examples:

 #+begin_src emacs-lisp :tangle no
   ;; (key-valid-p "b")
   ;; (key-valid-p "C-a")
   ;; (key-valid-p "s-a")
   ;; (key-valid-p "X-a") ;; This returns nil!!!
 #+end_src


**** 3. Mode

=Mode= means =FileType= in =Vim=. You got different =modes= when you open different files into the buffer. For example:

- =typescript-mode= is available when you open =*.ts= files
- =c-mode= is available when you open =*.c= files
- =org-mode= is available when you open =*.org= files
- =message-mode= the current buffers is =*Messages*=
- =lisp-mode= the current buffers is =*scratch*=
- =help-mode= the current buffers is =*Help*=
- =ivy-minibuffer-map= the current buffer is ivy minibuffer
=- ivy-switch-buffer-map= the current buffer is opened for switching buffer
etc. 

Different =mode= effects the visual result in buffer, and you can turn the current buffer into any =Mode= you want, just run =xxx-mode= function.


+ What is =Major= mode and =Minor= mode???

  When you open a buffer, the current buffer has =Major= mode which determined by the opened file type and =Minor= mode which means all alternative mode attached to this buffer.

  For example:

  1) When you open an =*.org= file and run ~describe-mode~, then you should see the following description:

      #+begin_comment
        =Minor= modes enabled in this buffer: =Command-Log= =Company=
        =Display-Line-Numbers= =Evil-Collection-Unimpaired= =Evil-Local=
        =Evil-Surround= =Font-Lock= =Olivetti= =Org-Indent= =Visual-Line=

        The major mode is =Org= mode defined in org.el:
      #+end_comment


  2) When you open a =*.c= file and ~describe-mode~, then you should see the following description:

      #+begin_comment
        =Minor= modes enabled in this buffer: =Command-Log= =Company=
        =Display-Line-Numbers= =Eldoc= =Evil-Collection-Unimpaired= =Evil-Local=
        =Evil-Surround= =Flymake= =Font-Lock= =Highlight-Indent-Guides= =Lsp-Completion=
        =Lsp-Diagnostics= =Lsp-Headerline-Breadcrumb= =Lsp-Managed= =Lsp=
        =Lsp-Modeline-Code-Actions= =Lsp-Modeline-Diagnostics=
        =Lsp-Modeline-Workspace-Status= =Lsp-Ui-Doc= =Lsp-Ui= =Lsp-Ui-Sideline=

        The major mode is =C/*l= mode defined in cc-mode.el:

        Major mode for editing C code.
      #+end_comment


    The =Major= mode is the =File type=, and the =Minor= mode is added by the packages you installed, they all work together. Usually, the =Major= mode (=xxx-mode= of the file type) should be the target mode if you want to bind some keys to buffer.


**** 4. Keymap

A =keymap= is a Lisp data structure that specifies key bindings for various key sequences.

Its value looks like this:

=(keymap=
=(tab)=
=(11)=
=(normal-state keymap "Auxiliary keymap for Normal state"=
                =(13 . org-cycle))=
=(leader keymap=
            =(99 keymap=
                =(98 . org-insert-structure-template)))=
=(67108899 . org-table-rotate-recalc-marks)=
=(10)=
=(13 . org-return)=

Basically, it's talking about =pressing what key (combination) to call what function= and that's it:)

So, different =modes= have different =keymaps=, e.g.:

+ =global-map= is for holding the =keys -> functions= relationship of default modes (a lot of them).
+ =typescript-mode-map= is for holding the =keys -> functions= relationship of =typescript-mode=.
+ =c-mode-map= is for holding the =keys -> functions= relationship of =c-mode= 

That said when you use =global-map=, =xxx-mode-map= in the =define-key= function, you should make sure to evaluate its map value!!!!

- The correct example:

    #+BEGIN_SRC emacs-lisp :tangle no
      (define-key global-map (kbd "<tab>") nil)
      (define-key (list global-map org-mode-map) (kbd "<tab>") nil)
    #+END_SRC

    The =global-map= and =(list global-map org-mode-map)= will be evaluted to its map value!!!

- The wrong example:

    #+BEGIN_SRC emacs-lisp :tangle no
      (define-key 'global-map (kbd "<tab>") nil)
      (define-key '(global-map org-mode-map) (kbd "<tab>") nil)
    #+END_SRC

    The ='global-map= and ='(global-map org-mode-map)= won't be evaluted to its map value and it will cause =(define-key YOUR_MAP "\n" YOUR_FUNCTION_OR_NIL)= error!!!


**** 5. Hook

Sometimes, =xxx-mode= and =xxx-mode-map= are only available after finishing loading the file, that said the following keybinding will fail as the paritcular =mode= and =mode-map= don't exists before the file has been loaded.

~(define-key (list c-mode-map typescript-mode-map) (kbd "Q") 'exit)~

For solving that problem, you can use =xxx-mode-hook= to defer binding.


*** How to bind keys in Emacs

**** What functions you can use to bind keys

Plz keep that in mide:

The following keybinding functions only can bind =KEY= to =COMMAND= (which means a function uses =(interactive)= and be able to list in the =M-x= list).

You got a few ways to bind keys in =Emacs=:

***** ~(global-set-key KEY COMMAND)~

~global-set-key~ binds the ~KEY~ to the =global-map= to call the ~COMMAND~

Here is the example:

#+BEGIN_SRC emacs-lisp :tangle no
  (global-set-key (kbd "<tab>") 'switch-to-next-buffer)
  (global-set-key (kbd "<backtab>") 'switch-to-prev-buffer)
#+END_SRC


~globa-set-key~ is a legacy function; see ~keymap-global-set~ for the recommended function to use instead. Here are some examples:

Pay attention that: you don't need to call ~(kbd)~ when using ~keymap-global-set~!!!

#+BEGIN_SRC emacs-lisp :tangle no
  (keymap-global-set "C-c y" 'clipboard-yank)
  (keymap-global-set "C-M-q" 'query-replace)
  (keymap-global-set "<f5>" 'flyspell-mode)
  (keymap-global-set "C-<f5>" 'display-line-numbers-mode)
  (keymap-global-set "C-<right>" 'forward-sentence)
  (keymap-global-set "<mouse-2>" 'mouse-save-then-kill)
#+END_SRC


***** ~(define-key KEYMAP KEY DEF &optional REMOVE)~

This is the better way to use, as it gives you a chance to bind to different =mode=.

=global-set-key= is a shortcut for (=define-key global-map KEY COMMAND)=.

Let's have a look how to bind the =Q= to =kill-current-buffer= command in all =modes=:

#+BEGIN_SRC emacs-lisp :tangle no
  ;; Unbind 'Q'
  (define-key dired-mode-map (kbd "Q") nil)

  ;; Re-bind 'Q'
  (define-key evil-normal-state-map (kbd "Q") 'kill-current-buffer)
  (define-key evil-motion-state-map (kbd "Q") 'kill-current-buffer)
#+END_SRC

~define-key~ is a legacy function; see ~keymap-set~ for the recommended function to use instead. Here are some examples:

Pay attention that: you don't need to call ~(kbd)~ when using ~keymap-set~!!!

#+BEGIN_SRC emacs-lisp :tangle no
  (keymap-set texinfo-mode-map "C-c p" 'backward-paragraph)
  (keymap-set texinfo-mode-map "C-c n" 'forward-paragraph)))
  (keymap-set texinfo-mode-map "C-c C-x x" nil)
#+END_SRC


***** ~(evil-define-key STATE KEYMAP KEY DEF &rest BINDINGS)~

When you need to set a keybinding to the particular =state= and =mode=, you can use ~evil-define-key~ instead. Here is the example:

#+BEGIN_SRC emacs-lisp :tangle no
  (evil-define-key 'normal org-mode-map (kbd "RET") 'org-cycle)
#+END_SRC
  


**** How to unbind/disable the default keybindings that you don't use

It's very important that you should know =How to disable/unbind the default keybindings that you don't use=!!!! Otherwise, your keybinding won't work as you expected!!!

Here are the steps of how you can find which =mode= already have the keybindings you want to set and unbind it

***** 1. Run ~describe-key~ and then press your key, for example =Q=

It should show the command info into a new buffer (if your key has been bound to some modes).

At the very top part, it should say what function your =Q= has been bound to already, and the =Key Bindings= section should show you that your =Q= also bound to in which =mode= like this:

--------------------------------------------------
=Key Bindings=
completion-list-mode-map z
evil-motion-state-map Q
evil-normal-state-map Q
--------------------------------------------------

That said, you should unbind all those =modes= for your =Q= (if that's NOT what you want).


***** 2. But sometimes, ~describe-key~ doesn't list all =modes= as some modes won't exists before opening the file has that mode

For that situation, you should run ~clm/toggle-command-log-buffer~ to show the command log buffer. And then, go to any UIs/modes to press your key (for exmaple =Q= in this case) and see what functions it binds to.

After that, run ~describe-function~ and put the function name there, help buffer should show you the =Key Bindings= section (if keybinding exists). That's how you can get the hidden =modes= in different situations.

***** 3. So, how to unbind/unset keybindings you found?

The answer is just bind it to =nil=.

=(define-key YOUR_MODE_NAME_HERE (kbd YOUR_KEY_HERE) nil)=


**** How to bind key via hooks

Sometimes, =xxx-mode= and =xxx-mode-map= are only available after finishing loading the file, that's why you should bind key via a =hook= in those situations.

***** 1. Bind key to =xxx-mode-map=

#+begin_src emacs-lisp :tangle no
  ;;
  ;; Command to run when pressing 'C-c a'
  ;;
  (defun print_a_message()
      (interactive)
      (message "Print something by pressing 'C-c a'.")
  )

  ;;
  ;; The bind function to be called when 'org-mode' is available
  ;;
  (defun bind-test-key-to-org-mode-via-hook()
    (message ">>> [ org-mode-hook-test ] Set temp keybinding 'C-c a' org mode")
    (define-key org-mode-map (kbd "C-c a") 'print_a_message)
  )

  ;;
  ;; Add the bind function to 'org-mode-hook'
  ;;
  (add-hook 'org-mode-hook #'bind-test-key-to-org-mode-via-hook)
#+end_src

If you evaluate the above functions, then run ~describe-variable~ on =org-mode-hook=, you should see the following value has been added to that hook:

~bind-test-key-to-org-mode-via-hook my/org-mode-setup~

Then when you open an =org= file or run ~org-mode~ (to reload), then run ~describe-variable~ on =org-mode-map= again, you should see the follwing key->function relationship has been add to its keymap:

=(3 keymap=
    =(97 . print_a_message)=

And then press ~C-c a~, you should see the ~Print something by pressing ’C-c a’.~ debug message has been printed to the =*Messages*= buffer, that said your mode-hook settings is working:)


***** 2. Bind key to local buffer

The example above binds the ~C-c a~ to =org-mode-map=, But you can't stop other installed packages from binding the same keybindings to the same hook sometimes. If that happens, then duplicated binding to =org-mode-map= might happen. So, if there is no special needs, you should use =xxx-mode-hook= to do defer binding to the local buffer, as this promises no duplicated bindings.

Let's fix the above duplicated bindings:

#+begin_src emacs-lisp :tangle no
  ;;
  ;; Command to run when pressing 'C-c a'
  ;;
  (defun print_a_message()
      (interactive)
      (message "Print something by pressing 'C-c a'.")
  )

  ;;
  ;; The bind function to be called when 'org-mode' is aviable
  ;;
  (defun bind-test-key-to-org-mode-via-hook()
    (message ">>> [ bind-test-key-to-org-mode-via-hook ] Set temp keybinding 'C-c a' local buffer")

    ;;
    ;; Bind the local buffer scope rather than the 'org-mode-map'
    ;;
    (define-key evil-normal-state-local-map (kbd "C-c a") 'print_a_message)

    ;;
    ;; '(evil-local-set-key 'normal KEY COMMAND)' is the same with 
    ;; '(define-key evil-normal-state-local-map KEY COMMAND)',
    ;;
    ;; Just pick the one you like to use
    ;;
    ;; (evil-local-set-key 'normal (kbd "C-c a") 'print_a_message)
  )

  ;;
  ;; Add the bind function to 'org-mode-hook'
  ;;
  (add-hook 'org-mode-hook #'bind-test-key-to-org-mode-via-hook)
#+end_src

Then when you open an =org= file or run ~org-mode~ (to reload), then run ~describe-variable~ on =org-mode-map=, you won't see any key binding to call the ~print_a_message~ command.

But if you run ~describle-bindings~ (in the org file buffer),  you should see the following setting is on the top part:

~`evil-normal-state-local-minor-mode' Minor Mode Bindings:~
    ~Key             Binding~
    ~C-c a		print_a_message~

That means the ~C-c a~ only bind to the current opened buffer, try to press ~C-c a~, you should see the ~Print something by pressing ’C-c a’.~ debug message has been printed to the =*Messages*= buffer, that said your mode-hook settings is working:)


*** How to unbind all keybindings for the given mode

If you really want to unbind all keybindings for the particular mode, do like this:

#+BEGIN_SRC emacs-lisp :tangle no
  (setf (cdr YOUR_MODE_NAME_HERE) nil)
#+END_SRC


* My configuration

** Basic settings

*** Use =Super= key as =Meta= (But it works in =GUI= mode only)

#+begin_src emacs-lisp
  ;;
  ;; For MacOS
  ;;
  (if (string-equal "darwin" system-type)
          (progn
                  (setq mac-command-modifier 'meta)
                  (message ">>> MacOS, set 'super' key as 'meta' key." system-type)
          )
  )

   ;;
   ;; For Linux
   ;;
   (if (string-equal "gnu/linux" system-type)
           (progn
                   (setq x-super-keysym 'meta)
                   (message ">>> Linux, set 'super' key as 'meta' key." system-type)
           )
   )

#+end_src


*** Hide all UIs that I don't need

#+BEGIN_SRC emacs-lisp
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (setq inhibit-startup-message t
        use-dialog-box nil)
#+END_SRC


*** Use =y-or-n-p= for prompts:

By default, =Emacs= prompts for user confirmation using =yes= or =no=. The following setting changes to use =y= or =n= for shorter and faster responses.

#+begin_src emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+end_src


*** Auto refresh buffer when file has been updated outside Emacs

#+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode 1)
  (setq global-auto-revert-non-file-buffers t)
#+END_SRC


*** No auto backup and auto save

#+BEGIN_SRC emacs-lisp
(setq make-backup-files nil
      auto-save-default nil)
#+END_SRC


*** Disable remember opened file positions

#+BEGIN_SRC emacs-lisp
  ;; Enable it
  ;;(save-place-mode 1)

  ;; Disable it
  (setq save-place-mode nil)
#+END_SRC


*** Line number related

#+BEGIN_SRC emacs-lisp
  (global-display-line-numbers-mode 1)
  (setq display-line-numbers-type 'relative)
  (setq column-number-mode t)
#+END_SRC


*** Enable current line background highlight both in terminal and GUI

#+BEGIN_SRC emacs-lisp
;; (when window-system (global-hl-line-mode t))
(global-hl-line-mode t)
#+END_SRC


*** Customized variable file

By default, =Emacs= writes some custom settings back to =init.el= when you call ~customize~ related functions and then mess up your =init.el= file. For avoiding this, you need to tell =Emacs= where to save those customized settings and re-load that file.

Also, I don't want to see error message when loading that custom file even it has.

#+BEGIN_SRC emacs-lisp
(setq custom-file (locate-user-emacs-file "custom-vars.el"))
(load custom-file 'noerror 'nomessage)
#+END_SRC


*** Dired settings

Show hidden files by default.

#+BEGIN_SRC emacs-lisp
;; (when window-system (global-hl-line-mode t))
(setq dired-listing-switches "-lhta")
#+END_SRC


*** Auto select =help= window

=describe-xxxx= function opens a new help buffer and window, but the help window doesn't be selected by default, it's quite annoying as you need to move to that window before you can close it.

But you can make it auto be selected by the following settings:

#+begin_src emacs-lisp
  (setq help-window-select t)
#+end_src


*** Always display =help= buffer on the right-side window

#+BEGIN_SRC emacs-lisp
  (setq display-buffer-alist
        '(
           ("\\*helpful" 
               (display-buffer-reuse-window display-buffer-in-side-window)
               (side . right)
               (window-width . 0.5)
           )
         )
  )
#+END_SRC


*** Fixed =TAB= width

#+BEGIN_SRC emacs-lisp
  (setq tab-width 4)
#+END_SRC


*** Org mode edit src in current window

When pressing =C-c '= inside the code block, which way I prefer to open the src editing window: ~current-window~

#+BEGIN_SRC emacs-lisp
  (setq org-src-window-setup 'current-window)
  ;; (setq org-src-window-setup 'split-window-rIght)
#+END_SRC

Inside the src editing window, press =C-c '= again to accept change and exit; press ~C-c C-k~ to abort and exit.


*** Enable auto pair mode

Auto pair =()= and =[]=

#+BEGIN_SRC emacs-lisp
  (electric-pair-mode)
#+END_SRC


*** Disable native compilation warnings and errors

Auto pair =()= and =[]=

#+BEGIN_SRC emacs-lisp
  (setq native-comp-async-report-warnings-errors nil)
#+END_SRC



*** Don't use actual image size for inline images and show inline image by default

#+BEGIN_SRC emacs-lisp
  (setq org-image-actual-width nil)
  (setq org-startup-with-inline-images t)
#+END_SRC

After you set ~org-image-actual-width~ to ~nil~, then you're able to use the following attributes to specific the size of any inline images:

#+BEGIN_SRC emacs-lisp :tangle no
  ;;
  ;; Display image with half of the current window size
  ;;
  #+ATTR_HTML: :width 50%
  [[~/...your_image_file]]

  ;;
  ;; Display image with exactly pixels width
  ;;
  #+ATTR_HTML: :width 100px
  [[~/...your_image_file]]
#+END_SRC

Because you set ~org-startup-with-inline-images~, that's why sometimes the size doesn't work well when opening an org file in a separated window (it still use the full Emacs window width to display the inline image)!!!

The way to fix that is by running ~org-toggle-inline-images~ twice to refresh it.


*** Add extra module load path

Load your custom dynamically loaded module from the given path.

#+BEGIN_SRC emacs-lisp
  ;; Just for debugging purpose:
  ;;
  ;; When developing your dynamically Loaded Module for emacs, you can
  ;; add your library output folder to the 'load-path' for testing.
  ;;
  ;; After adding your testing library folder to 'load-path', then you
  ;; can load it by running:
  ;; 
  ;; (require 'YOUR_LIB_FILENAME_HERE)
  ;; (CALL_YOUR_MODULE_FUNCTION)
  ;; ...
  ;;
  (push (expand-file-name "~/zig/emacs-module-in-zig/zig-out/lib") load-path)

  (push "~/.config/emacs/lib" load-path)
#+END_SRC



** Set fonts and transparent background, it has to be in ~early-init.el~

For some setttings, you have to place them into the =early-init.el=

For example, I need to run some functions to set transparent background via the ~after-make-frame-functions~ hook. If you run ~describe-variable~ on that hook, you should see it says:

=="Note that these functions are usually not run for the initial frame, unless you add them to the hook in your early-init file."=

That's why the following code has to be placed into =early-init.el= instead of =init.el=!!!

#+BEGIN_SRC emacs-lisp :tangle ./early-init.el
  ;; --------------------------------------------------------------------------------------------
  ;; Remove title bar for the Mac (GUI) version
  ;; --------------------------------------------------------------------------------------------
  ;;  (if (string-equal "darwin" system-type)
  ;;       (progn
  ;;           ;;
  ;;           ;; By setting this, you don't need to figure out it's the terminal version or GUI version.
  ;;           ;;
  ;;           (add-to-list 'default-frame-alist '(undecorated . t))
  ;;           (message ">>> Remove title bar for Mac GUI version.")
  ;;       )
  ;;  )

  ;; --------------------------------------------------------------------------------------------
  ;; Set font and transparent after creating the frame (window)
  ;; --------------------------------------------------------------------------------------------

  ;;
  ;; Set my font
  ;;
  (defun my-set-font()
     (set-face-attribute 'default nil
         ;;:family "SauceCodePro Nerd Font"
         :family "JetBrains Mono Nerd Font"
         :weight 'semi-bold
         :height 140
         ;; :italic t
     )
     (message ">>> [ early-init > my-set-font ] Set my custom font.")
  )

  ;;
  ;; Set transparent background for GUI
  ;;
  (defun my-set-transparent-gui()
    (message ">>> [ early-init > my-set-transarent-background ] - call 'my-set-transparent-gui'")
    ;;
    ;; Force to set a particular background color for better transparent effect.
    ;;
    ;; (set-face-attribute 'default nil :background "#23211B")

    (set-frame-parameter nil 'alpha-background 95)
    (add-to-list 'default-frame-alist '(alpha-background . 95))
  )

  ;;
  ;; Set transparent background for terminal
  ;;
  (defun my-set-transparent-terminal()
    (message ">>> [ early-init > my-set-transarent-background ] - call 'my-set-transparent-terminal'")
    (set-face-attribute 'default nil :background "nil")
  )

  ;;
  ;; Setting the transparent background is very different between GUI mode and Terminal mode, so you
  ;; better do that in the a hook handler (especially after the init window frame has been created
  ;; and the color theme has been loaded)
  ;;
  ;; For detailed steps about =Emacs= startup sequence, read this:
  ;;
  ;; https://www.gnu.org/software/emacs/manual/html_node/elisp/Startup-Summary.html
  ;;
  (defun my-set-transarent-background(current_frame)
    (message ">>> [ early-init > my-set-transarent-background ] - display-graphics-p result: %s" (display-graphic-p current_frame))
    (if (display-graphic-p current_frame)
            (my-set-transparent-gui)
            (my-set-transparent-terminal)
    )
  )

  ;;
  ;; Call set font function and set transparent function in standalone mode or daemon mode
  ;;
  (if (daemonp)
      (add-hook 'after-make-frame-functions
          (lambda (frame)
              (with-selected-frame frame
                (message ">>> [ early-init ] Run lambda funtion in 'after-make-frame-functions' hook.")
                (progn
                    (message ">>> [ early-init ] lambda funtion set font and transparent background in 'after-make-frame-functions' hook.")
                    (my-set-font)
                    (my-set-transarent-background frame)
                )
                (message ">>> [ early-init ] Run lambda funtion in 'after-make-frame-functions' hook [ done ].")
                            ))
          )
      (add-hook 'emacs-startup-hook
          (lambda ()
              (message ">>> [ early-init ] Run lambda funtion in 'emacs-startup-hook' hook.")
              (progn
                  (message ">>> [ early-init ] lambda funtion set font and transparent background in 'emacs-startup-hook' hook.")
                  (my-set-font)
                  (my-set-transarent-background nil)
              )
              (message ">>> [ early-init ] Run lambda funtion in 'emacs-startup-hook' hook [ done ].")
          )
          )
  )
#+END_SRC


** Package init and settings

*** Init package and install =use-package=

#+BEGIN_SRC emacs-lisp
  (require 'package)
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
  ;;(add-to-list 'package-archives
  ;;	     '(
  ;;	       ("melpa" . "https://melpa.org/packages/")
  ;;	       ("org" . "https://orgmode.org/elpa/")
  ;;	       ("elpa" . "https://elpa.gun.org/packages/")
  ;;	       ))

  (unless package-archives
          (package-refresh-contents))
  ;;(package-refresh-contents)
  (package-initialize)

  ;;
  ;; (unless condition nil
  ;;         statement-to-execute)
  ;;
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))

  (require 'use-package)

  ;; Auto install all missing packages when using =(use-packge)`
  ;; It's equal to use `:ensure t` in `(use-package)`
  (setq use-package-always-ensure t)
#+END_SRC



*** ~(use-package)~ quick manual

#+begin_src emacs-lisp :tangle no
  ;;
  ;; Load the package, but only if 'PACKAGE_NAME' is available on your system. If not, a
  ;; warning is logged to the '*Messages*' buffer.
  ;;
  ;;
  (use-package 'PACKAGE_NAME
    ;;
    ;; Install if it doesn't exists, and because of '(setq use-package-always-ensure t)'
    ;; has been set already, that said ':ensure t' will be applied to all '(use-package)',
    ;; that's why you don't need to set ':ensure t' anymore.
    ;;
    :ensure t

    ;; 
    ;; Lazy load this package
    ;; Using 'bind' and 'command' will cause the package to lazy load as well!!!
    ;;
    ;; The keywords ':commands,' et al, provide "triggers" that cause a package to
    ;; be loaded when certain events occur. However, if 'use-package' cannot determine
    ;; that any trigger has been declared, it will load the package immediately (when
    ;; Emacs is starting up) unless :defer t is given. The presence of triggers can be
    ;; overridden using ':demand t' to force immediately loading anyway.
    ;; For example, :hook represents a trigger that fires when the specified hook is run.
    ;; 
    ;; In almost all cases you don't need to manually specify ':defer t', because this is
    ;; implied whenever ':bind' or ':mode' or ':interpreter' are used. Typically, you only
    ;; need to specify ':defer' if you know for a fact that some other package will do
    ;; something to cause your package to load at the appropriate time, and thus you would
    ;;  like to defer loading even though 'use-package' has not created any autoloads for you.
    ;;
    :defer t

    ;; 
    ;; Use the ':init' keyword to execute code before a package is loaded. It accepts one
    ;; or more forms, up to the next keyword:
    ;;
    :init
        ;;
        ;; All settings belong to ':init' part
        ;;
        (setq YOUR_VARS t)

    ;; 
    ;; Use the ':config' keyword to execute code after a package is loaded. In cases where
    ;; loading is done lazily (see more about autoloading below), this execution is deferred
    ;; until after the autoload occurs
    :config
        ;;
        ;; All settings belong to ':config part
        ;;
        (your-mode t)

    ;; 
    ;; Load this package after another package
    ;;
    :after ANOTHER_PACKAGE_NAME

    ;; 
    ;; Run the commands when the package is actually loaded.
    ;; The ':commands' keyword takes either a symbol or a list of symbols.
    ;;
    :commands SINGLE_COMMAND
    :commands (COMMAND_1 COMMAND_2 COMMAND_3 etc)

    ;; 
    ;; Keybindings
    ;;
    :bind (("M-o l" . COMMAND_TO_BIND)
           ("M-o r" . COMMAND_TO_BIND)
           ("M-o w" . COMMAND_TO_BIND)))

    ;; 
    ;; The ':hook' keyword allows adding functions onto package hooks. The same
    ;; effect with using '(add-hook)'. The following ':hook' setting is the same:
    ;;
    ;; :init
    ;; (add-hook 'prog-mode-hook #'company-mode))
    ;;
    :hook (prog-mode . company-mode))

    ;; 
    ;; The ':custom' keyword allows customization of package custom variables.
    ;; Same thing with using '(setq NAME VALUE)' in ':init' but with comments.
    ;; The documentation string is not mandatory.
    ;;
    ;; NOTE: these are only for people who wish to keep customizations with their
    ;;       accompanying use-package declarations. Functionally, the only benefit
    ;;       over using setq in a :config block is that customizations might execute
    ;;       code when values are assigned.
    ;; 
    ;; NOTE: The customized values are not saved in the Emacs custom-file. Thus you
    ;;       should either use the :custom option or you should use M-x customize-option
    ;;       which will save customized values in the Emacs custom-file. Do not use both.
    ;;
    :custom
        (comint-buffer-maximum-size 20000 "Increase comint buffer size.")
        (comint-prompt-read-only t "Make the prompt read only."))
    ;;
    ;; The ':disabled' keyword can turn off a module you're having difficulties with, or
    ;; stop loading something you're not using at the present time:
    ;;
    :disabled

    ;;
    ;; Print out the error if you want
    ;;
    :catch (lambda (keyword err)
            (message ">>> Package load failed with error: %s" (error-message-string err)))

  )
#+end_src


** Enable system clipboard

 #+begin_src emacs-lisp
   (use-package xclip
      :config
          (xclip-mode 1)
   )
 #+end_src


** Command log  

#+BEGIN_SRC emacs-lisp
  (use-package command-log-mode
      :defer t
      :config
          (global-command-log-mode 1)
  )
#+END_SRC


** Better help buffer

=Helpful= is a replacement for *help* buffers that provides much more contextual information.

#+BEGIN_SRC emacs-lisp
  (use-package helpful
      :defer t
      ;; ;;
      ;; ;; 'counsel' related configuration
      ;; ;;
      ;; :init
      ;;     (setq counsel-describe-function-function #'helpful-callable)
      ;;     (setq counsel-describe-variable-function #'helpful-variable)
      ;;     :bind
      ;;     ([remap describe-function] . counsel-describe-function)
      ;;     ([remap describe-variable] . counsel-describe-variable)
      ;;     ([remap describe-command] . helpful-command)
      ;;     ([remap describe-key] . helpful-key)
  )
#+END_SRC

Here is what =Helpful= improved, it shows you the help information with the following patterns:


=Signature=
(describe-function FUNCTION)

=Documentation=
Display the full documentation of FUNCTION (a symbol).
......

=View in manual= (Click here will bring you to the detail function document)

=Key Bindings=
.....

=References=
......

=Debugging=
......

=Source Code=
......



** Edit/UX improve related

*** =Olivetti=: works like =Goyo= in =Neovim=

#+BEGIN_SRC emacs-lisp
  (use-package olivetti
    :defer t
    :init
        (setq olivetti-body-width 0.6)
  )
#+END_SRC


*** =which-key=: Display keybinding in group

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :defer t
    :init
        (which-key-setup-side-window-right-bottom)
        (setq which-key-idle-delay 0.2)
        ;; (setq which-key-sort-order 'which-key-local-then-key-order)
        (setq which-key-sort-order 'which-key-prefix-then-key-order)
        (setq which-key-prefix-prefix "> " )
    :config
        (which-key-mode)
  )
#+END_SRC


*** =Highlight indent=

#+begin_src emacs-lisp
  (use-package highlight-indent-guides
    :defer t
    :hook (prog-mode . highlight-indent-guides-mode)
    :config
        ;;(setq highlight-indent-guides-method 'character)
        (setq highlight-indent-guides-method 'column)
        (setq highlight-indent-guides-character ?\|)
        ;;(setq highlight-indent-guides-responsive 'top)
  )
#+end_src


*** =Vertico= complection

=Vertico= is new and lightway completion UI based on the default completion system, it uses all =Emacs= builtin functionalities, no need to add something new (heavery) on top like =Ivy=.

 #+begin_src emacs-lisp
   (use-package vertico
     :init
        (vertico-mode)
        (vertico-multiform-mode)

        ;;
        ;; Configure Vertico modes per command or completion category.
        ;;
        ;; 'buffer' means 'vertico-buffer-mode' to display vertico in a buffer instead of minibuffer
        ;;
        ;; For more details, watch this video: https://www.youtube.com/watch?v=hPwDbx--Waw
        ;;
        (setq vertico-multiform-commands
            '((consult-imenu buffer)
              (consult-ripgrep buffer)
             )
        )

        ;; How many lines needs to show in minibuffer before hit the top or bottom
        (setq vertico-scroll-margin 3)

        ;; Show more lines in minibuffer
        (setq vertico-count 20)

        ;; Grow and shrink the Vertico minibuffer
        ;; (setq vertico-resize t)

        ;; Optionally enable cycling for `vertico-next' and `vertico-previous'.
        (setq vertico-cycle t)

     :config

        ;;
        ;; Auto tidy up the directory prompt when changing to '~' or '/' directory
        ;; This works with 'file-name-shadow-mode' enabled. When you're in the sub directory, and you
        ;; type '~' or '/' path in 'find-file' or 'dired', then 'vertico' clear the old path and keep
        ;; the curent path.
        ;;
        (add-hook 'rfn-eshadow-update-overlay-hook #'vertico-directory-tidy)
   )

   (use-package savehist
    :init
        (savehist-mode)
   )
 #+end_src


**** Extensions

***** Marginalia

Rich annotations in the minibuffer

#+begin_src emacs-lisp
  (use-package marginalia
    ;; Bind `marginalia-cycle' locally in the minibuffer.  To make the binding
    ;; available in the *Completions* buffer, add it to the
    ;; `completion-list-mode-map'.
    :bind (:map minibuffer-local-map
           ("M-A" . marginalia-cycle))
    :init
       ;; Marginalia must be activated in the :init section of use-package such that
       ;; the mode gets enabled right away. Note that this forces loading the
       ;; package.
       (marginalia-mode)
  )
#+end_src


***** Consult

Useful search and navigation commands, here is the best video to explain how it works:
https://www.youtube.com/watch?v=HwBHBwYgs2g

#+begin_src emacs-lisp
  ;; Enable rich annotations using the Marginalia package
  (use-package consult
    :after vertico
  )
#+end_src


Here are the useful commands:

| Function         | Description                                             |
|------------------+---------------------------------------------------------|
| ~consult-imenu~    | The enhanced ~imenu~                                      |
| ~consult-yank-pop~ | List all yanked content, press =RET= to replace at point. |
| ~consult-ripgrep~  | Run ~ripgrep~ and preview                                 |
| ~consult-line~     | Better search like ~/~ or ~*~ but with preview              |


By default ~consult-ripgrep~ runs the search in current (opened-file) directory, if you want to change the search directory, you can run this function directly instead:

#+BEGIN_SRC emacs-lisp :tangle no
  (consult-ripgrep "~/.config/emacs")
#+END_SRC


***** vertico-posframe

=vertico-posframe= is an =vertico= extension, which lets =vertico= use posframe to show its candidate menu.

NOTE: =vertico-posframe= requires Emacs 26 and do not support mouse click.

#+begin_src emacs-lisp
  ;;
  ;; Only enabled in GUI mode!!!
  ;;
  (if (display-graphic-p nil)
    (use-package vertico-posframe
        :after vertico
        :init
            ;;
            ;; The following setting is saying:
            ;;
            ;; All rest 'vertico-multiform-commands' use default popup
            ;; except the 'consult-imenu' and 'consult-ripgrep' (use 'vertico-buffer-mode')
            ;;
            (setq vertico-multiform-commands
                '(
                   (consult-imenu buffer)     ; Uses 'vertico-buffer-mode'
                   (consult-ripgrep buffer)   ; Uses 'vertico-buffer-mode'

                   ;;
                   ;; Use popup as default
                   ;;
                   (t posframe
                       (vertico-posframe-poshandler . posframe-poshandler-frame-center)
                       (vertico-posframe-border-width . 2)
                   )
                 )
            )

            ;; The popup position specified by the 'vertico-posframe-poshandler' and the
            ;; default value is 'posframe-poshandler-frame-center'.
            ;;
            ;; You can change it on your own, the value defined in:
            ;; '~/.config/emacs/elpa/posframe-20230714.227/posframe.el'
            ;;
            ;; The builtin poshandler functions are listed below:
            ;;
            ;; posframe-poshandler-frame-center
            ;; posframe-poshandler-frame-top-center
            ;; posframe-poshandler-frame-top-left-corner
            ;; posframe-poshandler-frame-top-right-corner
            ;; posframe-poshandler-frame-top-left-or-right-other-corner
            ;; posframe-poshandler-frame-bottom-center
            ;; posframe-poshandler-frame-bottom-left-corner
            ;; posframe-poshandler-frame-bottom-right-corner
            ;; posframe-poshandler-window-center
            ;; posframe-poshandler-window-top-center
            ;; posframe-poshandler-window-top-left-corner
            ;; posframe-poshandler-window-top-right-corner
            ;; posframe-poshandler-window-bottom-center
            ;; posframe-poshandler-window-bottom-left-corner
            ;; posframe-poshandler-window-bottom-right-corner
            ;; posframe-poshandler-point-top-left-corner
            ;; posframe-poshandler-point-bottom-left-corner
            ;; posframe-poshandler-point-bottom-left-corner-upward
            ;; posframe-poshandler-point-window-center
            ;; posframe-poshandler-point-frame-center
            ;;
            ;; (setq vertico-posframe-poshandler 'posframe-poshandler-frame-center)

            ;;
            ;; Control popup left and right paddings
            ;;
            (setq vertico-posframe-parameters
                '((left-fringe . 10)
                  (right-fringe . 10)
                 )
            )

        :config
            (vertico-multiform-mode 1)

            ;;
            ;; When enabling 'vertico-multiform-mode', 'vertico-posframe-mode' will be
            ;; activated/deactivated by 'vertico-multiform-mode' dynamically when you
            ;; add ‘posframe’ setting to 'vertico-multiform-commands,' please do not
            ;; enable 'vertico-posframe-mode' globally at the moment!!!
            ;;
            ;; (vertico-posframe-mode 1)
    )
  )
#+end_src



***** Embark

=Embark= allows you to do something (aka, run an action) on the following targets:

- A single item or all items inside the completion list/Minibuffer/imenu result/rg result/etc
- Selection of text

****** Work with =which-key= 

Be able to show keybindings via =which-key=

#+BEGIN_SRC emacs-lisp
  (defun embark-which-key-indicator ()
    "An embark indicator that displays keymaps using which-key.
  The which-key help message will show the type and value of the
  current target followed by an ellipsis if there are further
  targets."
    (lambda (&optional keymap targets prefix)
      (if (null keymap)
          (which-key--hide-popup-ignore-command)
        (which-key--show-keymap
         (if (eq (plist-get (car targets) :type) 'embark-become)
             "Become"
           (format "Act on %s '%s'%s"
                   (plist-get (car targets) :type)
                   (embark--truncate-target (plist-get (car targets) :target))
                   (if (cdr targets) "…" "")))
         (if prefix
             (pcase (lookup-key keymap prefix 'accept-default)
               ((and (pred keymapp) km) km)
               (_ (key-binding prefix 'accept-default)))
           keymap)
         nil nil t (lambda (binding)
                     (not (string-suffix-p "-argument" (cdr binding))))))))
#+END_SRC


****** Install and configure

#+BEGIN_SRC emacs-lisp
  (use-package embark
    :init
      ;; Optionally replace the key help with a completing-read interface
      (setq prefix-help-command #'embark-prefix-help-command)

      ;;
      ;; Work with 'which-key', 'embark-which-key-indicator' must defined!!!
      ;;
      ;; (setq embark-indicators '(embark-which-key-indicator
      ;;                           embark-highlight-indicator
      ;;                           embark-isearch-highlight-indicator)
      ;; )

    :config
      ;;
      ;; Hide the mode line of the Embark live/completions buffers
      ;;
      ;; (add-to-list 'display-buffer-alist
      ;; 						'("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
      ;; 						nil
      ;; 						(window-parameters (mode-line-format . none))))
  )

  ;;
  ;; Consult users will also want the embark-consult package.
  ;;
  (use-package embark-consult
    :hook
        (embark-collect-mode . consult-preview-at-point-mode))
#+END_SRC




*** =evil-mode= and =evil-surround=

**** What is =Evil=

=Evil= is an extensible =vi= layer for =Emacs=. It emulates the main features of =Vim=, turning =Emacs= into a modal editor. Like =Emacs= in general, =Evil= is extensible in =Emacs Lisp=.


**** Evil =modes= and =state=

=Evil= uses the term =state= for what is called a =mode= in regular =vi= usage, because modes are understood in =Emacs= terms to mean something else.

=Evil= defines a number of states by default:

| state                        | description                                                                        |
|------------------------------+------------------------------------------------------------------------------------|
| normal state (<N>)           |                                                                                    |
| insert state (<I>)           |                                                                                    |
| visual state (<V>)           |                                                                                    |
| replace state (<R>)          |                                                                                    |
| operator-pending state (<O>) | A special state entered after launching an operator, but before specifying the     |
|                              | corresponding motion or text object.                                               |
|                              |                                                                                    |
| motion state (<M>)           | A special state useful for buffers that are read-only, where motions are available |
|                              | but editing operations are not.                                                    |
|                              |                                                                                    |
| Emacs state (<E>)            | All =Evil= keybindings are disabled, switch back to original =Emacs= keybindings.      |
|                              |                                                                                    |


By default, toggle between =Evil state= and =Emacs sate= by pressing ~C-z~, but I disabled it (as I need the ~C-z~ to go back to terminal). So I if you need that, you can run ~evil-emacs-state~ and ~evil-normal-state~ manually.

Why you need to the =Emacs state=??? For example, if =Evil= keybinding overwrites the original =Emacs= hotkey, then you need to disable it temporary by going back to =Emacs state=.


**** Evil settings

Important keybindings when using =Evil=:

- =:q= uses to quit the entire =Emacs= client (connection), completely different with =Vim=!!! The function name is  =evil-quit=.

- =:bd= uses to close the current buffer, use this instead of =:q=. The function name is  =kill-current-buffer=.

- =Q= binds to =evil-window-delete= which ONLY used to close the splitted window (but NOT close the related buffer).


#+BEGIN_SRC emacs-lisp
  ;;
  ;; Evil custom settings, you can found all settings here:
  ;; https://evil.readthedocs.io/en/latest/settings.html
  ;;

  ;; Switch between last buffers
  (defun switch-to-last-buffer ()
    (interactive)
    (switch-to-buffer nil))

  ;;
  ;; Set the following mode to 'normal state after 'evil-mode' loaded
  ;;
  ;; Why do this?
  ;; 
  ;; If the buffer switches to 'Evil-Normal-State' by default, then the upcomming
  ;; keybindins "(evil-global-set-key 'normal)" which targets to 'normal' state will
  ;; work automatically.
  ;; 
  ;; That will save a lot of keybinding settings.
  ;;
  (defun rune/evil-hook ()
    (dolist (mode '(helpful-mode
                    help-mode
                    debugger-mode
                    package-menu-mode
                    term-mode
                    custom-mode))
        (evil-set-initial-state mode 'normal)
    )
  )

  (use-package evil
      :init
        (setq evil-auto-indent t          ; Enable auto indent
              evil-echo-state t           ; Don't show the state/mode in status bar
              evil-want-C-u-scroll t      ; Enable <C-u> scroll up
              evil-want-C-i-jump t        ; <C-i> inserts a tab character
              evil-want-Y-yank-to-eol t   ; Enable `Y`: Yank to end of line
              evil-vsplit-window-right t  ; Always vsplit window on the rigth
              evil-want-integration t     ;This is optional since it's already set to t by default.
              evil-want-keybinding nil
        )
      :custom
        (evil-undo-system 'undo-redo)
      :config
        (evil-mode 1)

        ;; Leader key
        (evil-set-leader '(normal visual) (kbd "SPC"))
        (rune/evil-hook)
  )

  (use-package evil-collection
    :after evil
    :config
        (evil-collection-init))
#+END_SRC


**** Evil-surrond settings

#+begin_src emacs-lisp
  (use-package evil-surround
      :init
      (global-evil-surround-mode 1)
      :config
          (add-hook 'org-mode-hook (lambda ()
                                      (push '(?= . ("=" . "=")) evil-surround-pairs-alist)))
  )
#+end_src


**** Evil-goggles settings 

=evil-goggles-mode= displays a visual hint when editing with =evil=.

#+BEGIN_SRC emacs-lisp
  (use-package evil-goggles
    :ensure t
    :init
       ;;
       ;; Only enalbe yank effect, 't' by default
       ;;
       ;; (setq evil-goggles-enable-yank t)

       ;;
       ;; Disable the following effects
       ;;
       (setq evil-goggles-enable-delete nil
             evil-goggles-enable-change nil
             evil-goggles-enable-indent nil
             evil-goggles-enable-join nil
             evil-goggles-enable-fill-and-move nil
             evil-goggles-enable-paste nil
             evil-goggles-enable-shift nil
             evil-goggles-enable-surround nil
             evil-goggles-enable-commentary nil
             evil-goggles-enable-nerd-commenter nil
             evil-goggles-enable-replace-with-register nil
             evil-goggles-enable-set-marker nil
             evil-goggles-enable-undo nil
             evil-goggles-enable-redo nil
             evil-goggles-enable-record-macro nil)
    :config
    (evil-goggles-mode)

    ;; optionally use diff-mode's faces; as a result, deleted text
    ;; will be highlighed with `diff-removed` face which is typically
    ;; some red color (as defined by the color theme)
    ;; other faces such as `diff-added` will be used for other actions
    (evil-goggles-use-diff-faces))
#+END_SRC


*** =Org= mode settings

**** Heading font and =org-bullets= settings

#+BEGIN_SRC emacs-lisp
  (defun my/org-mode-setup()
    (org-indent-mode)           ;; Enable org indent mode
    (variable-pitch-mode -1)
    (visual-line-mode 1)

    ;;
    ;; Heading font size (only works in GUI mode)
    ;; 
    ;; But the following settings only work in =GUI= mode, nothing will happen in =Terminal= mode!!!
    ;;
    (dolist (face '((org-level-1 . 1.8)
		    (org-level-2 . 1.5)
		    (org-level-3 . 1.2)
		    (org-level-4 . 1.1)
		    (org-level-5 . 1.0)
		    (org-level-6 . 1.0)
		    (org-level-7 . 1.0)))
      (set-face-attribute (car face) nil
			  :font "JetBrains Mono Nerd Font"
			  :weight 'regular
			  :height (cdr face))
    )
  )

  (use-package org
     :config
	  (setq org-ellipsis " ......"         ; Ellipsis string when `S-TAB`
		org-hide-emphasis-markers t    ; Hide the marker (bold, link etc)
	  )
	  (add-hook 'org-mode-hook #'my/org-mode-setup)
   )
        

  (use-package org-bullets
    :after org
    :init
      ;;(setq org-bullets-bullet-list '("①" "②" "③" "④" "⑤" "⑥"))
      (setq org-bullets-bullet-list '("➊" "➋" "➌" "➍" "➎" "➏"))
    :config
       (add-hook 'org-mode-hook #'org-bullets-mode)
  )
#+END_SRC


**** =org-auto-tangle=

#+BEGIN_SRC emacs-lisp
  (defun my-enable-org-auto-tangle()
     (message "[ my-enable-org-auto-tangle ]")
     (org-auto-tangle-mode nil)
     (message "[ my-enable-org-auto-tangle ] - Done.")
  )

  (use-package org-auto-tangle
    :after org
    :config
       (add-hook 'org-mode-hook #'my-enable-org-auto-tangle)
  )
#+END_SRC


** Treesitter

*** Install language grammar libraries

Before you can have ~xxx-ts-mode~ (~xxx~ is the language name), you need to walk through the following steps:

**** 1. Set the ~treesit-language-source-alist~ with all langauges you needed:

If you don't set this, you can't run the batch command to install all of them in one-shot (as it will ask you the confirm git URL).

If you can't find the language gammar in =https://github.com/tree-sitter/tree-sitter-xxx=, then take a look at the Neovim treesitter README, it includes some third-party implementations:

=~/.local/share/nvim/site/pack/packer/start/nvim-treesitter/README.md=

#+begin_src emacs-lisp
  (setq treesit-language-source-alist
    '((c "https://github.com/tree-sitter/tree-sitter-c")
      (cpp "https://github.com/tree-sitter/tree-sitter-cpp")
      (zig "https://github.com/maxxnino/tree-sitter-zig")
      (rust "https://github.com/tree-sitter/tree-sitter-rust")
      (bash "https://github.com/tree-sitter/tree-sitter-bash")
      (cmake "https://github.com/uyha/tree-sitter-cmake")
      (css "https://github.com/tree-sitter/tree-sitter-css")
      (elisp "https://github.com/Wilfred/tree-sitter-elisp")
      (go "https://github.com/tree-sitter/tree-sitter-go")
      (html "https://github.com/tree-sitter/tree-sitter-html")
      (javascript "https://github.com/tree-sitter/tree-sitter-javascript" "master" "src")
      (json "https://github.com/tree-sitter/tree-sitter-json")
      (make "https://github.com/alemuller/tree-sitter-make")
      (markdown "https://github.com/ikatyang/tree-sitter-markdown")
      (python "https://github.com/tree-sitter/tree-sitter-python")
      (toml "https://github.com/tree-sitter/tree-sitter-toml")
      (tsx "https://github.com/tree-sitter/tree-sitter-typescript" "master" "tsx/src")
      (typescript "https://github.com/tree-sitter/tree-sitter-typescript" "master" "typescript/src")
      (yaml "https://github.com/ikatyang/tree-sitter-yaml")
      (fish "https://github.com/ram02z/tree-sitter-fish")
     )
  )

  ;;
  ;; Change the default major mode
  ;;
  (add-to-list 'auto-mode-alist '("\\.toml\\'" . toml-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.rs\\'" . rust-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.c\\'" . c-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.h\\'" . c-or-c++-ts-mode))
  (add-to-list 'auto-mode-alist '("CMakeLists.txt" . cmake-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
  (add-to-list 'auto-mode-alist '("\\.fish\\'" . fish-mode))
  (add-to-list 'auto-mode-alist '("lfrc" . bash-mode))
  (add-to-list 'auto-mode-alist '("bspwmrc" . bash-mode))
  (add-to-list 'auto-mode-alist '("\\.clang-format\\'" . bash-mode))
  (add-to-list 'auto-mode-alist '("\\.json\\'" . json-ts-mode))

  ;;
  ;; remap the non-treesitter mode to treesitter mode
  ;;
  (setq major-mode-remap-alist
   '((c-mode . c-ts-mode)
     (c++-mode . c++-ts-mode)
     (bash-mode . bash-ts-mode)
     (sh-mode . bash-ts-mode)
     (cmake-mode . cmake-ts-mode)
     (css-mode . css-ts-mode)
     (elisp-mode . elisp-ts-mode)
     (go-mode . go-ts-mode)
     (html-mode . html-ts-mode)
     (js-mode . js-ts-mode)
     (make-mode . make-ts-mode)
     (json-mode . json-ts-mode)
     (js-json-mode . json-ts-mode)
     (python-mode . python-ts-mode)
     (tsx-mode . tsx-ts-mode)
     (typescript-mode . typescript-ts-mode)
     (yaml-mode . yaml-ts-mode)
    )
  )
#+end_src


**** 2. Install all of them

You can either ~M-x~ then ~treesit-install-language-grammar~ to install one-by-one, or you can run the following batch command to install all of them in one-shot:

#+begin_src emacs-lisp :tangle no
  ;; (mapc #'treesit-install-language-grammar (mapcar #'car treesit-language-source-alist))
#+end_src


They should be installed to your =~/.config/emacs/tree-sitter= folder like this:

#+begin_src bash
  ls -lht tree-sitter/

  # total 9.5M
  # 230K  libtree-sitter-yaml.so*
  # 1.2M  libtree-sitter-typescript.so*
  # 1.2M  libtree-sitter-tsx.so*
  #  40K  libtree-sitter-toml.so*
  # 529K  libtree-sitter-python.so*
  # 825K  libtree-sitter-markdown.so*
  # 168K  libtree-sitter-make.so*
  #  16K  libtree-sitter-json.so*
  # 353K  libtree-sitter-javascript.so*
  #  38K  libtree-sitter-html.so*
  # 300K  libtree-sitter-go.so*
  #  60K  libtree-sitter-elisp.so*
  #  76K  libtree-sitter-css.so*
  # 100K  libtree-sitter-cmake.so*
  # 638K  libtree-sitter-bash.so*
  # 3.2M  libtree-sitter-cpp.so*
  # 668K  libtree-sitter-c.so*
  # 812K  libtree-sitter-zig.so*
  # 829K  libtree-sitter-rust.so*
#+end_src


You can check each of them to see whether has been install successfully or not:

#+begin_src emacs-lisp :tangle no
  ;;
  ;; Return 't' means install successfully
  ;;
  (treesit-language-available-p 'c)
  (treesit-language-available-p 'cpp)
  (treesit-language-available-p 'zig)
  (treesit-language-available-p 'rust)
  (treesit-language-available-p 'bash)
  (treesit-language-available-p 'cmake)
  (treesit-language-available-p 'css)
  (treesit-language-available-p 'elisp)
  (treesit-language-available-p 'go)
  (treesit-language-available-p 'html)
  (treesit-language-available-p 'javascript)
  (treesit-language-available-p 'json)
  (treesit-language-available-p 'make)
  (treesit-language-available-p 'markdown)
  (treesit-language-available-p 'python)
  (treesit-language-available-p 'toml)
  (treesit-language-available-p 'tsx)
  (treesit-language-available-p 'typescript)
  (treesit-language-available-p 'yaml)
  (treesit-language-available-p 'fish)
#+end_src



** Treemacs

A tree layout file explorer for Emacs.

#+BEGIN_SRC emacs-lisp :tangle no
    (use-package treemacs
       :disabled
       :init
       ;;
       ;; Mouse click to show action menu
       ;;
       (with-eval-after-load 'treemacs
           (define-key treemacs-mode-map [mouse-1] #'treemacs-single-click-expand-action))
       :config


       ;;
       ;; Theme
       ;;
       (treemacs-load-theme "Default")

       (progn
           (setq treemacs-collapse-dirs                 (if treemacs-python-executable 3 0)
               treemacs-deferred-git-apply-delay        0.5
               treemacs-directory-name-transformer      #'identity
               treemacs-display-in-side-window          t
               treemacs-eldoc-display                   'simple
               treemacs-file-event-delay                2000
               treemacs-file-extension-regex            treemacs-last-period-regex-value
               treemacs-file-follow-delay               0.2
               treemacs-file-name-transformer           #'identity
               treemacs-follow-after-init               t
               treemacs-expand-after-init               t
               treemacs-find-workspace-method           'find-for-file-or-pick-first
               treemacs-git-command-pipe                ""
               treemacs-goto-tag-strategy               'refetch-index
               treemacs-header-scroll-indicators        '(nil . "^^^^^^")
               treemacs-hide-dot-git-directory          t
               treemacs-indentation                     2
               treemacs-indentation-string              " "
               treemacs-is-never-other-window           nil
               treemacs-max-git-entries                 5000
               treemacs-missing-project-action          'ask
               treemacs-move-forward-on-expand          nil
               treemacs-no-png-images                   nil
               treemacs-no-delete-other-windows         t
               treemacs-project-follow-cleanup          nil
               treemacs-persist-file                    (expand-file-name ".cache/treemacs-persist" user-emacs-directory)
               treemacs-position                        'left
               treemacs-read-string-input               'from-child-frame
               treemacs-recenter-distance               0.1
               treemacs-recenter-after-file-follow      nil
               treemacs-recenter-after-tag-follow       nil
               treemacs-recenter-after-project-jump     'always
               treemacs-recenter-after-project-expand   'on-distance
               treemacs-litter-directories              '("/node_modules" "/.venv" "/.cask")
               treemacs-project-follow-into-home        nil
               treemacs-show-cursor                     nil
               treemacs-show-hidden-files               t
               treemacs-silent-filewatch                nil
               treemacs-silent-refresh                  nil
               treemacs-sorting                         'alphabetic-asc
               treemacs-select-when-already-in-treemacs 'move-back
               treemacs-space-between-root-nodes        t
               treemacs-tag-follow-cleanup              t
               treemacs-tag-follow-delay                1.5
               treemacs-text-scale                      nil
               treemacs-user-mode-line-format           nil
               treemacs-user-header-line-format         nil
               treemacs-wide-toggle-width               70
               treemacs-width                           35
               treemacs-width-increment                 1
               treemacs-width-is-initially-locked       t
               treemacs-workspace-switch-cleanup        nil)

           ;; The default width and height of the icons is 22 pixels. If you are
           ;; using a Hi-DPI display, uncomment this to double the icon size.
           (treemacs-resize-icons 44)

           (treemacs-follow-mode t)
           (treemacs-filewatch-mode t)
           (treemacs-fringe-indicator-mode 'always)
           (when treemacs-python-executable
           (treemacs-git-commit-diff-mode t))

           (pcase (cons (not (null (executable-find "git")))
                       (not (null treemacs-python-executable)))
           (`(t . t)
           (treemacs-git-mode 'deferred))
           (`(t . _)
           (treemacs-git-mode 'simple)))

           (treemacs-hide-gitignored-files-mode nil)

           ;;
           ;; Enable indent guide
           ;;
           (setq treemacs-indent-guide-style 'line)
           (treemacs-indent-guide-mode t)

           ;;
           ;; If you want to look at files from within treemacs, without opening them with 'RET'
           ;; and switching to another window, you can do so with 'P' which activates
           ;; 'treemacs-peek-mode'.
           ;;
           ;; When 'peek-mode' is active treemacs will automatically preview the file at point.
           ;;
           ;; You can scroll the window being peeked (and in general other-window when you are in treemacs)
           ;; with 'M-N/P' or 'M-J/K' if you use treemacs-evil.
           ;;
           (treemacs-peek-mode t)

           ;;
           ;; Allows you to use treemacs icons in dired buffers
           ;;
           ;; (treemacs-icons-dired-mode)

           ;;
           ;; Provides a theme using all-the-icons.
           ;;
           ;;(treemacs-all-the-icons)
       )
  )

  ;;
  ;; evil support
  ;;
  (use-package treemacs-evil
   :disabled
   :after (treemacs evil)
  )

  (use-package treemacs-icons-dired
   :disabled
   :hook (dired-mode . treemacs-icons-dired-enable-once)
   :ensure t)

  ;; (use-package treemacs-projectile
  ;;   :after (treemacs projectile)
  ;;   :ensure t)

  ;; (use-package treemacs-magit
  ;;   :after (treemacs magit)
  ;;   :ensure t)

  ;; (use-package treemacs-persp ;;treemacs-perspective if you use perspective.el vs. persp-mode
  ;;   :after (treemacs persp-mode) ;;or perspective vs. persp-mode
  ;;   :ensure t
  ;;   :config (treemacs-set-scope-type 'Perspectives))

  ;; (use-package treemacs-tab-bar ;;treemacs-tab-bar if you use tab-bar-mode
  ;;   :after (treemacs)
  ;;   :ensure t
  ;;   :config (treemacs-set-scope-type 'Tabs))
#+END_SRC


** Important! Improve ~C-j~ and ~C-k~ for the modes I needed

**** Disable ~C-j~ and ~C-k~ from the following modes

#+BEGIN_SRC emacs-lisp
  (dolist (map (list
                global-map
                evil-window-map
                evil-normal-state-map
                evil-motion-state-map
                ))
      (define-key map (kbd "C-j") nil)
      (define-key map (kbd "C-k") nil)
      ;;(message "State: %s" state);
  )

  (evil-define-key 'normal org-mode-map (kbd "C-j") nil)
  (evil-define-key 'normal org-mode-map (kbd "C-k") nil)
#+END_SRC


**** Enable ~C-j~ and ~C-k~ for the following modes

#+BEGIN_SRC emacs-lisp
  (dolist (map (list
                vertico-map
                ))
    (define-key map (kbd "C-j") 'vertico-next)
    (define-key map (kbd "C-k") 'vertico-previous)
  )

  ;;
  ;; 'org-mode'
  ;;
  (defun my-org-next-heading()
    (interactive)
    (org-forward-heading-same-level nil)
    (evil-scroll-line-to-center nil)
  )

  (defun my-org-previous-heading()
    (interactive)
    (org-backward-heading-same-level nil)
    (evil-scroll-line-to-center nil)
  )

  (evil-define-key 'normal org-mode-map (kbd "C-j") 'my-org-next-heading)
  (evil-define-key 'normal org-mode-map (kbd "C-k") 'my-org-previous-heading)

  ;;
  ;; Bind to the local buffer keymap against the following delay modes
  ;;
  (defun my-markdown-next-heading()
    (interactive)
    (outline-next-visible-heading 1)
    (evil-scroll-line-to-center nil)
  )

  (defun my-markdown-previous-heading()
    (interactive)
    (outline-next-visible-heading -1)
    (evil-scroll-line-to-center nil)
  )

  (defun my-bind-markdown-heading-jumping-local()
    (define-key evil-normal-state-local-map (kbd "C-j") 'my-markdown-next-heading)
    (define-key evil-normal-state-local-map (kbd "C-k") 'my-markdown-previous-heading)
  )

  (dolist (hook '(
                 markdown-mode-hook
                 markdown-view-mode-hook
                 ))
    (add-hook hook #'my-bind-markdown-heading-jumping-local)
  )
#+END_SRC


** =eglot= LSP support

=Emacs Polyglot= is the built-in Emacs LSP client.

- Github: https://github.com/joaotavora/eglot
- Manual: https://joaotavora.github.io/eglot

*** Upgrade to latest version

You can run ~eglot-upgrade-eglot~ to the latest version.


*** Install language server

Before you can active =eglot=, you have to install your language server separated.

**** =clangd=

#+BEGIN_SRC bash
  # For Arch Linux
  doas pacman --refresh --sync clang
#+END_SRC

  
**** =zls=

#+BEGIN_SRC bash
  # Build the `zls` from source:

  mkdir ~/temp/ && cd ~/temp
  git clone --recurse-submodules https://github.com/zigtools/zls
  cd zls
  zig build -Doptimize=ReleaseSafe

  # Then move `./zig-out/bin/zls` to your $PATH folder

  # Remove the repo folder
  cd .. && rm -rf zls
#+END_SRC


**** =rust-analyzer=

#+BEGIN_SRC bash
  # Better to upgrade =rust= to latest version (optional)
  # rustup upgrade

  # Remove the old version that comes from `rustup`
  rm -rf ~/.cargo/bin/rust-analyzer

  # Then install the latest version

  # For Arch Linux
  doas pacman --refresh --sync rust-analyzer
#+END_SRC



**** =Python=

#+BEGIN_SRC bash
  pip install python-lsp-server
  pip install --upgrade autopep8 
#+END_SRC


**** =cmake-language-server=

#+BEGIN_SRC bash
  pip3 install cmake-language-server 
#+END_SRC


*** Setup langauge server list (optional)

~eglot-server-programs~ is the variable that use to list all relationships between =mode= and =language server.

Basically, the default value covers all you need already, you can check it in the github home page:

https://github.com/joaotavora/eglot

If you run ~describe-variable~ on ~eglot-server-programs~, you should be able to see something like the following:

#+BEGIN_SRC emacs-lisp :tangle no
  ;; (((rust-ts-mode rust-mode)
  ;;   "rust-analyzer")
  ;;  (zig-mode "zls")
  ;;  ((cmake-mode cmake-ts-mode)
  ;;   "cmake-language-server")
  ;;  ((js-mode js-ts-mode tsx-ts-mode typescript-ts-mode typescript-mode)
  ;;   "typescript-language-server" "--stdio")
  ;;  ((dockerfile-mode dockerfile-ts-mode)
  ;;   "docker-langserver" "--stdio")
  ;;  ((bash-ts-mode sh-mode)
  ;;   "bash-language-server" "start")
  ;;  ((c-mode c-ts-mode c++-mode c++-ts-mode)
  ;;   .
  ;;       [("clangd" "ccls")
  ;;   ;; ...ignore the rest
  ;; )
#+END_SRC

That said, you don't need to do anything:)

But if you have to use another language servers, then you can have a look at here:

https://joaotavora.github.io/eglot/#Setting-Up-LSP-Servers


*** Start =eglot=

**** Start =eglot= manually

The most common way to start Eglot is to simply visit a source file of a given language and use the command ~M-x eglot~. This starts the language server suitable for the visited file’s =major-mode,= and attempts to connect to it. If the connection to the language server is successful, you will see the =[eglot:project]= indicator on the mode line which reflects the server that was started. 

For example:

#+BEGIN_SRC bash

  #[eglot] Connected! Server `clangd' now managing `(c-ts-mode c-mode c++-mode c++-ts-mode)' buffers in project `ping-pong-tron-legacy'.

#+END_SRC


A single =Eglot= session for a certain =major-mode= usually serves all the buffers under that mode which visit files from the same project, so you don’t need to invoke =M-x eglot= again when you visit another file from the same project which is edited using the same =major-mode.= This is because =Eglot= uses the Emacs project infrastructure, as described in Buffers, Projects, and Eglot, and this knows about files that belong to the same project. Thus, after starting an Eglot session for some buffer, that session is automatically reused when visiting files in the same project with the same =major-mode=.


**** Start =eglot= automatically

***** Fix =tab= issue

Before you setup the start hook, you better to fix the =indentation= style.

****** What is a =style=

A =style= is a named collection of customizations that can be used in C mode and the related modes. There are many of them with very different settings.

For example, this is the default =gnu= style and =linux= style:

#+BEGIN_SRC bash
  # GNU
  # ("gnu"
  #  (c-basic-offset . 2)
  #  (c-comment-only-line-offset 0 . 0)
  #  (c-hanging-braces-alist
  #   (substatement-open before after)
  #   (arglist-cont-nonempty))
  #  (c-offsets-alist
  #   (statement-block-intro . +)
  #   (knr-argdecl-intro . 5)
  #   (substatement-open . +)
  #   (substatement-label . 0)
  #   (label . 0)
  #   (statement-case-open . +)
  #   (statement-cont . +)
  #   (arglist-intro . c-lineup-arglist-intro-after-paren)
  #   (arglist-close . c-lineup-arglist)
  #   (inline-open . 0)
  #   (brace-list-open . +)
  #   (brace-list-intro first c-lineup-2nd-brace-entry-in-arglist c-lineup-class-decl-init-+ +)
  #   (topmost-intro-cont first c-lineup-topmost-intro-cont c-lineup-gnu-DEFUN-intro-cont))
  #  (c-special-indent-hook . c-gnu-impose-minimum)
  #  (c-block-comment-prefix . ""))

  #  Linux
  #  ("linux"
  #   (indent-tabs-mode . t)
  #   (c-basic-offset . 8)
  #   (c-comment-only-line-offset . 0)
  #   (c-hanging-braces-alist
  #    (brace-list-open)
  #    (brace-entry-open)
  #    (substatement-open after)
  #    (block-close . c-snug-do-while)
  #    (arglist-cont-nonempty))
  #   (c-cleanup-list brace-else-brace)
  #   (c-offsets-alist
  #    (statement-block-intro . +)
  #    (knr-argdecl-intro . 0)
  #    (substatement-open . 0)
  #    (substatement-label . 0)
  #    (label . 0)
  #    (statement-cont . +)))

#+END_SRC

As you can see, they're very different in the detail, it effects your indentation (every time you type =(, [, {= and press =<return>= to add a new line, it will cause reindentation. If you pick the wrong one, you got a mess code and it's very annoying!!!

And the variable =c-default-style= to specify the default style for various major modes( NOT just for the =c-mode=), its default value looks like this:

#+BEGIN_SRC bash

  # ((java-mode . "java")
  #  (awk-mode . "awk")
  #  (other . "gnu"))

#+END_SRC

That said except the =java-mode= and =awk-mode=, all the other major modes apply the =gnu= style, that's why your C/C++ code gets messed up!!!

For detailed information, plz take a look at the [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Custom-C-Indent.html][Customizing C Indentation]] chapter.


****** How to set default style

If you only want to change the current buffer style, you can press ~C-c .~ then pick a style and press ~<return>~. Or you can call ~c-set-style~ in CC mode, ~c-ts-mode-set-style~ in =c-ts-mode= based on tree-sitter. But keep that in mind, that setting only affects the current buffer!!!

Here is the way to set the default style via the hook:

#+BEGIN_SRC emacs-lisp
  (setq my-tab-width 4)

  ;;
  ;; 
  ;;
  (defun my-c-style-settings()
      ;;
      ;; Very important to reset!!!
      ;;
      (setq tab-width my-tab-width)                

      ;;
      ;;This setting ONLY for for 'c-mode'!!!
      ;;
      (setq c-default-style "linux")               ;; Default is 'gun'
      (setq c-basic-offset my-tab-width)           ;; Default is 2

      ;;
      ;; In 'c-ts-mode' you have to use another settings!!!
      ;;
      (setq c-ts-mode-indent-style "linux")        ;; Default is 'gun'
      (setq c-ts-mode-indent-offset my-tab-width)  ;; Default is 2

      ;;
      ;; Back to normal TAB behavior rather than 'indent-for-tab-command' 
      ;;
      (define-key evil-insert-state-local-map (kbd "TAB") 'tab-to-tab-stop)

      (message ">>> my-c-style-settings [done]")
  )

  ;; ;;
  ;; ;; In 'c-ts-mode' you have to use another settings!!!
  ;; ;;
  ;; (defun my-c-treesitter-style-settings()
  ;;     (setq c-ts-mode-indent-style "linux")        ;; Default is 'gun'
  ;;     (setq c-ts-mode-indent-offset my-tab-width)  ;; Default is 2
  ;;     (message ">>> my-c-treesitter-style-settings [done]")
  ;; )

  ;;
  ;;
  ;;
  (defun my-emacs-lisp-style-settings()
      (setq tab-width 4)
      (message ">>> my-emacs-lisp-style-settings [done]")
  )

  (add-hook 'c-mode-hook #'my-c-style-settings)
  (add-hook 'c-ts-mode-hook #'my-c-style-settings)
  (add-hook 'c++-ts-mode-hook #'my-c-style-settings)
  (add-hook 'zig-mode-hook #'my-c-style-settings)
  (add-hook 'rust-ts-mode-hook #'my-c-style-settings)
  (add-hook 'python-ts-mode-hook #'my-c-style-settings)
  (add-hook 'emacs-lisp-mode-hook #'my-emacs-lisp-style-settings)
  (add-hook 'cmake-ts-mode-hook #'my-c-style-settings)
#+END_SRC


***** Setup hook to start =eglot=

Here is the way to start =eglot= automatically:

#+BEGIN_SRC emacs-lisp
  (defun start-eglot()
     (eglot-ensure)
     (setq eldoc-echo-area-prefer-doc-buffer t)
     (message ">>> start-elogt")
  )

  (dolist (hook '(c-mode-hook
                  c-ts-mode-hook
                  c++-ts-mode-hook
                  rust-ts-mode-hook
                  zig-mode-hook
                  python-ts-mode-hook 
                  cmake-ts-mode-hook
                  ))
     (add-hook hook #'start-eglot)
  )
#+END_SRC


The following settings try to disable 'inlay-hint', but it seems doesn't work, have no idea why....

#+BEGIN_SRC emacs-lisp :tangle no
  ;; (defun my-eglot-disable-inlay-hint()
  ;;    (message ">>> [ my-eglot-disable-inlay-hint ]")
  ;;    (eglot-inlay-hints-mode -1)
  ;;    (message ">>> [ my-eglot-disable-inlay-hint ] done.")
  ;; )
  ;; 
  ;; (add-hook 'eglot-connect-hook #'my-eglot-disable-inlay-hint)
#+END_SRC


*** Stop =eglot=

If you don't want to run the =eglot= anymore for any reasons, just run =M-x eglot-shutdown=.


*** =eglot= commands

**** M-x eglot

This command adds the current buffer and the file it visits to the group of buffers and files managed by Eglot on behalf of a suitable language server. If a language server for the buffer’s major-mode (see Major Modes in GNU Emacs Manual) is not yet running, it will be started; otherwise the buffer and its file will be added to those managed by an existing server session.


**** M-x eglot-shutdown

This command shuts down a language server. It prompts for a language server to shut down (unless there’s only one server session, and it manages the current buffer). Then the command shuts down the server and stops managing the buffers the server was used for. Emacs features (see Eglot Features) that Eglot configured to work with the language server are restored back to their original configuration.

Normally, this command kills the buffers used for communicating with the language server, but if invoked with a prefix argument C-u, the command doesn’t kill those buffers, allowing them to be used for diagnostics and problem reporting (see Troubleshooting Eglot).


**** M-x eglot-shutdown-all

This command shuts down all the language servers active in the current Emacs session. As with eglot-shutdown, invoking this command with a prefix argument avoids killing the buffers used for communications with the language servers.


**** M-x eglot-rename

This command renames the program symbol (a.k.a. identifier) at point to another name. It prompts for the new name of the symbol, and then modifies all the files in the project which are managed by the language server of the current buffer to implement the renaming.


**** M-x eglot-format

This command reformats the active region according to the language-server rules. If no region is active, it reformats the entire current buffer.


**** M-x eglot-format-buffer

This command reformats the current buffer, in the same manner as eglot-format does.



**** M-x eglot-code-actions

***** M-x eglot-code-action-organize-imports
***** M-x eglot-code-action-quickfix
***** M-x eglot-code-action-extract
***** M-x eglot-code-action-inline
***** M-x eglot-code-action-rewrite


**** M-x eglot-inlay-hints-mode

This command toggles LSP inlay hints on and off for the current buffer. Inlay hints are small text annotations to specific parts of the whole buffer, not unlike diagnostics, but designed to help readability instead of indicating problems. 


**** M-x eglot-stderr-buffer

This command pops up the buffer with the debug info printed by the language server to its standard error stream.


**** M-x eldoc

Ask the ElDoc system for help at point.

***** M-x eldoc-mode

Toggle echo area display of Lisp objects at point (ElDoc mode), it shows the documentation (at point) in the eacho area.

It's enabled by default after =eglot= has beeen executed and it should become the buffer-loca minor mode which you can see it inside the 'modeline'.

If you turn off this mode, the =eldoc-doc-buffer= won't update anymore!!!


***** M-x eldoc-doc-buffer

It opens a buffer and keep updating the documentation (at point) until the buffer has been killed or you turn off the =eldoc-mode=, it's super convenient.

It bounds to =K= by default.


**** M-x flymake-show-buffer-diagnostics

Ask Flymake system to display diagnostics for the current buffer.


**** M-x flymake-show-project-diagnostics

Ask Flymake to list diagnostics for all the files in the current project.


**** M-x xref-find-definitions

Ask Xref to go the definition of the identifier at point.


**** M-x imenu

Let the user navigate the program source code using buffer index, categorizing program elements by syntactic class (class, method, variable, etc.) and offering completion.

Better to use =consult-imenu= instead.


**** M-x completion-at-point

Request completion of the symbol at point.


*** =Company=

Completion to provide a dropdown selection.

#+begin_src emacs-lisp
  (use-package company
    :custom
       (company-minimum-prefix-length 2)
       (company-idle-delay 0.0)
       (company-tooltip-align-annotations t)
       (company-show-numbers t)
       (company-selection-wrap-around t)
       (company-transformers '(company-sort-by-occurrence))
    :config
        ;;
        ;; Enable completion for all buffers
        ;;
        (global-company-mode 1)
  )
#+end_src


*** =Yasnippet= 

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "~/.config/emacs/snippets")

  ;;
  ;; Fix 'company' can't list 'yasnippet' candidates in dropdown list
  ;;
  (defun my-fix-company-yasnippet()
     ;; (add-to-list 'company-backends '(company-capf :with company-yasnippet))

     ;;
     ;; Make 'yassnippet' list first
     ;;
     (add-to-list 'company-backends '(:separate company-yasnippet company-capf))
  )

  (use-package yasnippet
    :config
      ;;
      ;; Enable 'yasnippet' in global minor mode
      ;;
      ;; (yas-global-mode 1)

      ;;
      ;; But I prefer only neable 'yasnippet' in coding mode
      ;;
      (yas-reload-all)

      (add-hook 'c-ts-mode-hook #'yas-minor-mode)
      (add-hook 'c++-ts-mode-hook #'yas-minor-mode)
      (add-hook 'rust-ts-mode-hook #'yas-minor-mode)
      (add-hook 'zig-mode-hook #'yas-minor-mode)
      (add-hook 'zig-mode-hook #'yas-minor-mode)
      (add-hook 'org-mode-hook #'yas-minor-mode)
      (add-hook 'cmake-ts-mode-hook #'yas-minor-mode)

      ;;
      ;; Fix 'company' can't list 'yasnippet' candidates in dropdown list
      ;;
      (add-hook 'eglot-managed-mode-hook #'my-fix-company-yasnippet)
  )
#+END_SRC

**** Where's your snippets

Snippets are located in the ~yas-snippet-dirs~ which I've already set in the ~'load-path~ above.

The folder structure looks like this (aka, ~snippet tables~):

#+BEGIN_SRC bash
#  ~/.config/emacs/snippets
#                    |-- c-ts-mode
#                    |   |-- printf
#                    |-- rust-ts-mode
#                    |   |-- println
#                    |-- zig-mode
#                        |-- print
#+END_SRC


**** Useful commands

| Command                | Description                                         |
|------------------------+-----------------------------------------------------|
| ~yas-describe-tables~    | Show the YASnippet tables for all modes             |
| ~yas-new-snippet~        | Create a new snippet                                |
| ~yas-visit-snippet-file~ | Open exists snippet                                 |
| ~yas-tryout-snippet~     | Open a buffer with given mode to try snippet        |
| ~yas-reload-all~         | Reload all snippets on the fly (good for debugging) |



*** =Comment/Uncomment=

#+begin_src emacs-lisp
  (use-package evil-nerd-commenter
    :after lsp-mode
  )
#+end_src


*** Langauge mode

**** =Zig=

#+begin_src emacs-lisp
  (use-package zig-mode)
#+end_src
 

**** =Rust=

#+begin_src emacs-lisp
  (use-package rust-mode)
#+end_src


**** =Fish=

#+begin_src emacs-lisp
  (use-package fish-mode)
#+end_src


**** =Markdown=

#+begin_src emacs-lisp
  (use-package markdown-mode)
#+end_src


**** =TypeScript=

#+begin_src emacs-lisp :tangle no
  ;; (use-package typescript-mode
  ;;   :mode "\\.ts\\'"
  ;;   :hook (typescript-mode . lsp-deferred)
  ;;   :config
  ;;   (setq typescript-indent-level 4)
  ;; )
#+end_src


**** =Web=

#+begin_src emacs-lisp :tangle no
  ;; (use-package web-mode
  ;;   :config
  ;;       (setq web-mode-markup-indent-offset 4
  ;;             web-mode-css-indent-offset 4
  ;;             web-mode-code-indent-offset 4
  ;;             web-mode-style-padding 4
  ;;             web-mode-script-padding 4
  ;;             web-mode-enable-auto-closing t
  ;;             web-mode-enable-auto-opening t
  ;;             web-mode-enable-auto-pairing t
  ;;             web-mode-enable-auto-indentation t)
  ;;   :mode
  ;;       (".html$" "*css$" "*.tsx")
  ;; )
#+end_src


**** =Python=

#+begin_src emacs-lisp :tangle no
  ;; (use-package lsp-pyright
  ;;     :hook (python-mode . (lambda ()
  ;;             (setq indent-tabs-mode t)
  ;;             (setq tab-width 4)
  ;;             (setq python-indent-offset 4)
  ;;             (company-mode 1)
  ;;             (require 'lsp-pyright)
  ;;             (pyvenv-autoload)
  ;;             (lsp))
  ;;     )
  ;; )
#+end_src
 




** Color theme

*** =Nerd icons=

#+BEGIN_SRC emacs-lisp :tangle no
  ;; (use-package nerd-icons)
#+END_SRC

After =nerd-icons= has been installed, you need to run ~nerd-icons-install-fonts~ once to install particular icon font until you can see the nerd icons!!!


*** ++All-the-icons (=treemacs= depends on this fonts)+

Another option you can choose is =all-the-icons= (But I disabled at this momment, as I use =nerd-icons=).

#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons)
#+END_SRC

After =all-the-icons= has been installed, you need to run ~all-the-icons-install-fonts~ once to install particular icon font until you can see the icons!!!


*** +Doom themes+

This package includes a lot of color themes.

#+BEGIN_SRC emacs-lisp
  (use-package doom-themes
      :config
      ;; Global settings (defaults)
      (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
            doom-themes-enable-italic t) ; if nil, italics is universally disabled

      ;; Load theme, pick the one you like
      ;; (load-theme 'doom-gruvbox t)
      ;;(load-theme 'doom-nord-aurora t)
      (load-theme 'doom-one t)
      ;;(load-theme 'doom-solarized-dark t)
      ;;(load-theme 'doom-solarized-light t)
      ;;(load-theme 'doom-pine t)
      ;;(load-theme 'doom-zenburn t)
      ;;(load-theme 'doom-laserwave t)
      ;;(load-theme 'doom-henna t)
      ;;(load-theme 'doom-xcode t)
      ;; (load-theme 'doom-lantern t)
      ;;(load-theme 'doom-miramare t)
      ;;(load-theme 'doom-old-hope t)

      ;; Enable flashing mode-line on errors
      ;;(doom-themes-visual-bell-config)

      ;; Enable custom neotree theme (all-the-icons must be installed!)
      (doom-themes-neotree-config)
      ;; or for treemacs users
      (setq doom-themes-treemacs-theme "doom-atom") ; use "doom-colors" for less minimal icon theme
      (doom-themes-treemacs-config)
      ;; Corrects (and improves) org-mode's native fontification.
      (doom-themes-org-config)
    )
#+END_SRC


**** How to customize any theme you're using???

Basically, you can use ~describe-variable~ and put your theme name there and ~tab~ to see what theme variable you can use, then pick any one of them to go to the help document.

After that, you can click the theme source code link and you're able to customize from the source code:)

For example, the current theme link in the theme variable help document, put your cursor to the =doom-solarized-light-theme.el= and press ~RET~. Modify all colors you want and save, then reload:)

=doom-solarized-light-padded-modeline= is a variable defined in =doom-solarized-light-theme.el=.


*** +Doom modeline (status bar concept in =Vim=)+

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package doom-modeline
    :disabled
    :after doom-themes
    :init
        (setq doom-modeline-buffer-file-name-style 'truncate-from-project)
        (setq nerd-icons-color-icons nil)
        (doom-modeline-mode 1)
  )
#+END_SRC


*** =Tron-legacy-theme=

**** +This is the original version which I don't use anymore+

#+BEGIN_SRC emacs-lisp :tangle no
  ;; (use-package tron-legacy-theme
  ;;    :init
  ;;    :config
  ;;        ;; Gloden cursor, only effects the 'GUI' mode
  ;;        (setq tron-legacy-theme-vivid-cursor t)

  ;;        ;; The foreground to be dimmed and comments to be brighter
  ;;        ;; (setq tron-legacy-theme-dark-fg-bright-comments t)

  ;;        ;; changes the background color to a dark gunmetal grey,
  ;;        ;; instead of the default pure black. It doesn't work, as I
  ;;        ;; set a solid background color in 'settings.org'!!!
  ;;        ;; (setq tron-legacy-theme-softer-bg t)

  ;;        (load-theme 'tron-legacy t)
  ;; )
#+END_SRC


**** This is my modified version

I modified the =tron-legacy-theme= and place it in =~/.config/emacs/themes=.

Here are the steps to modify the setting on the fly:

1. Open =~/.config/emacs/themes/my-tron-legacy-theme.el= and change colors

2. Run ~M-x byte-recompile-file~ to re-generate the =~/.config/emacs/themes/my-tron-legacy-theme.elc=

3. In any =emacs= instance, run ~(load-theme 'my-tron-legacy t)~ to take affect.


#+BEGIN_SRC emacs-lisp :tangle no
  (add-to-list 'custom-theme-load-path "~/.config/emacs/themes/")

  ;; Gloden cursor, only effects the 'GUI' mode
  (setq tron-legacy-theme-vivid-cursor t)

  ;; The foreground to be dimmed and comments to be brighter
  ;; (setq tron-legacy-theme-dark-fg-bright-comments t)

  ;; changes the background color to a dark gunmetal grey,
  ;; instead of the default pure black. It doesn't work, as I
  ;; set a solid background color in 'settings.org'!!!
  ;; (setq tron-legacy-theme-softer-bg t)

  (load-theme 'my-tron-legacy t)
#+END_SRC


*** My custom modeline

**** What is ~mode-line-format~

~mode-line-format~ is the variable that you should set a formatted string to represent your custom mode line.

This is the default ~mode-line-format~ value:

#+BEGIN_SRC emacs-lisp :tangle no
  ("%e" mode-line-front-space
   (:propertize
    ("" mode-line-mule-info mode-line-client mode-line-modified mode-line-remote)
    display
    (min-width
     (5.0)))
   mode-line-frame-identification mode-line-buffer-identification "   " mode-line-position evil-mode-line-tag
   (vc-mode vc-mode)
   "  " mode-line-modes mode-line-misc-info mode-line-end-spaces)
#+END_SRC


When =eglot= enabled, ~(eglot--mode-line-format)~ get called and add its extra info to the =mode-line-misc-info=. That said you SHOULD include =mode-line-misc-info= in your custom =mode-line-format= if want the =eglot= to be shown.

#+BEGIN_SRC emacs-lisp :tangle no
  (add-to-list 'mode-line-misc-info
               `(eglot--managed-mode (" [" eglot--mode-line-format "] ")))
#+END_SRC


**** How to customize ~mode-line-format~

Here are the steps to customize your own mode line:

1. Use ~defvar~ to declare your own variables that will be used in the ~mode-line-format~ strintg value.

2. After you ~defvar~ your own variables, you have to use ~put~ to add the ~risky-local-variable~ property to it and set that property's value to ~t~!!!

3. Use ~(setq-default mode-line-format '())~ to customize your mode line and that's it:)


Here are some useful functions you will use to customize your ~mode-line-format~:

| Function name               | Description                                                                |
|-----------------------------+----------------------------------------------------------------------------|
| ~propertize~                  | Return a copy of STRING with text properties added, for example add        |
|                             | custom face (font) to the string.                                          |
| ~major-mode~                  | Symbol for current buffers major mode.                                     |
| ~symbol-name~                 | Return SYMBOL's name, a string.                                            |
| ~capitalize~                  | Convert argument to capitalized form and return that.                      |
| ~put~                         | Store SYMBOL's PROPNAME property with value VALUE.                         |
| ~defface~                     | Declare FACE (font settings) as a customizable face that defaults to SPEC. |
| ~mode-line-window-selected-p~ | ~t~ when updating the mode line for the active window                        |



**** +Fion colors+

#+BEGIN_SRC emacs-lisp

  (set-face-attribute 'mode-line-active nil :background "systemGreenColor")
  ;; Function name
  (set-face-attribute 'font-lock-function-name-face nil :foreground "#2AA198" :weight 'bold)
  ;; docstring
  (set-face-attribute 'font-lock-doc-face nil :foreground "#96A7A9" :weight 'normal)
  ;; comment
  (set-face-attribute 'font-lock-comment-delimiter-face nil :weight 'normal)
  (set-face-attribute 'font-lock-comment-face nil :weight 'normal)
#+END_SRC

**** My ~mode-line-format~ settings

Read the comment carefully to understand how it works:

#+BEGIN_SRC emacs-lisp
  ;; -------------------------------------------------------------------------------
  ;; All custom faces (font settings)
  ;; -------------------------------------------------------------------------------
  (defface my-modeline-light-blue-font '((t :foreground "#ACE6FE" :inherit italic bold)) "Modeline light blue font")
  (defface my-modeline-blue-green-font '((t :foreground "#4BB5BE")) "Modeline blue-green font")
  (defface my-modeline-light-orange-font '((t :foreground "#DEB45B")) "Modeline light-orange font")
  (defface my-modeline-orange-font '((t :foreground "#FF9F1C")) "Modeline orange font")
  (defface my-modeline-yellow-font '((t :foreground "#FFE64D")) "Modeline yellow font")
  (defface my-modeline-light-red-font '((t :foreground "#f44747")) "Modeline light-red font")
  (defface my-modeline-light-green-font '((t :foreground "#BBF0EF")) "Modeline light-green font")
  (defface my-modeline-dark-green-font '((t :foreground "#5A7387")) "Modeline dark-green font")
  (defface my-modeline-purple-font '((t :foreground "systemPurpleColor")) "Modeline purple font")
  (defface my-modeline-indigo-font '((t :foreground "systemIndigoColor")) "Modeline indigo font")
  (defface my-modeline-black-font '((t :foreground "gridColor")) "Modeline black font")



  ;; -------------------------------------------------------------------------------
  ;; Override the default face for change mode line background
  ;; -------------------------------------------------------------------------------
  (set-face-attribute 'mode-line-active nil :background "#31033d")
  (set-face-attribute 'mode-line-inactive nil :background "#322f33")


  ;; -------------------------------------------------------------------------------
  ;; All modeline variables
  ;; -------------------------------------------------------------------------------

  ;;
  ;; 'my-modeline-major-mode' variable related
  ;;
  (defun my-get-major-mode()
    "Return 'major-mode' as a string."
    (string-replace "-mode" "" (symbol-name major-mode)))

  (defun my-get-major-mode-capitalize()
    "Return capitalized 'major-mode' as a string."
    (capitalize (string-replace "-mode" "" (symbol-name major-mode))))

  (defvar-local my-modeline-major-mode
    '(:eval
        (propertize (my-get-major-mode) 'face 'my-modeline-indigo-font))
    "Mode line constructor to display major mode"
  )

  ;;
  ;; 'my-modeline-buffer-name' variable related
  ;;
  (defun my-get-current-name () 
     (if (mode-line-window-selected-p)
         (buffer-name)
         (format " %s" (buffer-name))
     )
  )

  (defvar-local my-modeline-buffer-name
    '(:eval
        (propertize (my-get-current-name) 'face 'my-modeline-black-font))
    "Mode line constructor to display buffer name"
  )

  (defvar-local my-modeline-buffer-file-name
    '(:eval
        (propertize (format " %s" (buffer-file-name)) 'face 'my-modeline-dark-green-font))
    "Mode line constructor to display buffer name"
  )

  ;;
  ;; 'my-modeline-evil-state' variable related
  ;;
  (defun my-get-evil-state()
    "Return 'evil-state' as a string."
    (format " %s  " (upcase (symbol-name evil-state))))

  (defvar-local my-modeline-evil-state
    '(:eval
        (when (mode-line-window-selected-p)
           (propertize (my-get-evil-state) 'face 'my-modeline-dark-green-font)))
    "Mode line constructor to display current evil state"
  )


  ;;
  ;; 'my-modeline-git-branch' variable related
  ;;
  (defun my-get-git-branch-name()
     (format "%s %s" (nerd-icons-mdicon "nf-md-source_branch") (substring vc 5))
  )

  (defvar-local my-modeline-git-branch
    '(:eval
        (when (mode-line-window-selected-p)
            (when-let (vc vc-mode)
                (propertize (my-get-git-branch-name) 'face 'my-modeline-yellow-font)
            ))
     )
  )

  ;;
  ;; 'my-modeline-flymake' variable related
  ;;
  (declare-function flymake--severity "flymake" (type))
  (declare-function flymake-diagnostic-type "flymake" (diag))

  ;; Based on `flymake--mode-line-counter'.
  (defun prot-modeline-flymake-counter (type)
    "Compute number of diagnostics in buffer with TYPE's severity.
  TYPE is usually keyword `:error', `:warning' or `:note'."
    (let ((count 0))
      (dolist (d (flymake-diagnostics))
        (when (= (flymake--severity type)
                 (flymake--severity (flymake-diagnostic-type d)))
          (cl-incf count)))
      (when (cl-plusp count)
        (number-to-string count))))

  (defun my-get-lsp-error-indicator()
    ;; (insert (nerd-icons-octicon "nf-oct-bug"))  2
    ;; (insert (nerd-icons-codicon "nf-cod-bug"))  2
    ;; (insert (nerd-icons-faicon "nf-fa-bug"))    2
    (nerd-icons-octicon "nf-oct-bug")
  )

  (defun my-modeline-flymake-error()
     (when-let (count (prot-modeline-flymake-counter (intern ":error")))
         (propertize
             (format " %s %s" (my-get-lsp-error-indicator) count)
             'face
             'my-modeline-light-red-font)
     )
  )

  (defun my-get-lsp-warning-indicator()
    ;; (insert (nerd-icons-octicon "nf-oct-copilot_warning"))  2
    ;; (insert (nerd-icons-codicon "nf-cod-warning"))          2
    ;; (insert (nerd-icons-faicon "nf-fa-warning"))            2
    (nerd-icons-faicon "nf-fa-warning")
  )

  (defun my-modeline-flymake-warning()
     (when-let (count (prot-modeline-flymake-counter (intern ":warning")))
         (propertize
             (format " %s %s" (my-get-lsp-warning-indicator) count)
             'face
             'my-modeline-yellow-font)
     )
  )

  (defun my-get-lsp-note-indicator()
    ;; (insert (nerd-icons-faicon "nf-fa-exclamation"))          2
    ;; (insert (nerd-icons-mdicon "nf-md-exclamation_thick"))   󱈸 2
    ;; (insert (nerd-icons-faicon "nf-fa-exclamation_circle"))   2
    (nerd-icons-faicon "nf-fa-exclamation_circle")
  )

  (defun my-modeline-flymake-note()
     (when-let (count (prot-modeline-flymake-counter (intern ":note")))
         (propertize
             (format " %s %s" (my-get-lsp-note-indicator) count)
             'face
             'my-modeline-dark-green-font)
     )
  )

  (defvar-local my-modeline-flymake
      `(:eval
        (when (and (bound-and-true-p flymake-mode)
                   (mode-line-window-selected-p))
          (list
           '(:eval (my-modeline-flymake-error))
           '(:eval (my-modeline-flymake-warning))
           '(:eval (my-modeline-flymake-note))
           )))
    "Mode line construct displaying `flymake-mode-line-format'.
  Specific to the current window's mode line.")


  ;;
  ;; 'my-modeline-misc-info' variable related
  ;;
  (defvar-local my-modeline-misc-info
      '(:eval
        (when (mode-line-window-selected-p)
          mode-line-misc-info))
    "Mode line construct displaying `mode-line-misc-info'.
  Specific to the current window's mode line.")


  ;; -------------------------------------------------------------------------------
  ;; Keep that in mind: Each mode line variable (insdie the 'mode-line-format') must have
  ;; the 'risky-local-variable' property and set to 't'!!!
  ;; -------------------------------------------------------------------------------
  (dolist (my-var '(my-modeline-major-mode
                    my-modeline-buffer-name
                    my-modeline-evil-state
                    my-modeline-git-branch
                    my-modeline-flymake
                                        my-modeline-misc-info))
    (put my-var 'risky-local-variable t)
  )



  ;; -------------------------------------------------------------------------------
  ;;
  ;; Set the 'mode-line-format' as default value.
  ;;
  ;; - If you use 'setq' here, then it only applies to the current local buffer, but you see
  ;; the instant effects.
  ;;
  ;; - If you use 'setq-default' here, then it applies to all buffersc, but you can't see
  ;; the instant effects until re-launch Emacs.
  ;; -------------------------------------------------------------------------------
  (setq-default mode-line-format
    '("%e"
      my-modeline-evil-state
      my-modeline-buffer-name
      "  "
      ;;(:eval (format "MODE: %s" (propertize (symbol-name major-mode) 'face 'warning)))
      my-modeline-major-mode
      "  "
      my-modeline-git-branch
      "  "
      my-modeline-flymake
      "  "
      my-modeline-misc-info
      )
  )
#+END_SRC



*** How to customize font colors in Emacs

**** 1. Open a buffer in the =mode= that you want to change the color and run ~describe-face~ to get all current buffer =face= (font name) list.

**** 2. Choose the =face= name and press ~<return>~ then you see all the font and color settings in the new buffer.

**** 3. Change the =face= attribute settings for that particular =face=.

You can use ~(set-face-attribute FACE FRAME &rest ARGS)~ to change the given font attributes.

- If ~FRAME~ is a frame, set the FACE's attributes only for that frame.  If ~FRAME~ is =nil=, set attribute values for all existing frames, as well as the default for new frames.  If ~FRAME~ is =t=, change the default values of attributes for new frames.

- ~ARGS~ must come in pairs ATTRIBUTE VALUE.  ATTRIBUTE must be a valid face attribute name and VALUE must be a value that is valid for ATTRIBUTE, as described below for each attribute.


Take the =org-level-1= as an example:

    #+begin_src emacs-lisp :tangle no
      ;;
      ;; Transparent background color
      ;;
      (set-face-attribute 'org-level-1 nil :background nil)

      ;;
      ;; Background color
      ;;
      (set-face-attribute 'org-level-1 nil :background "olivedrab")

      ;;
      ;; Font color
      ;;
      (set-face-attribute 'org-level-1 nil :foreground "olivedrab")
    #+end_src


   Example to set default font color (but keep the background color doesn't change):

   #+begin_src emacs-lisp :tangle no
     (set-face-attribute 'default nil :foreground "#ACE6FE")
   #+end_src


**** 4. How to get the color string?

   Run ~list-color-display~, then pick name string:)


**** 5. Optional, show color as background on the color string

   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package rainbow-mode)
   #+END_SRC



** =org-roam=

#+BEGIN_SRC emacs-lisp
  (use-package org-roam
    :custom
    (org-roam-directory (file-truename "~/sbzi/personal/org-roam"))
   ;; :bind (("<leader> n l" . org-roam-buffer-toggle)
   ;;        ("<leader> n f" . org-roam-node-find)
   ;;        ("<leader> n g" . org-roam-graph)
   ;;        ("<leader> n i" . org-roam-node-insert)
   ;;        ("<leader> n c" . org-roam-capture)
   ;;        ;; Dailies
   ;;        ("<leader> n j" . org-roam-dailies-capture-today))
    :config
    ;; If you're using a vertical completion framework, you might want a more informative completion interface
    (setq org-roam-node-display-template (concat "${title:*} " (propertize "${tags:10}" 'face 'org-tag)))
    (org-roam-db-autosync-mode)
    ;; If using org-roam-protocol
    (require 'org-roam-protocol))
#+END_SRC


** History and auto save
** 界面
*** 窗口外观
#+begin_src elisp
  (setq default-frame-alist '((fullscreen . maximized))) ; 全屏
  ;; (set-frame-parameter nil 'undecorated t)
  ;; (add-to-list 'default-frame-alist '(drag-internal-border . 1))
  ;; (add-to-list 'default-frame-alist '(internal-border-width . 5))
  (defun my/set-window ()
  (interactive)
    (unless my/is-termux ; 终端下以下设置不可用
      (tool-bar-mode 0) ; 禁用工具栏
      (scroll-bar-mode 0)) ; 禁用滚动条
    (menu-bar-mode 0) ; 禁用菜单栏
    )
#+end_src
*** 折叠
#+begin_src elisp
(setq my/enable-folding (not my/is-terminal))
#+end_src


* My keybindings

** basic note
1. All my custom keybindings have a pattern:

    =<leader>xxx= is equal to =C-c xxx=

    That said I can use =s-c xxx= (means =Command-c xxx=) in terminal, as I map the =CMD-c= (from MacOS Parallels Desktop) to =C-c= (in Arch Linux VM).


2. About =Evil state=

    =Evil mode= has the following =state keymaps= you can used to set your own keybindings:

    + evil-insert-state-map
    + evil-emacs-state-map
    + evil-normal-state-map
    + evil-visual-state-map
    + evil-motion-state-map
    + evil-operator-state-map
    + evil-outer-text-objects-map
    + evil-inner-text-objects-map
    + evil-replace-state-map
    + evil-normal-state-local-map

    The main reason =motion= state exists is for use with =read-only= modes where insertion keybindings aren’t useful. 

    If you bind key to =montion= state, that means you bind the key to =normal, visual and operator= state as well. That's quite convenient to save a lot of bindings!!!

*** Toggle spell checking

#+BEGIN_SRC emacs-lisp
   (dolist (map (list
                 evil-motion-state-map
                 ))
     (define-key map (kbd "<leader>sp") 'flyspell-mode)
     (define-key map (kbd "C-c s p") 'flyspell-mode)
   )
#+END_SRC

*** Control whether enable =which-key= customize description or not

By default, =which-key= only show the function name with the keybindings like below:

#+BEGIN_SRC
 b → consult-buffer 
 o → +prefix
#+END_SRC

That's fine but not very convenient, as I might forget what the ~o~ prefix means. By using the following settings:

#+BEGIN_SRC emacs-lisp :tangle no
  (which-key-add-key-based-replacements "b" "Switch to buffer")
  (which-key-add-key-based-replacements "o" "(Quick) Open...")
#+END_SRC

Then I got a better =which-key= list like this:

#+BEGIN_SRC
 b → Switch to buffer
 o → (Quick) Open...
#+END_SRC


That means I need to write a lot of ~(which-key-add-key-based-replacements)~ function calls for all of my keybindings, but what if I don't need that (or I prefer to switch back to the original function name display style)? So, for a better choice, I add a global variable ~my-enable-which-key-customized-description~ to enable or disbale that feature just by setting it to ~t~ or ~nil~:

#+BEGIN_SRC emacs-lisp
  ;;
  ;; Enable
  ;;
  (setq my-enable-which-key-customized-description t)

  ;;
  ;; Disable
  ;;
  ;; (setq my-enable-which-key-customized-description nil)
#+END_SRC


*** Unbind all keybindings for the following modes

Why do this?

For example the =help-mode-map= already have the default keybinding like =SPC= to scrollup, that said all =<leader>xx= evil binding won't work, as =<leader>= key is =SPC=.

That's why I unbind all of those buffer mode maps I don't care, this make the evil binding works!!!

#+begin_src emacs-lisp 
  (setf (cdr help-mode-map) nil)
#+end_src


*** =ESC= acts like ~C-g~

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)
#+END_SRC


*** Disable ~C-z~

By default, evil bind ~C-z~ to toggle between =evil-state= and =emacs-state=, but I don't need that.

#+BEGIN_SRC emacs-lisp
  (dolist (map (list
                evil-insert-state-map
                evil-motion-state-map
                ))
      (define-key map (kbd "C-z") nil)
  )
#+END_SRC


*** Fix =error: Key sequence SPC X starts with non-prefix key SPC=

#+BEGIN_SRC emacs-lisp
  (define-key evil-motion-state-map (kbd "<SPC>") nil)
  (define-key evil-normal-state-map (kbd "<SPC>") nil)
#+END_SRC



** Kill current window: ~Q~ and exit =Emacs=: ~<leader>q~

#+BEGIN_SRC emacs-lisp
  (dolist (map (list
                evil-motion-state-map
                evil-normal-state-map
                ))
      (define-key map (kbd "Q") 'delete-window)
      (define-key map (kbd "SPC q q") 'save-buffers-kill-terminal)
      (define-key map (kbd "C-c q q") 'save-buffers-kill-terminal)
      ;; (message ">>> bind 'Q/<leader>q/C-c q' in '%s'" map);
  )


  ;;
  ;; Bind to the local buffer keymap against the following delay modes
  ;;
  (defun my-bind-q-kill-current-window-local()
    (define-key evil-normal-state-local-map (kbd "Q") 'delete-window)
  )

  (dolist (hook '(
                 dired-mode-hook
                 xref--xref-buffer-mode-hook
                 ))
    (add-hook hook #'my-bind-q-kill-current-window-local)
  )

  (if my-enable-which-key-customized-description
      (progn
          (which-key-add-key-based-replacements "SPC q q" "Save and exit")
          (which-key-add-key-based-replacements "C-c q q" "Save and exit")
      ))
#+END_SRC


** Call =describe-xxxx= functions: ~<leader>df/v/k/b~

#+BEGIN_SRC emacs-lisp
  (dolist (map (list
                evil-motion-state-map
                evil-normal-state-map
                ))
    (define-key map (kbd "SPC d f") 'helpful-callable)
    (define-key map (kbd "C-c d f") 'helpful-callable)
    (define-key map (kbd "SPC d v") 'helpful-variable)
    (define-key map (kbd "C-c d v") 'helpful-variable)
    (define-key map (kbd "SPC d k") 'describe-key)
    (define-key map (kbd "C-c d k") 'helpful-key)
    (define-key map (kbd "SPC d b") 'describe-bindings)
    (define-key map (kbd "C-c d b") 'describe-bindings)
    (define-key map (kbd "SPC d m") 'describe-mode)
    (define-key map (kbd "C-c d m") 'describe-mode)
    ;;(message "State: %s" state);
  )

  (if my-enable-which-key-customized-description
      (progn
          (which-key-add-key-based-replacements "SPC d" "Describe ...")
          (which-key-add-key-based-replacements "C-c d" "Describe ...")

          (which-key-add-key-based-replacements "SPC d f" "Function")
          (which-key-add-key-based-replacements "C-c d f" "Function")
          (which-key-add-key-based-replacements "SPC d v" "Variable")
          (which-key-add-key-based-replacements "C-c d v" "Variable")
          (which-key-add-key-based-replacements "SPC d k" "Keys")
          (which-key-add-key-based-replacements "C-c d k" "Keys")
          (which-key-add-key-based-replacements "SPC d m" "Mode")
          (which-key-add-key-based-replacements "C-c d m" "Mode")
          (which-key-add-key-based-replacements "SPC d b" "Bindings")
          (which-key-add-key-based-replacements "C-c d b" "Bindings")
      ))
#+END_SRC


** Toggle-command-log-mode: ~<leader>l~

#+BEGIN_SRC emacs-lisp
  (dolist (map (list
                evil-motion-state-map
                ))
    (define-key map (kbd "SPC l") 'clm/toggle-command-log-buffer)
    (define-key map (kbd "C-c l") 'clm/toggle-command-log-buffer)
  )

  (if my-enable-which-key-customized-description
      (progn
          (which-key-add-key-based-replacements "SPC l" "Command Log")
          (which-key-add-key-based-replacements "C-c l" "Command Log")
      ))
#+END_SRC


** Evaluate lisp expression: ~<leader>ee~

#+BEGIN_SRC emacs-lisp
  (dolist (map (list
                evil-motion-state-map
                ))
    (define-key map (kbd "SPC e e") 'eval-last-sexp)
    (define-key map (kbd "C-c e e") 'eval-last-sexp)
  )

  (if my-enable-which-key-customized-description
      (progn
          (which-key-add-key-based-replacements "SPC e" "Evalute/Emoji")
          (which-key-add-key-based-replacements "C-c e" "Evalute/Emoji")
          (which-key-add-key-based-replacements "SPC e e" "Evalute Lisp")
          (which-key-add-key-based-replacements "C-c e e" "Evalute Lisp")
      ))
#+END_SRC



** Save =buffer=: ~W~

#+BEGIN_SRC emacs-lisp
  (dolist (map (list
                evil-motion-state-map
                ))
    (define-key map (kbd "W") 'save-buffer)
  )
#+END_SRC


** Go back to normal mode: ~jj~

#+BEGIN_SRC emacs-lisp
  (defun xwl-jj-as-esc ()
  (interactive)
  (if (memq evil-state '(insert replace))
      (let ((changed? (buffer-modified-p)))
          (insert "j")
          (let* ((tm (current-time))
              (ch (read-key)))
          (if (and (eq ch ?j)
                  (< (time-to-seconds (time-since tm)) 0.3))
              (save-excursion
                  (delete-char -1)
                  (evil-force-normal-state)
                  (set-buffer-modified-p changed?))
              (insert ch))))
  (call-interactively 'evil-next-line)))

  (define-key evil-insert-state-map  "j" 'xwl-jj-as-esc)
  (define-key evil-replace-state-map "j" 'xwl-jj-as-esc)
#+END_SRC


** Move cursor to beginning: ~H~ and ending of the line: ~L~

#+BEGIN_SRC emacs-lisp
  (dolist (map (list
                evil-motion-state-map
                ))
    (define-key map (kbd "H") 'evil-first-non-blank)
    (define-key map (kbd "L") 'evil-end-of-line)
    ;;(message "State: %s" state);
  )
#+END_SRC


** Go back to last marked position: ~gb~

I can't call ~evil-set-mark~ in my custom function, as it calls ~read-char~ when the function runs, so I can't pass a char in that way.

As a workaround, I can use the default evil keybinding =m= to set a =M= to current position, MAKE SURE that's an uppercase =M=, otherwise, you can go back if you jump to another buffer!!!

#+BEGIN_SRC emacs-lisp
  (defun my-goto-last-marked-position()
    (interactive)
    (evil-goto-mark ?M)
  )

  (dolist (map (list
                evil-motion-state-map
                ))
      (define-key map (kbd "gb") 'my-goto-last-marked-position)
      ;;(message "State: %s" state);
  )

  (if my-enable-which-key-customized-description
      (progn
          (which-key-add-key-based-replacements "gb" "Go back")
      ))
#+END_SRC


** Open =files= or =buffers=: ~<leader>f/b~

#+BEGIN_SRC emacs-lisp
  (dolist (map (list
                evil-motion-state-map
                ))
    (define-key map (kbd "SPC f") 'find-file)
    (define-key map (kbd "C-c f") 'find-file)
    (define-key map (kbd "SPC b") 'consult-buffer)
    (define-key map (kbd "C-c b") 'consult-buffer)
  )

  (if my-enable-which-key-customized-description
      (progn
          (which-key-add-key-based-replacements "SPC f" "Find files")
          (which-key-add-key-based-replacements "C-c f" "Find files")
          (which-key-add-key-based-replacements "SPC b" "Buffer list")
          (which-key-add-key-based-replacements "C-c b" "Buffer list")
      ))
#+END_SRC


** Project scope fuzzy =searching= files and related actions: ~<leader>p f~

#+BEGIN_SRC emacs-lisp
  (dolist (map (list
                evil-motion-state-map
                ))
    (define-key map (kbd "SPC p f") 'project-find-file)
    (define-key map (kbd "C-c p f") 'project-find-file)

    (define-key map (kbd "SPC p d") 'project-dired)
    (define-key map (kbd "C-c p d") 'project-dired)

    (define-key map (kbd "SPC p s") 'project-switch-project)
    (define-key map (kbd "C-c p s") 'project-switch-project)

    (define-key map (kbd "SPC p b") 'project-switch-to-buffer)
    (define-key map (kbd "C-c p b") 'project-switch-to-buffer)

    (define-key map (kbd "SPC p c") 'project-async-shell-command)
    (define-key map (kbd "C-c p c") 'project-async-shell-command)
  )

  (if my-enable-which-key-customized-description
      (progn
          (which-key-add-key-based-replacements "SPC p" "Projects")
          (which-key-add-key-based-replacements "SPC p f" "Fuzzy searching in project")
          (which-key-add-key-based-replacements "SPC p d" "Open dired in project")
          (which-key-add-key-based-replacements "SPC p b" "Switch buffer in project")
          (which-key-add-key-based-replacements "SPC p s" "Switch to another project")
          (which-key-add-key-based-replacements "SPC p c" "Run async shell command")
      ))
#+END_SRC


** Switch between last buffers: ~<leader><leader>~

#+BEGIN_SRC emacs-lisp
  (dolist (map (list
                evil-motion-state-map
                ))
    (define-key map (kbd "SPC SPC") 'switch-to-last-buffer)
  )

  (if my-enable-which-key-customized-description
      (progn
          (which-key-add-key-based-replacements "SPC SPC" "Last Buffer")
      ))
#+END_SRC


** Toggle focus mode(fullscreen) : ~<leader>Enter~

#+BEGIN_SRC emacs-lisp
  (dolist (map (list
                evil-motion-state-map
                ))
    (define-key map (kbd "SPC RET") 'olivetti-mode)
  )

  (if my-enable-which-key-customized-description
      (progn
          (which-key-add-key-based-replacements "SPC RET" "Toggle Focus mode")
      ))
#+END_SRC


** Search and change current word: ~C-s~ 

#+BEGIN_SRC emacs-lisp
  ;;
  ;; Unbind the default <C-s> for 'isearch-forward'
  ;;
  (define-key global-map (kbd "C-s") nil)
  
  ;;
  ;; Replace current word or selection using vim style for evil mode
  ;;
  (defun evil-replace-word-selection()
    (interactive)
    (if (use-region-p)
        (let ((selection (buffer-substring-no-properties (region-beginning) (region-end))))
            (if (= (length selection) 0)
                (message "empty string")
                (evil-ex (concat "'<,'>s/" selection "/"))
            )
        )
        (evil-ex (concat "%s/" (thing-at-point 'word) "/"))))

  ;;
  ;; Rebind <C-s>
  ;;
  (define-key evil-motion-state-map (kbd "C-s") 'evil-replace-word-selection)
#+END_SRC


** Search word from all files: ~<leader>r~

#+BEGIN_SRC emacs-lisp
  (dolist (map (list
                evil-motion-state-map
                ))
    (define-key map (kbd "SPC r") 'consult-ripgrep)
    (define-key map (kbd "C-c r") 'consult-ripgrep)
  )

  (if my-enable-which-key-customized-description
      (progn
          (which-key-add-key-based-replacements "SPC r" "Rg search")
          (which-key-add-key-based-replacements "C-c r" "Rg search")
      ))
#+END_SRC


** ~i menu~ (list all functions name at the file): ~<leader>im~

#+BEGIN_SRC emacs-lisp
  (dolist (map (list
                evil-motion-state-map
                ))
    (define-key map (kbd "SPC i m") 'consult-imenu)
    (define-key map (kbd "C-c i m") 'consult-imenu)
  )

  (if my-enable-which-key-customized-description
      (progn
          (which-key-add-key-based-replacements "SPC i" "iMenu/Insert")
          (which-key-add-key-based-replacements "C-c i" "iMenu/Insert")
      ))
#+END_SRC


** split Window: ~<leader>vs~

#+BEGIN_SRC emacs-lisp
  (dolist (map (list
                evil-motion-state-map
                ))
    (define-key map (kbd "SPC v s") 'evil-window-vsplit)
    (define-key map (kbd "C-c v s") 'evil-window-vsplit)
  )

  (if my-enable-which-key-customized-description
      (progn
          (which-key-add-key-based-replacements "SPC v" "Vertical split")
          (which-key-add-key-based-replacements "C-c v" "Vertical split")
          (which-key-add-key-based-replacements "SPC v s" "Vertical split")
          (which-key-add-key-based-replacements "C-c v s" "Vertical split")
      ))
#+END_SRC


** Window jumping movement by ~C-h, C-l~

For jumping between up and down windows, I prefer to use ~C-w j~ and ~C-w k~.

#+BEGIN_SRC emacs-lisp
  (dolist (map (list
                evil-motion-state-map
                ))
    (define-key map (kbd "C-l") 'evil-window-right)
    (define-key map (kbd "C-h") 'evil-window-left)
   ;; (define-key map (kbd "C-j") 'evil-window-down)
   ;; (define-key map (kbd "C-k") 'evil-window-up)
    ;;(message "State: %s" state);
  )
#+END_SRC


** Change window size: ~-/+/=~

#+BEGIN_SRC emacs-lisp
  (defun my-increase-window-width ()
    (interactive)
    (evil-window-increase-width 5)
  )

  (defun my-decrease-window-width ()
    (interactive)
    (evil-window-increase-width -5)
  )

  (defun my-increase-window-height ()
    (interactive)
    (evil-window-increase-height 5)
  )

  (defun my-decrease-window-height ()
    (interactive)
    (evil-window-increase-height -5)
  )

  (dolist (map (list
                evil-motion-state-map
                evil-normal-state-map
                ))
    (define-key map (kbd "|") 'balance-windows)
    (define-key map (kbd "=") 'my-increase-window-width)
    (define-key map (kbd "-") 'my-decrease-window-width)
    (define-key map (kbd "+") 'my-increase-window-height)
    (define-key map (kbd "_") 'my-decrease-window-height)
  )

  ;;
  ;; Bind to the local buffer keymap against the following delay modes
  ;;
  (defun my-bind-window-resize-local()
    (define-key evil-normal-state-local-map (kbd "|") 'balance-windows)
    (define-key evil-normal-state-local-map (kbd "=") 'my-increase-window-width)
    (define-key evil-normal-state-local-map (kbd "-") 'my-decrease-window-width)
    (define-key evil-normal-state-local-map (kbd "+") 'my-increase-window-height)
    (define-key evil-normal-state-local-map (kbd "_") 'my-decrease-window-height)
  )

  (dolist (hook '(
                 dired-mode-hook
                 ))
    (add-hook hook #'my-bind-window-resize-local)
  )
#+END_SRC


** Open =emacs config=: ~<leader>oc~

#+BEGIN_SRC emacs-lisp
(defun my-open-emacs-configuration-file()
    (interactive)
    (find-file "~/.config/emacs/configuration.org")
)

;; Unbind this!!!
(define-key global-map (kbd "C-c o") nil)

(dolist (map (list
            evil-motion-state-map
            evil-normal-state-map
            ))
(define-key map (kbd "SPC o c") 'my-open-emacs-configuration-file)
(define-key map (kbd "C-c o c") 'my-open-emacs-configuration-file)
)

(if my-enable-which-key-customized-description
    (progn
        (which-key-add-key-based-replacements "SPC o" "Open ....")
        (which-key-add-key-based-replacements "C-c o" "Open ....")
        (which-key-add-key-based-replacements "SPC o c" "Config file")
        (which-key-add-key-based-replacements "C-c o c" "Config file")
    ))
#+END_SRC


** Open =snippet= folder: ~<leader>os~

#+BEGIN_SRC emacs-lisp
(defun my-open-yasnippet-folder()
    (interactive)
    (find-file-other-window "~/.config/emacs/snippets")
)

;; Unbind this!!!
(define-key global-map (kbd "C-c o") nil)

(dolist (map (list
            evil-motion-state-map
            evil-normal-state-map
            ))
(define-key map (kbd "SPC o s") 'my-open-yasnippet-folder)
(define-key map (kbd "C-c o s") 'my-open-yasnippet-folder)
)

(if my-enable-which-key-customized-description
    (progn
        (which-key-add-key-based-replacements "SPC o s" "Snippet folder")
        (which-key-add-key-based-replacements "C-c o s" "Snippet folder")
    ))
#+END_SRC



** Open EShell: ~<leader>s~

#+BEGIN_SRC emacs-lisp
  (dolist (map (list
                evil-motion-state-map
                evil-normal-state-map
                ))
      (define-key map (kbd "SPC s s") 'nil)
      (define-key map (kbd "C-c s s") 'nil)
  )

  (defun my-open-eshell()
     (interactive)
     (split-window-below)
     (windmove-down)
     (eshell)
  )

  (dolist (map (list
                evil-motion-state-map
                ))
      (define-key map (kbd "SPC s s") 'my-open-eshell)
      (define-key map (kbd "C-c s s") 'my-open-eshell)

      (if my-enable-which-key-customized-description
          (progn
              (which-key-add-key-based-replacements "SPC s s" "Shell")
              (which-key-add-key-based-replacements "C-c s s" "Shell")
          ))
  )
#+END_SRC


** Open =sbzi= dired: ~<leader>od~

#+BEGIN_SRC emacs-lisp
  (defun my-open-sbzi-folder()
    (interactive)
    (dired "~/sbzi")
  )
  (defun my-open-notes-folder()
    (interactive)
    (dired "~/sbzi/personal/denote")
  )

  ;;
  ;; Bind
  ;;
  (dolist (map (list
                evil-motion-state-map
                evil-normal-state-map
                ))
      (define-key map (kbd "SPC o d") 'my-open-sbzi-folder)
      (define-key map (kbd "C-c o d") 'my-open-sbzi-folder)

      (define-key map (kbd "SPC o n") 'my-open-notes-folder)
      (define-key map (kbd "C-c o n") 'my-open-notes-folder)
  )

  (if my-enable-which-key-customized-description
      (progn
          (which-key-add-key-based-replacements "SPC o d" "directory")
          (which-key-add-key-based-replacements "C-C o d" "directory")

          (which-key-add-key-based-replacements "SPC o n" "directory")
          (which-key-add-key-based-replacements "C-C o n" "directory")
      ))
#+END_SRC

** Emoji

*** Emoji insert: ~<leader>ei~ and exit: ~C-g~
 #+BEGIN_SRC emacs-lisp
   (dolist (map (list
                 evil-motion-state-map
                 evil-normal-state-map
                 ))
     (define-key map (kbd "SPC e i") 'emoji-insert)
     (define-key map (kbd "C-c e i") 'emoji-insert)
   )

  (if my-enable-which-key-customized-description
      (progn
          (which-key-add-key-based-replacements "SPC e i" "Insert emoji")
          (which-key-add-key-based-replacements "C-c e i" "Insert emoji")
      ))
 #+END_SRC


*** Emoji recent by ~<leader>er~

 #+BEGIN_SRC emacs-lisp
    (dolist (map (list
                  evil-motion-state-map
                  evil-normal-state-map
                  ))
      (define-key map (kbd "SPC e r") 'emoji-recent)
      (define-key map (kbd "C-c e r") 'emoji-recent)
    )

   (if my-enable-which-key-customized-description
       (progn
           (which-key-add-key-based-replacements "SPC e r" "Recent emoji")
           (which-key-add-key-based-replacements "C-c e r" "Recent emoji")
       ))
 #+END_SRC


** Next search: ~n~ and Prev search: ~N~ 

#+begin_src emacs-lisp
  ;;
  ;; Unbind 'n' and 'N'
  ;;
  (define-key evil-motion-state-map (kbd "n") nil)
  (define-key evil-motion-state-map (kbd "N") nil)

  (defun my-search-next()
    (interactive)
    (evil-search-next)
    (evil-scroll-line-to-center nil)
  )

  (defun my-search-previous()
    (interactive)
    (evil-search-previous)
    (evil-scroll-line-to-center nil)
  )

  (define-key evil-motion-state-map (kbd "n") 'my-search-next)
  (define-key evil-motion-state-map (kbd "N") 'my-search-previous)
#+end_src


** Org mode

*** ~org-mode~ fold or unfold when cursor is on heading by ~<RET>~

#+begin_src emacs-lisp 
  (defun my-org-mode-return-cycle-local()
    (define-key evil-normal-state-local-map (kbd "RET") 'org-cycle)
  )
#+end_src


*** ~org-mode~ insert/edit a link by ~<leader>il~ and open a link by ~<leader>ol~ 

#+begin_src emacs-lisp 
  (defun my-org-mode-insert-and-open-link-local()
    (define-key evil-normal-state-local-map (kbd "SPC i l") 'org-insert-link)
    (define-key evil-normal-state-local-map (kbd "C-c i l") 'org-insert-link)
    (define-key evil-normal-state-local-map (kbd "SPC o l") 'org-open-at-point)
    (define-key evil-normal-state-local-map (kbd "C-c o l") 'org-open-at-point)

    (if my-enable-which-key-customized-description
        (progn
            (which-key-add-key-based-replacements "SPC o l" "Open at point")
            (which-key-add-key-based-replacements "C-c o l" "Open at point")
            (which-key-add-key-based-replacements "SPC i l" "Insert link")
            (which-key-add-key-based-replacements "C-c i l" "Insert link")
        ))
  )
#+end_src


*** Bind all bindings above in the 'org-mode-hook' once

#+BEGIN_SRC emacs-lisp
  (defun my-org-mode-local-bindings()
     ;; (my-org-mode-create-elisp-code-block-local)
     (my-org-mode-return-cycle-local)
     (my-org-mode-insert-and-open-link-local)
  )

  (add-hook 'org-mode-hook #'my-org-mode-local-bindings)
#+END_SRC


** Markdown

*** ~markdown-mode~ fold or unfold when cursor is on heading by ~<RET>~

#+begin_src emacs-lisp 
  (evil-define-key 'normal markdown-mode-map (kbd "RET") 'markdown-cycle)
  (evil-define-key 'normal markdown-view-mode-map (kbd "RET") 'markdown-cycle)
#+end_src


** Fast kill buffers and windows

*** Kill all helpful buffers and opend window by ~<leader>kh~

#+BEGIN_SRC emacs-lisp
  ;;
  ;; Close the 'helful' window and kill its buffer
  ;;
  (defun kill-helpful-window-and-buffers ()
      (interactive)
      (message ">>> [ kill-helpful-window-and-buffers ] - ....... ")

      (cl-loop for buf in (buffer-list)
              do (if (string-match-p "^*helpful" (buffer-name buf))
                 (progn
                     ;;
                     ;; Try to close its window first if exists.
                     ;;
                     (setq window-to-be-killed (get-buffer-window (buffer-name buf) nil))
                     (if window-to-be-killed
                        (progn
                            (delete-window window-to-be-killed)
                            (message ">>> [ kill-helpful-window-and-buffers] - Closed window associated with buffer: %s" (buffer-name buf))
                        )
                     )

                     ;;
                     ;; Kill buffer.
                     ;;
                     (message ">>> [ kill-helpful-window-and-buffers] - Killed buffer: %s" (buffer-name buf))
                     (kill-buffer buf)
                 )
              )
      )

      (message ">>> [ kill-helpful-window-and-buffers ] - [done] ")
  )

  (define-key evil-motion-state-map (kbd "SPC k h") 'kill-helpful-window-and-buffers)
  (define-key evil-normal-state-map (kbd "C-c k h") 'kill-helpful-window-and-buffers)

  (if my-enable-which-key-customized-description
      (progn
          (which-key-add-key-based-replacements "SPC k" "Kill")
          (which-key-add-key-based-replacements "C-c k" "Kill")
          (which-key-add-key-based-replacements "SPC k h" "Help window and buffer")
          (which-key-add-key-based-replacements "C-c k h" "Help window and buffer")
      ))
#+END_SRC


*** Kill all eldoc buffers and opend window by ~<leader>kd~

#+BEGIN_SRC emacs-lisp
  ;;
  ;; Close the 'eldoc' window and kill its buffer
  ;;
  (defun kill-eldoc-window-and-buffers ()
      (interactive)
      (message ">>> [ kill-eldoc-window-and-buffers ] - ....... ")

      (cl-loop for buf in (buffer-list)
         do (if (string-match-p "^*eldoc" (buffer-name buf))
             (progn
                ;;
                ;; Try to close its window first if exists.
                ;;
                (setq window-to-be-killed (get-buffer-window (buffer-name buf) nil))
                (if window-to-be-killed
                    (progn
                        (delete-window window-to-be-killed)
                        (message ">>> [ kill-eldoc-window-and-buffers] - Closed window associated with buffer: %s" (buffer-name buf))
                    )
                )

                ;;
                ;; Kill buffer.
                ;;
                (message ">>> [ kill-eldoc-window-and-buffers] - Killed buffer: %s" (buffer-name buf))
                (kill-buffer buf)
             )
         )
      )

      (message ">>> [ kill-eldoc-window-and-buffers ] - [done] ")
  )

  (define-key evil-motion-state-map (kbd "SPC k d") 'kill-eldoc-window-and-buffers)
  (define-key evil-normal-state-map (kbd "C-c k d") 'kill-eldoc-window-and-buffers)

  (if my-enable-which-key-customized-description
      (progn
          (which-key-add-key-based-replacements "SPC k d" "Doc window and buffer")
          (which-key-add-key-based-replacements "C-c k d" "Doc window and buffer")
      ))
#+END_SRC


*** Kill all embark buffers and opend window by ~<leader>ke~

#+BEGIN_SRC emacs-lisp
  ;;
  ;; Close the 'embark' window and kill its buffer
  ;;
  (defun kill-embark-window-and-buffers ()
     (interactive)
     (message ">>> [ kill-embark-window-and-buffers ] - ....... ")

     (cl-loop for buf in (buffer-list)
        do (if (string-match-p "^*Embark" (buffer-name buf))
           (progn
               ;;
               ;; Try to close its window first if exists.
               ;;
               (setq window-to-be-killed (get-buffer-window (buffer-name buf) nil))
               (if window-to-be-killed
                   (progn
                       (delete-window window-to-be-killed)
                       (message ">>> [ kill-embark-window-and-buffers] - Closed window associated with buffer: %s" (buffer-name buf))
                   )
               )

               ;;
               ;; Kill buffer.
               ;;
               (message ">>> [ kill-embark-window-and-buffers] - Killed buffer: %s" (buffer-name buf))
               (kill-buffer buf)
           )
        )
     )

     (message ">>> [ kill-embark-window-and-buffers ] - [done] ")
  )

  (define-key evil-motion-state-map (kbd "SPC k e") 'kill-embark-window-and-buffers)
  (define-key evil-normal-state-map (kbd "C-c k e") 'kill-embark-window-and-buffers)

  (if my-enable-which-key-customized-description
      (progn
          (which-key-add-key-based-replacements "SPC k e" "Embark window and buffer")
          (which-key-add-key-based-replacements "C-c k e" "Embark window and buffer")
      ))
#+END_SRC


** Rebind general ~<leader>X~ bindings to local buffer scope by calling this function

All the ~<leader>X~ bindings above are targeted to =evil-motion-state-map= (which covers =Normal/Motion/Visual= evil states), it should work for most situtations.

But for some particular modes, you still should rebind all of them ~<leader>X~ bindings to the given modes' local buffer scope to make sure to override the packages' level bindings IF you want your ~<leader>X~ bindings work on that mode!!!

So, the following function is designed for that purpose: Call one function in ~xxxx-mode-hook~ to rebind all ~<leader>X~ bindings to the given modes' local buffer scope!!!

#+BEGIN_SRC emacs-lisp
  (defun rebind-general-leader-x-bindings-to-local-buffer-scope()
    ;;
    ;; Quick
    ;;
    (define-key evil-normal-state-local-map (kbd "SPC q") 'save-buffers-kill-terminal)

    ;;
    ;; Describe related
    ;;
    (define-key evil-normal-state-local-map (kbd "SPC d f") 'helpful-callable)
    (define-key evil-normal-state-local-map (kbd "SPC d v") 'helpful-variable)
    (define-key evil-normal-state-local-map (kbd "SPC d k") 'describe-key)
    (define-key evil-normal-state-local-map (kbd "SPC d b") 'describe-bindings)
    (define-key evil-normal-state-local-map (kbd "SPC d m") 'describe-mode)

    ;;
    ;; Command log
    ;;
    (define-key evil-normal-state-local-map (kbd "SPC l") 'clm/toggle-command-log-buffer)

    ;;
    ;; Evalate
    ;;
    (define-key evil-normal-state-local-map (kbd "SPC e e") 'eval-last-sexp)

    ;;
    ;; Find and switch related
    ;;
    (define-key evil-normal-state-local-map (kbd "SPC f") 'find-file)
    (define-key evil-normal-state-local-map (kbd "SPC r") 'consult-ripgrep)
    (define-key evil-normal-state-local-map (kbd "SPC b") 'consult-buffer)
    (define-key evil-normal-state-local-map (kbd "SPC SPC") 'switch-to-last-buffer)

    ;;
    ;; Project scope related
    ;;
    (define-key evil-normal-state-local-map (kbd "SPC p f") 'project-find-file)
    (define-key evil-normal-state-local-map (kbd "SPC p d") 'project-dired)
    (define-key evil-normal-state-local-map (kbd "SPC p s") 'project-switch-project)
    (define-key evil-normal-state-local-map (kbd "SPC p b") 'project-switch-to-buffer)
    (define-key evil-normal-state-local-map (kbd "SPC p c") 'project-async-shell-command)

    ;;
    ;; Focus mode
    ;;
    (define-key evil-normal-state-local-map (kbd "SPC RET") 'olivetti-mode)

    ;;
    ;; iMenu
    ;;
    (define-key evil-normal-state-local-map (kbd "SPC i m") 'consult-imenu)



    ;;
    ;; Window split and movement
    ;;
    (define-key evil-normal-state-local-map (kbd "SPC v s") 'evil-window-vsplit)

    ;;
    ;; Quick open related
    ;;
    (define-key evil-normal-state-local-map (kbd "SPC o c") 'my-open-emacs-configuration-file)
    (define-key evil-normal-state-local-map (kbd "SPC o s") 'my-open-yasnippet-folder)

    ;;
    ;; Emoji related
    ;;
    (define-key evil-normal-state-local-map (kbd "SPC e i") 'emoji-insert)
    (define-key evil-normal-state-local-map (kbd "SPC e r") 'emoji-recent)

    ;;
    ;; Kill specific buffer and opened windows
    ;;
    (define-key evil-normal-state-local-map (kbd "SPC k h") 'kill-helpful-window-and-buffers)
    (define-key evil-normal-state-local-map (kbd "SPC k d") 'kill-eldoc-window-and-buffers)
    (define-key evil-normal-state-local-map (kbd "SPC k e") 'kill-embark-window-and-buffers)

    (message "[ rebind-general-leader-x-bindings-to-local-buffer-scope ] - Done.")
  )
#+END_SRC


** Diredory

*** Go up dir by ~h~ and into dir or open file by ~l~

#+BEGIN_SRC emacs-lisp
  (defun my-dired-h-l-to-directory-navigating-local()
    (define-key evil-normal-state-local-map (kbd "h") 'dired-up-directory)
    (define-key evil-normal-state-local-map (kbd "l") 'dired-find-file)
  )
#+END_SRC


*** Open file to other window by ~o~

#+BEGIN_SRC emacs-lisp
  (defun my-dired-o-to-open-file-local()
    (define-key evil-normal-state-local-map (kbd "o") 'dired-find-file-other-window)
  )
#+END_SRC


*** Jump back to ~dired buffer~ corresponding to current buffer by ~C-c j~

#+BEGIN_SRC emacs-lisp
  (dolist (map (list
                evil-motion-state-map
                ))
      (define-key map (kbd "C-c j") 'dired-jump)
  )
#+END_SRC


*** Quickly go to particular directories by ~gX~

- ~gh~: Go home       =~/=
- ~gb~: Go backup     =~/sbzi/dot-config=
- ~gc~: Go c          =~/sbzi/c=
- ~gs~: Go sbzi       =~/sbzi=
- ~gd~: Go downloads  =~/Downloads=
- ~ge~: Go Emacs      =~/.config/emacs=
- ~gp~: Go Photos     =~/Photos=
- ~gt~: Go temp       =~/temp=

#+BEGIN_SRC emacs-lisp
  (defun my-goto-home-directory()
     (interactive)
     (dired "~/")
  )
  (defun my-goto-shell-backup-directory()
     (interactive)
     (dired "~/sbzi/dot-config")
  )
  (defun my-goto-c-directory()
     (interactive)
     (dired "~/sbzi/c")
  )
  (defun my-goto-emacs-directory()
     (interactive)
     (dired "~/.config/emacs")
  )
  (defun my-goto-downloads-directory()
     (interactive)
     (dired "~/Downloads")
  )
  (defun my-goto-sbzi-directory()
     (interactive)
     (dired "~/sbzi")
  )
  (defun my-goto-temp-directory()
     (interactive)
     (dired "~/temp")
  )
  (defun my-goto-photo-directory()
     (interactive)
     (dired "~/Photos")
  )

  (defun my-dired-custom-go-to-local()
    (define-key evil-normal-state-local-map (kbd "gh") 'my-goto-home-directory)
    (define-key evil-normal-state-local-map (kbd "gb") 'my-goto-shell-backup-directory)
    (define-key evil-normal-state-local-map (kbd "gd") 'my-goto-downloads-directory)
    (define-key evil-normal-state-local-map (kbd "gc") 'my-goto-c-directory)
    (define-key evil-normal-state-local-map (kbd "ge") 'my-goto-emacs-directory)
    (define-key evil-normal-state-local-map (kbd "gp") 'my-goto-photo-directory)
    (define-key evil-normal-state-local-map (kbd "gs") 'my-goto-sbzi-directory)
    (define-key evil-normal-state-local-map (kbd "gt") 'my-goto-temp-directory)
  )
#+END_SRC


*** Toggle hidden files by ~<leader>h~

Before this can work, you have to make sure that you have the following settings to show hidden files by default:

~(setq dired-listing-switches "-lhta")~

#+BEGIN_SRC emacs-lisp
  (setq dired-omit-files "^\\...+$")

  (defun my-dired-toggle-hidden-files-local()
    (define-key evil-normal-state-local-map (kbd "SPC h") 'dired-omit-mode)
    (define-key evil-normal-state-local-map (kbd "C-c h") 'dired-omit-mode)

    (if my-enable-which-key-customized-description
        (progn
            (which-key-add-key-based-replacements "SPC h" "Hidden mode")
            (which-key-add-key-based-replacements "C-c h" "Hidden mode")
        ))
  )
#+END_SRC


*** Modify the READ-ONLY buffer by ~<leader>m~

#+BEGIN_SRC emacs-lisp
  (defun my-dired-toggle-read-only-local()
    (define-key evil-normal-state-local-map (kbd "SPC m") 'dired-toggle-read-only)
    (define-key evil-normal-state-local-map (kbd "C-c m") 'dired-toggle-read-only)

    (if my-enable-which-key-customized-description
        (progn
            (which-key-add-key-based-replacements "SPC m" "Modify mode")
            (which-key-add-key-based-replacements "C-c m" "Modify mode")
        ))
  )
#+END_SRC

After going into the =wdired-change-to-wdired-mode=, here are the default keybindgins to accept or discard changes:

+ ~C-c C-c:~ Accept changes
+ ~C-c C-k:~ Discard changes


*** Yank ful path by ~<leader>yp~

#+BEGIN_SRC emacs-lisp
  (defun my-dired-yank-full-path ()
     (interactive)
     (dired-copy-filename-as-kill 0)
  )

  (defun my-dired-yank-full-path-local()
    (define-key evil-normal-state-local-map (kbd "SPC y p") 'my-dired-yank-full-path)
    (define-key evil-normal-state-local-map (kbd "C-c y p") 'my-dired-yank-full-path)

    (if my-enable-which-key-customized-description
        (progn
            (which-key-add-key-based-replacements "SPC y" "Yank")
            (which-key-add-key-based-replacements "C-c y" "Yank")
            (which-key-add-key-based-replacements "SPC y p" "Yank full path")
            (which-key-add-key-based-replacements "C-c y p" "Yank full path")
        ))
  )
#+END_SRC


*** Bind all bindings above in the 'dired-mode-hook' once

#+BEGIN_SRC emacs-lisp
  (defun my-dired-customized-bindings()
     (my-dired-h-l-to-directory-navigating-local)
     (my-dired-o-to-open-file-local)
     (my-dired-custom-go-to-local)
     (my-dired-toggle-hidden-files-local)
     (my-dired-toggle-read-only-local)
     (my-dired-yank-full-path-local)

     ;;
     ;; Rebind all SPC related bindings to local buffer scope
     ;;
     (rebind-general-leader-x-bindings-to-local-buffer-scope)
  )

  (add-hook 'dired-mode-hook #'my-dired-customized-bindings)
#+END_SRC



** Image Diredory

*** Fit the rendered image to window by ~=~

#+BEGIN_SRC emacs-lisp
  (evil-define-key '(normal) image-mode-map (kbd "=") 'image-transform-fit-to-window)
#+END_SRC


** LSP

*** Go to next or previous error by ~C-n~ or ~C-p~

#+BEGIN_SRC emacs-lisp
  (defun my-lsp-error-jumping-in-local-buffer()
    (define-key evil-normal-state-local-map (kbd "C-n") 'flymake-goto-next-error)
    (define-key evil-normal-state-local-map (kbd "C-p") 'flymake-goto-prev-error)

    (message ">>> [ my-lsp-error-jumping-in-local-buffer ] Set 'C-n' and 'C-p' to local buffer")
  )
#+END_SRC


*** Format buffer by ~<leader>ff~

#+BEGIN_SRC emacs-lisp
  (defun my-lsp-format-buffer()
    ;;(define-key evil-normal-state-local-map (kbd "<leader>ff") 'lsp-format-buffer)

    (define-key evil-normal-state-local-map (kbd "SPC f f") 'eglot-format-buffer)

    (message ">>> [ my-lsp-format-buffer ] Set '<leader>ff' to local buffer")
  )
#+END_SRC


*** Rename by ~<leader>rn~

#+BEGIN_SRC emacs-lisp
  (defun my-lsp-rename-buffer()
    ;; (define-key evil-normal-state-local-map (kbd "<leader>rn") 'lsp-rename)

    (define-key evil-normal-state-local-map (kbd "SPC r n") 'eglot-rename)

    (message ">>> [ my-lsp-rename-buffer ] Set '<leader>rn' to local buffer")
  )
#+END_SRC


*** Show error (diagnostics buffer) ~<leader>se~

#+BEGIN_SRC emacs-lisp
  (defun my-lsp-show-error()
    (define-key evil-normal-state-local-map (kbd "SPC s e") 'flymake-show-buffer-diagnostics)

    (message ">>> [ my-lsp-show-error ] Set '<leader>se' to local buffer")
  )
#+END_SRC


*** Run code action ~<leader>ca~

#+BEGIN_SRC emacs-lisp
  (defun my-lsp-code-action()
    ;; (define-key evil-normal-state-local-map (kbd "<leader>ca") 'lsp-execute-code-action)
    ;; (define-key evil-normal-state-local-map (kbd "C-c c a") 'lsp-execute-code-action)

    (define-key evil-normal-state-local-map (kbd "SPC c a") 'eglot-code-action-quickfix)

    (message ">>> [ my-lsp-code-action ] Set '<leader>ca' to local buffer")
  )
#+END_SRC


*** Toggle comment by ~<leader>/~

#+BEGIN_SRC emacs-lisp
  (defun my-lsp-toggle-comment()
    (define-key evil-visual-state-local-map (kbd "SPC /") 'evilnc-comment-or-uncomment-lines)

    (message ">>> [ my-lsp-toggle-comment ] Set '<leader>/' to local buffer")
  )
#+END_SRC


*** Toggle inlay hints by ~<leader>th~

#+BEGIN_SRC emacs-lisp
  (defun my-lsp-toggle-inlay-hint()
    (interactive)
    (message ">>>>> called.")
    (if eglot-inlay-hints-mode
        (progn
            (message ">>> [ my-lsp-toggle-inlay-hint ] Inlay hint is 'on', turn it 'off' now.")
            (eglot-inlay-hints-mode -1)
        )
        (progn
            (message ">>> [ my-lsp-toggle-inlay-hint ] Inlay hint is 'off', turn it 'on' now.")
            (eglot-inlay-hints-mode 1)
        )
    )
  )

  (defun my-setup-toggle-inlay-hint()
      (define-key evil-normal-state-local-map (kbd "SPC t h") 'my-lsp-toggle-inlay-hint)
      (message ">>> [ my-setup-toggle-inlay-hint ] Set '<leader>th' to local buffer")
  )
#+END_SRC


*** Bind all bindings above in one shot

#+BEGIN_SRC emacs-lisp
  (defun my-lsp-bindings()
     (my-lsp-error-jumping-in-local-buffer)
     (my-lsp-format-buffer)
     (my-lsp-rename-buffer)
     (my-lsp-show-error)
     (my-lsp-code-action)
     (my-lsp-toggle-comment)
     (my-setup-toggle-inlay-hint)

     (if my-enable-which-key-customized-description
         (progn
             (which-key-add-major-mode-key-based-replacements major-mode "SPC f" "Format")
             (which-key-add-major-mode-key-based-replacements major-mode "SPC f f" "Format")
             (which-key-add-major-mode-key-based-replacements major-mode "SPC r" "Rename")
             (which-key-add-major-mode-key-based-replacements major-mode "SPC r n" "Rename")
             (which-key-add-major-mode-key-based-replacements major-mode "SPC s" "Show errors")
             (which-key-add-major-mode-key-based-replacements major-mode "SPC s e" "Show errors")
             (which-key-add-major-mode-key-based-replacements major-mode "SPC c" "Code actions")
             (which-key-add-major-mode-key-based-replacements major-mode "SPC c a" "Code actions")
             (which-key-add-major-mode-key-based-replacements major-mode "SPC /" "Comment")
             (which-key-add-major-mode-key-based-replacements major-mode "SPC t" "Toggle")
             (which-key-add-major-mode-key-based-replacements major-mode "SPC t h" "Toggle hints")
         ))
  )

  (dolist (hook '(c-mode-hook
                  c-ts-mode-hook
                  c++-mode-hook
                  c++-ts-mode-hook
                  zig-mode-hook
                  zig-ts-mode-hook
                  rust-mode-hook
                  rust-ts-mode-hook
                  typescript-mode-hook
                  python-ts-mode-hook
                  ))
     (add-hook hook #'my-lsp-bindings)
  )
#+END_SRC


** Embark

*** Run ~embark-act~ by ~C-e~

#+BEGIN_SRC emacs-lisp
  ;; (define-key global-map (kbd "C-,") 'embark-act)
  (define-key global-map (kbd "C-e") 'embark-act)
#+END_SRC


For the =GUI= version:

Because of I use =vertico-posframe= in =GUI= mode, but =Embark= doesn't work well with popup. That's why if you press =C-e=, then =Embark menu= shows under the popup which means you can't see part of it. In that situation, you can press =C-h=, then the =Embark help menu= will re-rendered inside the popup!!!


** =org-download= for copy images from anywhere
#+BEGIN_SRC emacs-lisp
  (use-package org-download
      ;; Drag-and-drop to `dired`
      :config
      (add-hook 'dired-mode-hook 'org-download-enable)
  )
#+END_SRC


** pdf
*** pdf-tools
#+BEGIN_SRC emacs-lisp
    (use-package pdf-tools
      :load-path "~/.config/emacs/elpa/pdf-tools-20230611.239"
      :commands pdf-tools-install
      :mode ("\\.[pP][dD][fF]\\'" . pdf-view-mode)
      :magic ("%PDF" . pdf-view-mode)
      :hook (dirvish-setup . pdf-tools-install)
      :config
      (pdf-tools-install t nil t nil))

    (defun my-pdf-scroll-local()
     (message ">>> [ my-pdf-scroll-local ] ")

     ;;
     ;; Rebind
     ;;
     (define-key evil-normal-state-local-map (kbd "k") 'pdf-view-scroll-down-or-previous-page)
     (define-key evil-normal-state-local-map (kbd "j") 'pdf-view-scroll-up-or-next-page)
     (define-key evil-normal-state-local-map (kbd "|") 'pdf-view-fit-page-to-window)
     (define-key evil-normal-state-local-map (kbd "G") 'pdf-view-goto-page)
     (define-key evil-normal-state-local-map (kbd "<") 'pdf-view-first-page)
     (define-key evil-normal-state-local-map (kbd ">") 'pdf-view-last-page)
     (message ">>> [ my-pdf-scroll-local ] rebind pdf navigation works. ")

     ;;
     ;; Rebind all SPC related bindings to local buffer scope
     ;;
     (rebind-general-leader-x-bindings-to-local-buffer-scope)
     (rebind-colemak-leader-x-bindings-to-local-buffer-scope)
     )

  (defun my-pdf-custom-settings()
    (global-display-line-numbers-mode 0)
    ;; (setq display-line-numbers-type 'relative)
    ;; (setq column-number-mode t)
  )

  (dolist (hook '(pdf-view-mode-hook
                  ))
     (add-hook hook #'my-pdf-scroll-local)
     (add-hook hook #'my-pdf-custom-settings)
  )
#+END_SRC
#+BEGIN_SRC emacs-lisp
;;  (use-package pdf-tools
;;  :load-path "~/.config/emacs/elpa/pdf-tools-20230611.239"
;;  :mode ("\\.pdf\\'" . pdf-view-mode) ; pdf 文件默认打开方式
;; :bind
;;  (:map pdf-view-mode-map
;;   ("j" . pdf-view-next-page-command)
;;   ("k" . pdf-view-previous-page-command)
;;   ("l" . pdf-view-scroll-up-or-next-page)
;;   ("h" . pdf-view-scroll-down-or-previous-page)
;;   ("G" . pdf-view-goto-page)
;;   ("|" . pdf-view-fit-page-to-window)
;;   ("<" . pdf-view-first-page)
;;   ("<" . pdf-view-last-page)
;;
;;   :map pdf-history-minor-mode-map
;;   ("B" . pdf-history-backward)
;;   :map pdf-annot-minor-mode-map
;;   ("C-a a" . pdf-annot-add-highlight-markup-annotation)
;;   ("C-a s" . pdf-annot-add-squiggly-markup-annotation)
;;   ("C-a u" . pdf-annot-add-underline-markup-annotation)
;;   ("C-a d" . pdf-annot-delete))
;;  :custom
;;  (pdf-view-midnight-colors '("#000000" . "#9bCD9b")) ; 夜间模式设置绿色底色
;;  :config
;;  (require 'pdf-annot) ; 设置 pdf-annot-mimor-mode-map 必须
;;  (require 'pdf-history) ; 设置 pdf-history-minor-mode-map 必须
;;  (add-hook 'pdf-view-mode-hook 'pdf-view-fit-width-to-window) ; 默认适应页宽
;;  (add-hook 'pdf-view-mode-hook 'pdf-view-midnight-minor-mode) ; 默认夜间模式
;;  (pdf-tools-install))
#+END_SRC
*** org-noter

#+BEGIN_SRC emacs-lisp
(use-package pdf-tools)

(use-package org-noter
  :config
      (setq org-noter-max-short-selected-text-length 700000)
      (setq org-noter-max-short-length 80000)
      (setq org-noter-always-create-frame nil) ;; Prevent use new frame!!!
      (if (> 999 (display-pixel-height)) 
         (setq org-noter-doc-split-fraction '(0.6 . 0.5)))
  :custom
      (org-noter-highlight-selected-text t)
      (org-noter-notes-search-path '("~/sbzi/personal/org-noter/"))
      (org-noter-auto-save-last-location t)
)



(define-key org-noter-doc-mode-map (kbd "M-i") nil)
(define-key pdf-view-mode-map (kbd "C-u") nil)
(define-key org-noter-doc-mode-map (kbd "M-i") #'dm/insert-precise)

(defun dm/insert-precise (&optional optional)
  (interactive "P")
  (org-noter-insert-precise-note 't))

;; (push "~/workspace/org-noter-plus-djvu" load-path)
;; (push "~/workspace/org-noter-plus-djvu/other" load-path)
;; (push "~/workspace/org-noter-plus-djvu/modules" load-path)

;; (require 'org-noter)
;; (require 'org-noter-nov)
;; (require 'org-noter-pdf)


(define-advice org-noter--insert-heading (:after (level title &optional newlines-number location) add-full-body-quote)
  "Advice for org-noter--insert-heading.

When inserting a precise note insert the text of the note in the body as an org mode QUOTE block.

=org-noter-max-short-length= should be set to a large value to short circuit the normal behavior:
=(setq org-noter-max-short-length 80000)="

  ;; this tells us it's a precise note that's being invoked.
  (if (consp location)
      (insert (format "#+BEGIN_QUOTE\n%s\n#+END_QUOTE" title))))

;; ;; (require 'org-noter-nov-overlay)
;; doesn't work. (require 'org-noter-integration)


;;  (use-package pdf-tools-org-noter-helpers
;;   :straight (
;;              :type git :repo "https://github.com/analyticd/pdf-tools-org-noter-helpers")
;;   :config
;; (require 'pdf-tools-org-noter-helpers))

  (defun my-org-noter-local()
      (message ">>> [ my-pdf-org-noter-local ] ")

      ;;
      ;; Rebind
      ;;
      ;;(define-key evil-normal-state-local-map (kbd "C-c n n") 'org-noter)
      (define-key evil-normal-state-local-map (kbd "C-c n n") 'org-noter)
      (define-key evil-normal-state-local-map (kbd "M-a") 'org-noter-insert-note)
      (define-key evil-normal-state-local-map (kbd "M-p") 'org-noter-insert-precise-note)
      (define-key evil-normal-state-local-map (kbd "M-o") 'org-noter-create-skeleton)
      (define-key evil-normal-state-local-map (kbd "M-q") 'org-noter-kill-session)
      ;;(define-key evil-normal-state-local-map (kbd "C-c n h") 'org-noter-set-hide-other)
      (define-key evil-normal-state-local-map (kbd "M-s") 'org-noter-set-auto-save-last-location)
      (define-key evil-normal-state-local-map (kbd "M-.") 'org-noter-sync-next-note)
      (define-key evil-normal-state-local-map (kbd "M-,") 'org-noter-sync-prev-note)
      (define-key evil-normal-state-local-map (kbd "M-/") 'org-noter-sync-current-note)
      ;;(define-key evil-normal-state-local-map (kbd "M-}") 'org-noter-sync-next-page-or-chapter)
      ;;(define-key evil-normal-state-local-map (kbd "M-{") 'org-noter-sync-prev-page-or-chapter)
      (define-key evil-normal-state-local-map (kbd "M-c") 'org-noter-sync-current-page-or-chapter)



    ;; (if my-enable-which-key-customized-description
    ;;      (progn
    ;;          ;;(which-key-add-key-based-replacements "C-c n" "Noter")
    ;;          (which-key-add-key-based-replacements "C-c n n" "Open session")
    ;;          (which-key-add-key-based-replacements "C-c n o" "Outline")
    ;;          (which-key-add-key-based-replacements "C-c n k" "Kill session")
    ;;          (which-key-add-key-based-replacements "C-c n h" "Hide other")
    ;;          (which-key-add-key-based-replacements "C-c n a" "Save last location")
    ;;          (which-key-add-key-based-replacements "C-c n c" "current")
    ;;          (which-key-add-key-based-replacements "C-c n /" "current page")
    ;;          (which-key-add-key-based-replacements "C-c n >" "next note")
    ;;          (which-key-add-key-based-replacements "C-c n <" "prev note")
    ;;          (which-key-add-key-based-replacements "C-c n ]" "next chapter note")
    ;;          (which-key-add-key-based-replacements "C-c n [" "prev chapter note")
    ;;      ))

      (message ">>> [ my-pdf-org-noter-local ] - rebind successfully. ")
  )

  (dolist (hook '(org-mode-hook
                  pdf-view-mode-hook
                  ))
     (add-hook hook #'my-org-noter-local)
  )

  ;(add-hook 'pdf-view-mode-hook #'my-rebind-spc-for-pdf-view-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
;;  (use-package pdf-tools)
;;
;;  (use-package org-noter
;;    :config
;;        (setq org-noter-max-short-selected-text-length 20)
;;        (setq org-noter-max-short-length 80000)
;;        (setq org-noter-always-create-frame nil) ;; Prevent use new frame!!!
;;        (setq org-noter-default-heading-title "Note from $p$ page") ;; Prevent use new frame!!!
;;        (if (> 999 (display-pixel-height)) 
;;           (setq org-noter-doc-split-fraction '(0.6 . 0.5)))
;;    :custom
;;        (org-noter-highlight-selected-text t)
;;        (org-noter-notes-search-path '("~/sbzi/personal/org-noter/"))
;;        (org-noter-auto-save-last-location t)
;;  )
;;  (define-key org-noter-doc-mode-map (kbd "M-i") nil)
;;  (define-key pdf-view-mode-map (kbd "C-u") nil)
;;  (define-key org-noter-doc-mode-map (kbd "M-i") #'dm/insert-precise)
;;
;;  (defun dm/insert-precise (&optional optional)
;;    (interactive "P")
;;    (org-noter-insert-precise-note 't))
;;
;;  ;; (push "~/workspace/org-noter-plus-djvu" load-path)
;;  ;; (push "~/workspace/org-noter-plus-djvu/other" load-path)
;;  ;; (push "~/workspace/org-noter-plus-djvu/modules" load-path)
;;
;;  ;; (require 'org-noter)
;;  ;; (require 'org-noter-nov)
;;  ;; (require 'org-noter-pdf)
;;
;;
;;  (define-advice org-noter--insert-heading (:after (level title &optional newlines-number location) add-full-body-quote)
;;    "Advice for org-noter--insert-heading.
;;
;;  When inserting a precise note insert the text of the note in the body as an org mode QUOTE block.
;;
;;  =org-noter-max-short-length= should be set to a large value to short circuit the normal behavior:
;;  =(setq org-noter-max-short-length 80000)="
;;
;;    ;; this tells us it's a precise note that's being invoked.
;;    (if (consp location)
;;        (insert (format "#+BEGIN_QUOTE\n%s\n#+END_QUOTE" title))))
;;
;;  (defun my-org-noter-local()
;;    (message ">>> [ my-pdf-org-noter-local ] ")
;;    ;;
;;    ;; Rebind
;;    ;;
;;    ;;(define-key evil-normal-state-local-map (kbd "C-c n n") 'org-noter)
;;    (define-key evil-normal-state-local-map (kbd "C-c n n") 'org-noter)
;;    (define-key evil-normal-state-local-map (kbd "M-a") 'org-noter-insert-note)
;;    (define-key evil-normal-state-local-map (kbd "M-p") 'org-noter-insert-precise-note)
;;    (define-key evil-normal-state-local-map (kbd "M-o") 'org-noter-create-skeleton)
;;    (define-key evil-normal-state-local-map (kbd "M-q") 'org-noter-kill-session)
;;    ;;(define-key evil-normal-state-local-map (kbd "C-c n h") 'org-noter-set-hide-other)
;;    (define-key evil-normal-state-local-map (kbd "M-s") 'org-noter-set-auto-save-last-location)
;;    (define-key evil-normal-state-local-map (kbd "M-/") 'org-noter-sync-next-note)
;;    (define-key evil-normal-state-local-map (kbd "M-,") 'org-noter-sync-prev-note)
;;    (define-key evil-normal-state-local-map (kbd "M-.") 'org-noter-sync-current-note)
;;    ;;(define-key evil-normal-state-local-map (kbd "M-}") 'org-noter-sync-next-page-or-chapter)
;;    ;;(define-key evil-normal-state-local-map (kbd "M-{") 'org-noter-sync-prev-page-or-chapter)
;;    (define-key evil-normal-state-local-map (kbd "M-c") 'org-noter-sync-current-page-or-chapter)
;;
;;    (message ">>> [ my-pdf-org-noter-local ] - rebind successfully. ")
;;)
;;
;;(dolist (hook '(org-mode-hook
;;                pdf-view-mode-hook
;;                ))
;;   (add-hook hook #'my-org-noter-local)
;;)

;(add-hook 'pdf-view-mode-hook #'my-rebind-spc-for-pdf-view-mode)
#+END_SRC

** =org-capture=
#+BEGIN_SRC emacs-lisp
  (use-package org-capture
  :ensure nil
  :bind ("C-c ;" . (lambda () (interactive) (org-capture)))
  :hook ((org-capture-mode . (lambda ()
                               (setq-local org-complete-tags-always-offer-all-agenda-tags t)))
         (org-capture-mode . delete-other-windows))
  :custom
  (org-capture-use-agenda-date nil)
  ;; define common template
  (org-capture-templates `(("t" "Tasks" entry (file+headline "~/sbzi/personal/org-capture/tasks.org" "Reminders")
                            "* TODO %i%?"
                            :empty-lines-after 1
                            :prepend t)
                           ("n" "Notes" entry (file+headline "~/sbzi/personal/org-capture/capture.org" "Notes")
                            "* %? %^g\n%i\n"
                            :empty-lines-after 1)
                           ;; For EWW
                           ("b" "Bookmarks" entry (file+headline "~/sbzi/personal/org-capture/capture.org" "Bookmarks")
                            "* %:description\n\n%a%?"
                            :empty-lines 1
                            :immediate-finish t)
                           ("d" "Diary")
                           ("dt" "Today's TODO list" entry (file+olp+datetree "~/sbzi/personal/org-capture/diary.org")
                            "* Today's TODO list [/]\n%T\n\n** TODO %?"
                            :empty-lines 1
                            :jump-to-captured t)
                           ("do" "Other stuff" entry (file+olp+datetree "~/sbzi/personal/org-capture/diary.org")
                            "* %?\n%T\n\n%i"
                            :empty-lines 1
                            :jump-to-captured t)
                           ))
  )
#+END_SRC
 


** =denote= notetaker
 #+BEGIN_SRC emacs-lisp
      (use-package denote
        :commands (denote denote-signature denote-subdirectory denote-rename-file-using-front-matter
                          denote-keywords-prompt
                          denote-rename-file
                          denote-link-or-create)
        :hook (dired-mode . denote-dired-mode-in-directories)
        :config
        (setq denote-directory (expand-file-name "~/denote"))

        (setq denote-directory (expand-file-name "~/sbzi/personal/denote/")
              denote-known-keywords '("dev" "liter" "books" "dailies" "personal")
              denote-infer-keywords t
              denote-sort-keywords t
              denote-allow-multi-word-keywords t
              denote-date-prompt-use-org-read-date t
              denote-link-fontify-backlinks t
              denote-front-matter-date-format 'org-timestamp
              denote-prompts '(title keywords)))
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
  (define-key evil-normal-state-map (kbd "SPC n") nil)
  (dolist (map (list
                evil-motion-state-map
                evil-normal-state-map
                ))
    (define-key map (kbd "SPC n") nil)
    (define-key map (kbd "SPC n l") nil)
  )

  (dolist (map (list
                evil-motion-state-map
                ))
    (define-key map (kbd "SPC i m") 'consult-imenu)
    (define-key map (kbd "C-c i m") 'consult-imenu)

    (define-key map (kbd "SPC n c") 'denote)
    (define-key map (kbd "SPC n o") 'denote-open-or-create)
    (define-key map (kbd "SPC n f") 'denote-type)
    (define-key map (kbd "SPC n t") 'denote-template)
    (define-key map (kbd "SPC n r") 'denote-rename-file)

    (define-key map (kbd "SPC n l a") 'denote-link)
    (define-key map (kbd "SPC n l c") 'denote-link-or-create)
    (define-key map (kbd "SPC n l r") 'denote-add-links)
    (define-key map (kbd "SPC n l f") 'denote-find-link)
    (define-key map (kbd "SPC n l b") 'denote-backlinks)
  )

  ;;
  ;; 'which-key' description
  ;;
  (if my-enable-which-key-customized-description
      (progn
          (which-key-add-key-based-replacements "SPC n" "Denote")
          (which-key-add-key-based-replacements "SPC n c" "Create note")
          (which-key-add-key-based-replacements "SPC n o" "Open (or create) note")
          (which-key-add-key-based-replacements "SPC n f" "Create note by file-type")
          (which-key-add-key-based-replacements "SPC n t" "Create note by template")
          (which-key-add-key-based-replacements "SPC n r" "Rename")
          (which-key-add-key-based-replacements "SPC n l" "Denote Links")
          (which-key-add-key-based-replacements "SPC n l a" "Add link")
          (which-key-add-key-based-replacements "SPC n l c" "Add (or create) link")
          (which-key-add-key-based-replacements "SPC n l r" "Regexp links")
          (which-key-add-key-based-replacements "SPC n l f" "Find links")
          (which-key-add-key-based-replacements "SPC n l b" "Back-links")
      ))
 #+END_SRC


 #+BEGIN_SRC emacs-lisp
   (message ">>>>>>>>>")
 #+END_SRC





