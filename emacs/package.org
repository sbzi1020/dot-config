* Package settings

** Init package and install `use-package`

#+BEGIN_SRC emacs-lisp
  (require 'package)
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
  ;;(add-to-list 'package-archives
  ;;	     '(
  ;;	       ("melpa" . "https://melpa.org/packages/")
  ;;	       ("org" . "https://orgmode.org/elpa/")
  ;;	       ("elpa" . "https://elpa.gun.org/packages/")
  ;;	       ))

  (unless package-archives
          (package-refresh-contents))
  ;;(package-refresh-contents)
  (package-initialize)

  ;;
  ;; (unless condition nil
  ;;         statement-to-execute)
  ;;
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))

  (require 'use-package)

  ;; Auto install all missing packages when using `(use-packge)`
  ;; It's equal to use `:ensure t` in `(use-package)`
  (setq use-package-always-ensure t)
#+END_SRC



** ~(use-package)~ quick manual

Removed the 'emacs-lisp' already, so the following code won't be executed!!!

#+begin_src
  ;;
  ;; Load the package, but only if 'PACKAGE_NAME' is available on your system. If not, a
  ;; warning is logged to the '*Messages*' buffer.
  ;;
  ;;
  (use-package 'PACKAGE_NAME
    ;;
    ;; Install if it doesn't exists, and because of '(setq use-package-always-ensure t)'
    ;; has been set already, that said ':ensure t' will be applied to all '(use-package)',
    ;; that's why you don't need to set ':ensure t' anymore.
    ;;
    :ensure t

    ;; 
    ;; Lazy load this package
    ;; Using 'bind' and 'command' will cause the package to lazy load as well!!!
    ;;
    ;; The keywords ':commands,' et al, provide "triggers" that cause a package to
    ;; be loaded when certain events occur. However, if 'use-package' cannot determine
    ;; that any trigger has been declared, it will load the package immediately (when
    ;; Emacs is starting up) unless :defer t is given. The presence of triggers can be
    ;; overridden using ':demand t' to force immediately loading anyway.
    ;; For example, :hook represents a trigger that fires when the specified hook is run.
    ;; 
    ;; In almost all cases you don't need to manually specify ':defer t', because this is
    ;; implied whenever ':bind' or ':mode' or ':interpreter' are used. Typically, you only
    ;; need to specify ':defer' if you know for a fact that some other package will do
    ;; something to cause your package to load at the appropriate time, and thus you would
    ;;  like to defer loading even though 'use-package' has not created any autoloads for you.
    ;;
    :defer t

    ;; 
    ;; Use the ':init' keyword to execute code before a package is loaded. It accepts one
    ;; or more forms, up to the next keyword:
    ;;
    :init
        ;;
        ;; All settings belong to ':init' part
        ;;
        (setq YOUR_VARS t)

    ;; 
    ;; Use the ':config' keyword to execute code after a package is loaded. In cases where
    ;; loading is done lazily (see more about autoloading below), this execution is deferred
    ;; until after the autoload occurs
    :config
        ;;
        ;; All settings belong to ':config part
        ;;
        (your-mode t)

    ;; 
    ;; Load this package after another package
    ;;
    :after ANOTHER_PACKAGE_NAME

    ;; 
    ;; Run the commands when the package is actually loaded.
    ;; The ':commands' keyword takes either a symbol or a list of symbols.
    ;;
    :commands SINGLE_COMMAND
    :commands (COMMAND_1 COMMAND_2 COMMAND_3 etc)

    ;; 
    ;; Keybindings
    ;;
    :bind (("M-o l" . COMMAND_TO_BIND)
           ("M-o r" . COMMAND_TO_BIND)
           ("M-o w" . COMMAND_TO_BIND)))

    ;; 
    ;; The ':hook' keyword allows adding functions onto package hooks. The same
    ;; effect with using '(add-hook)'. The following ':hook' setting is the same:
    ;;
    ;; :init
    ;; (add-hook 'prog-mode-hook #'company-mode))
    ;;
    :hook (prog-mode . company-mode))

    ;; 
    ;; The ':custom' keyword allows customization of package custom variables.
    ;; Same thing with using '(setq NAME VALUE)' in ':init' but with comments.
    ;; The documentation string is not mandatory.
    ;;
    ;; NOTE: these are only for people who wish to keep customizations with their
    ;;       accompanying use-package declarations. Functionally, the only benefit
    ;;       over using setq in a :config block is that customizations might execute
    ;;       code when values are assigned.
    ;; 
    ;; NOTE: The customized values are not saved in the Emacs custom-file. Thus you
    ;;       should either use the :custom option or you should use M-x customize-option
    ;;       which will save customized values in the Emacs custom-file. Do not use both.
    ;;
    :custom
        (comint-buffer-maximum-size 20000 "Increase comint buffer size.")
        (comint-prompt-read-only t "Make the prompt read only."))
    ;;
    ;; The ':disabled' keyword can turn off a module you're having difficulties with, or
    ;; stop loading something you're not using at the present time:
    ;;
    :disabled

    ;;
    ;; Print out the error if you want
    ;;
    :catch (lambda (keyword err)
            (message ">>> Package load failed with error: %s" (error-message-string err)))

  )
#+end_src
