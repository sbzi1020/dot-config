+title: My Emacs Configuration

#+PROPERTY: header-args:emacs-lisp :tangle ./init.el
#+auto_tangle: t
#+options: toc:2

* README

** Installation

*** 1. MacOS

You should install =Emacs Plus= to support all missing features in =Mac version=!!!

https://github.com/d12frosted/homebrew-emacs-plus

By default (without any addition options) this formula install Cocoa version of Emacs with support of =gnutls=, =imagemagick= (not included by default with =emacs-plus@29= and =emacs-plus@30=), =librsvg=, =libxml2=, dynamic modules and multicolor fonts. Please see the list of available options to disable any bit of default behaviour or add even more stuff.

Any I prefer install with the following options/features:

| Option                    | Description                                                                             |
|---------------------------+-----------------------------------------------------------------------------------------|
| --with-native-comp        | Native compilation, super important for solving the performance issue.                  |
| --with-imagemagick        | build with imagemagick support.                                                         |
| --with-modern-yellow-icon | More icons you can choose form  https://github.com/d12frosted/homebrew-emacs-plus#icons |

#+BEGIN_SRC bash
  brew tap d12frosted/emacs-plus

  brew install emacs-plus \
      --with-native-comp \
      --with-imagemagick \
      --with-modern-yellow-icon
#+END_SRC


Also, you can choose to install different versions:

#+BEGIN_SRC bash
  # brew tap d12frosted/emacs-plus
  # brew install emacs-plus    [options] # install the latest release (Emacs 29)
  # brew install emacs-plus@30 [options] # install Emacs 30 (master)
  # brew install emacs-plus@29 [options] # install Emacs 29
  # brew install emacs-plus@28 [options] # install Emacs 28
  # brew install emacs-plus@27 [options] # install Emacs 27
  # brew install emacs-plus@26 [options] # install Emacs 26
#+END_SRC


After installation, you got 2 ways to confirm that it's the =Native compilation= verison:

A. Open emacs and run the following =LISP= command:

    #+BEGIN_SRC emacs-lisp :tangle no
      (native-comp-available-p)
    #+END_SRC

    If it returns =t=, that mean YES, that's the =Native compilation= version:)


B. Open emacs and run the following =LISP= command:

    #+BEGIN_SRC emacs-lisp :tangle no
      (describe-variable 'system-configuration-features (current-buffer) nil)
    #+END_SRC

    If the output contains =NATIVE_COMP=, that mean YES, that's the =Native compilation= version:)


*** 2. Arch Linux

#+BEGIN_SRC bash
  # doas pacman --refresh --sync emacs

  # You should install the native compilation built-in version!!!
  doas pacman --refresh --sync emacs-nativecomp
#+END_SRC

If you see the following error when you run =emacs=:

#+BEGIN_SRC bash
  /usr/lib/libc.so.6: Version "GBLIC_X.Y.Z" not found
#+END_SRC

then you should re-install (upgrade) =glibc= to the corect version:

#+BEGIN_SRC bash
  doas pacman --refresh --sync glibc
#+END_SRC


Here is how to check the version you installed whether =native compilation= or not:

Open =emacs= and run ~(native-comp-available-p)~, if it returns =t= that means YES, =nil= is not.


** About the default configuration file and its location

1. In =MacOS=, the default configuration file locates in =~/.emacs.d=

   If you want to use =~/.config/emacs= instead of =~/.emacs.d=, then you HAVE TO remove =~/.emacs.d=.
   Otherwise, it won't load the =~/.config/emacs/init.el=!

2. I use =org-auto-tangle= package, so it generates the updated =./init.el= and =./early-init.el= automatically when this file has been saved.

   You can see the following messages print out to =*Messages*= buffer every time when saving this file.

   #+BEGIN_SRC emacs-lisp :tangle no
     ;; Tangling /home/wison/.config/emacs/configuration.org...
     ;; Tangling "/home/wison/.config/emacs/configuration.org" completed after 0.35 seconds
   #+END_SRC


** The Early Init File: =~/.config/emacs/early-init.el=

Most customizations for =Emacs= should be put in the normal =init= file. However, it is sometimes necessary to have customizations take effect during Emacs startup earlier than the normal =init= file is processed.

Such customizations can be put in the early init file, =~/.config/emacs/early-init.el= or =~/.emacs.d/early-init.el=.

This file is loaded before the package system and GUI is initialized, so in it you can customize variables that affect the package initialization process, such as ~package-enable-at-startup~, ~package-load-list~, and ~package-user-dir~. Note that variables like ~package-archives~ which only affect the installation of new packages, and not the process of making already-installed packages available, may be customized in the regular init file. See Package Installation.


** First time to run =Emacs=

You better to run the =Emacs= in daemon mode, as the it takes time to download all packages for the first time.

Actually, you should add the debug flag like this:

#+BEGIN_SRC bash
  emacs --daemon --debug-init
#+END_SRC

Then you can see the detail debug log. Also, sometimes it will fail to connect to =melpa.org/443=, if you
see the following error:

#+BEGIN_SRC bash
  Contacting host: stable.melpa.org:443

  # Ignore output
  ...... 

  # Finally, fail to install some pacakges
  Error (use-package): Failed to install org-bullets: melpa.org/443 Temporary failure in name resolution
#+END_SRC

So, you need to kill the existing =emacs= process and re-run =emacs --daemon --debug-init= command again
until you see it runs successfully like this:

#+BEGIN_SRC bash
  emacs --daemon --debug-init

  # Warning: due to a long standing Gtk+ bug
  # https://gitlab.gnome.org/GNOME/gtk/issues/221
  # Emacs might crash when run in daemon mode and the X11 connection is unexpectedly lost.
  # Using an Emacs configured with --with-x-toolkit=lucid does not have this problem.
  # Loading /home/wison/.config/emacs/settings.el (source)...
  # Loading /home/wison/.config/emacs/settings.el (source)...done
  # Loaded /home/wison/.config/emacs/settings.el
  # Loading /home/wison/.config/emacs/package.el (source)...
  # Loading /home/wison/.config/emacs/package.el (source)...done
  # Loaded /home/wison/.config/emacs/package.el
  # Loading /home/wison/.config/emacs/evil.el (source)...
  # Loading /home/wison/.config/emacs/evil.el (source)...done
  # Loaded /home/wison/.config/emacs/evil.el
  # Starting Emacs daemon.

#+END_SRC


** How to run =Emacs=

You can run emacs in different ways:

**** Run =Eamcs= as a server

For runing as a server:

#+BEGIN_SRC bash
  #
  # Run emacs as a server in background, same with 'emacs --bg-daemon'
  #
  emacs --daemon

  #
  # Run emacs as a server in foreground, good for debugging to see all console output
  #
  emacs --fg-daemon

  #
  # Run emacs as a named server in background, then you can have multiple server instances
  #
  emacs --daemon=XXX
  emacs --daemon=YYY
  emacs --daemon=ZZZ
#+END_SRC

When you run multiple named server instances, you can describe-variable on ~server-socket-dir~ to confirm the server socket folder, that folder contains all named server socket files.


After that, you can use ~emacsclient~ to communicate with the server:

#+BEGIN_SRC bash
  #
  # Open emacs in GUI mode
  #
  # As that's GUI program, you better to run it in background to avoid holding the current console
  #
  # -c, --create-frame: Create a new frame instead of trying to use the current Emacs frame
  # -a: if Emacs server doesn't run yet, then fallback to the given EDITOR)
  #
  emacsclient -c -a "nvim" &

  # Open emacs in terminal mode
  emacsclient -t
#+END_SRC


And you can kill the emacs server like this

#+BEGIN_SRC bash
  emacsclient -e \("kill-emacs"\)

  # If you only want to kill the given server instance
  emacsclient -e \("kill-emacs"\) --socket-name=XXX
#+END_SRC


**** Run =Emacs= as stand-alone instance


#+BEGIN_SRC bash
  # Open emacs in GUI mode
  emacs &

  # Open emacs in terminal mode
  # emacs -nw
  emacs --no-window-system
#+END_SRC



** How to export code block content into a given file (=*.el=)

All configuration contents in this file will be exported to ~init.el~ and ~early-init.el~ by running ~org-babel-tangle~ command, it exports all code blocks to the given file. You have a few ways to control how to export:

*** Specific each code block to export to the given file

~#+begin_src emacs-lisp :tangle ./A.el~
~#+end_src~

~#+begin_src emacs-lisp :tangle ./B.el~
~#+end_src~


*** Add property to define default export file

Or you can add the following property before the first headline of this line

~#+PROPERTY: header-args:emacs-lisp :tangle ./init-example.el~

It acts as a default tangle target, then you only need to specific in the code block.

But if you want to export to a different file, you can specific like this:

~#+begin_src emacs-lisp :tangle ./another.el~
~#+end_src~


Or you want to temporary disable/ignore tangle for the particular code block, then you can specific like this:

~#+begin_src emacs-lisp :tangle no
~#+end_src~

But keep that in mind, =you have to re-open this file to take affect if you changed the default tangle file!!!=


** How to export ORG file content to HTML

You can run ~org-export-dispatch~ command to export your ORG file to any supported output formats.

After running the ~org-export-dispatch~ command, you will see the popup buffer like this:

#+BEGIN_SRC text
 Use SPC, DEL, C-n, or C-p to navigate.
 [C-b] Body only:    Off           [C-v] Visible only:     Off
 [C-s] Export scope: Buffer        [C-f] Force publishing: Off
 [C-a] Async export: Off


 [c] Export to iCalendar
     [f] Current file              [a] All agenda files
     [c] Combine all agenda files

 [h] Export to HTML
     [H] As HTML buffer            [h] As HTML file
     [o] As HTML file and open

 [l] Export to LaTeX
     [L] As LaTeX buffer           [l] As LaTeX file
     [p] As PDF file               [o] As PDF file and open

 [o] Export to ODT
     [o] As ODT file               [O] As ODT file and open

 [t] Export to Plain Text
     [A] As ASCII buffer           [a] As ASCII file
     [L] As Latin1 buffer          [l] As Latin1 file
     [U] As UTF-8 buffer           [u] As UTF-8 file

 [P] Publish
     [f] Current file              [p] Current project
     [x] Choose project            [a] All projects


 [&] Export stack                  [#] Insert template
 [q] Exit 
#+END_SRC

Then press ~h~ to focus on the HTML exporting.

*** Export customization

**** Export =TOC= (Table Of Content)

You can set the global variable ~org-export-with-toc~ to ~t~ if you want of export the =TOC=, or set it to ~nil~ if you don't. That setting affects all ORG files.

But you can set it to ~nil~ by default and add the following options to the particular ORG file to affect only for the given file:

#+BEGIN_SRC emacs-lisp :tangle no
  ;;
  ;; Disable  exporting =TOC= for this ORG file
  ;;
  #+options: toc:nil

  ;;
  ;; Enable exporting =TOC= for this ORG file
  ;;
  #+options: toc:t

  ;;
  ;; Enable exporting =TOC= for this ORG file and ONLY export the all heading level 1
  ;;
  #+options: toc:1

  ;;
  ;; Enable exporting =TOC= for this ORG file and ONLY export the all heading level 2
  ;;
  #+options: toc:2
#+END_SRC



** Install =Treesitter langauge grammar=

You need to evaluate the following command to install all treesitter language grammars.

#+begin_src emacs-lisp :tangle no
  (mapc #'treesit-install-language-grammar (mapcar #'car treesit-language-source-alist))
#+end_src


** Learn how to use ~use-package~

https://github.com/jwiegley/use-package#getting-started


** Edit =emacs-lisp= source code in =org-mode=

When editing =emacs-lisp= source code your =org= file inside the =emacs-lisp= code block like this:

#+BEGIN_SRC emacs-lisp :tangle no
  (message "Hey:)")
#+END_SRC

You can press ~C-c '~ inside the code block to open a source code editing window in the =emacs-lisp= major mode (or any major mode you specified following by the =#+BEGIN_SRC=), then your =company-mode= and =eglot-mode= wll work well!!!

Then you don't need to switch to the =*scratch*= to edit your code for having the better coding experience and switch back:)


** How to run shell command in =Emacs=

You can run any emacs-lisp expressions in =evil commmand mode= which means you type ~:~ and follow by your emacs-lisp expression.

Also, you can run a shell commmand by ~:!~ and then follow by your shell command.

In the =dired-mode=, you can run a shell command by ~!~ or ~&~:

+ ~!~ runs the command ~dired-do-shell-command~ to execute your shell command.
+ ~&~ runs the command ~dired-do-async-shell-command~ to execute your shell command asynchronously.

And 2 things you need to know:

1. The shell command result will print out in the echo area or open a new buffer (depending on the output length).

2. You =SHOULD NOT= run any shell command that asks for interactive with =vim-keybindings=, as the command will halt and your keystrokes only go into the evil mode and operate inside the buffer (not passing to the shell command)!!!


** How to handle =org table=

Here, I only list the most convenient parts that I'm interested in, for more details, please have a look [[https://orgmode.org/manual/Built_002din-Table-Editor.html][here]].

Here are the default org table commands and behaviors:

*** Auto create table heading line and the first row

When finishing typing the following header line (=C= is your cursor position):

=|Name|Description|C=

Then you can press ~C-c RET~, it calls the ~org-ctrl-c-ret~ command to add the =hline= and first row like this:

| Name | Description |
|------+-------------|
| C    |             |

And =C= is your new cursor position, then you can keep typing.


*** Use =TAB= and =RET= to jump

When you got a table like the following (=C= is your cursor position):

| Name | Description |
|------+-------------|
| C    |             |

Then you can press ~TAB~ or ~RET~ to switch between columns and rows. Bascially, it calls ~org-cycle~ command. The main purpose of ~org-cycle~ is outline visibility cycling, but it also invokes other actions:

When inside a table, re-align the table and move to the next field.

But it works in different ways in =evil-mode=:


**** Move to the next column (create new row when hitting the most-right column)

| Name | Description |
|------+-------------|
|    C |           1 |
|    2 |           3 |
|    4 |             |

Suppose you have the above table, then in =Normal= mode, you press =RET= to call ~org-cycle~ command. Your cursor should jump like this:

C -> 1 -> 2 -> 3 -> 4


**** Move to the next column but next row (create new row when hitting the most-right column)

| Name | Description |
|------+-------------|
|    C |             |
|    1 |             |
|    2 |             |
|    3 |             |
|    4 |             |

Suppose you have the above table, then in =Insert= mode, you press =RET= to call ~org-return~ command. Your cursor should jump like this:

C -> 1 -> 2 -> 3 -> 4

Jump to next row and same column!!!

But if you want to jump to next column (in the same row) in =Insert= mode, you can press =TAB= to call =org-cycl=.


** How to handle =org= mode link manually

**** how to create link

Under the hook, org link format just like this =[[LINK_URL][DESCRIPTION_TO_DISPLAY]]=.

You can type from left to right, it won't show as a =Link= until you type the final =]= character.


**** How to edit created link

After created a link, you CAN'T see the =[[][]]= original text as it hides by the =org-hide-emphasis-markers= settings in =~/.config/color_theme.org=.

But you can go to the end of the link text and delete the last =]= character, then the original text
shows back (as that's broken link format) like this:

[[https://link][Hey]

Then you can change the URL or the DESCRIPTION part and add back the final =]= character, link shows back again.


** Default keybindings in =Emacs=

Although you install =Evil= package to enable =Vim Keybindings=, but sometimes your evil keybindings still won't work in some sort of the major modes.

So, you need to use the default =Emacs= keybindings in those siutations, what's why you better to know some of them from the very beginning.

Here are the common keybindings you should know about when dealing with =Emacs= :

| Keybindgins                     | Description                                                                                 |
|---------------------------------+---------------------------------------------------------------------------------------------|
| [Run function]                  |                                                                                             |
| ~M-x~                             | M means the meta-key, it's ALT or CMD (in MacOS), it calls ~execute-extended-command~         |
|                                 |                                                                                             |
| [Close and exit]                |                                                                                             |
| ~C-x C-c~                         | Bascially, exit =Emacs=, will ask you save unsaved buffer.                                    |
| ~C-x 4 0~                         | Call ~kill-buffer-and-window~ to close current window and buffer.                             |
|                                 |                                                                                             |
| [File & Dired]                  |                                                                                             |
| ~C-x C-f~                         | Call ~find-file~.                                                                             |
| ~C-x d~                           | Call ~dired~                                                                                  |
|                                 |                                                                                             |
| [Window]                        |                                                                                             |
| ~C-x 0~                           | Call ~delete-window~ to close current window, but NOT close the buffer.                       |
| ~C-x 1~                           | Call ~delete-other-windows~ to kill all other windows except the current window               |
| ~C-x 2~                           | Call ~split-window-below~ to split the window up and down direction                           |
| ~C-x 3~                           | Call ~split-window-right~ to split window on the right                                        |
|                                 |                                                                                             |
| [Org mode]                      |                                                                                             |
| ~<tab>~                           | Call ~org-cycle~ to fold or unfold the point at heading sub-tree                              |
| ~<backtab>~                       | Call ~org-shifttab~ to fold or unfold all heading sub-tree                                    |
| ~M-RET~                           | Call ~org-meta-return~ to add the next heading/list/item with the correct level               |
| ~C-j~                             | Call ~org-forward-heading-same-level~ to jump down to next (same level) heading.              |
| ~C-k~                             | Call ~org-backward-heading-same-level~ to jump up to next (same level) heading.               |
|                                 |                                                                                             |
| [Org mode heading level change] |                                                                                             |
| ~S-<up>~                          | Call ~org-metaup~ to move current heading up                                                  |
| ~S-<down>~                        | Call ~org-metadown~ to move current heading down                                              |
| ~S-<left>~                        | Call ~org-shiftleft~ to change item level/bullet type, reorder seq no automatically           |
| ~S-<right>~                       | Call ~org-shiftright~ to change item level/bullet type, reorder seq no automatically          |
|                                 |                                                                                             |
| [Org mode heading navigation]   |                                                                                             |
| ~g j~                             | Call ~outline-forward-same-level~ to jump down to next (same level) heading.                  |
| ~g k~                             | Call ~outline-backward-same-level~  to jump up  to next (same level) heading.                 |
| ~] ]~                             | Call ~outline-next-visible-heading~ to jump down to next  heading.                            |
| ~[ [~                             | Call ~outline-previous-visible-heading~  to jump up  to next heading.                         |
| ~z u~                             | Call ~outline-up-heading~ to jump back to parent level heading.                               |
|                                 |                                                                                             |
| ~C-c '~                           | Call ~org-edit-special~ to open the src editing window (with LSP support!!!)                  |
| ~C-c '~                           | Call ~org-edit-src-exit~ to accept the change and exit                                        |
| ~C-c C-k~                         | Call ~org-edit-src-abort~ to abort and exit                                                   |
| ~C-c C-x C-v~                     | Call ~org-toggle-inline-images~ to toggle image link to show image                            |
|                                 | Call ~org-toggle-link-display~ to toggle displaying the link content or the description       |
|                                 |                                                                                             |
| [Org mode link]                 |                                                                                             |
| ~C-c C-l~                         | Calls the ~org-insert-link~ to create or edit a link                                          |
| ~C-c C-o~                         | Calls the ~org-open-at-point~ to open a thing at point                                        |
|                                 |                                                                                             |
| [Org mode table]                |                                                                                             |
| ~C-c RET~                         | Calls the ~org-ctrl-c-ret~ command to add the =hline~ and first row                           |
| ~C-c C-c~                         | Calls ~org-ctrl-c-ctrl-c~ to re-align table, same result like calling ~org-table-align~         |
| NORMAL model ~RET~                | Calls ~org-cycle~ to re-align the table and move to the next field.                           |
| INSERT mode ~TAB~                 | Calls ~org-cycle~ to re-align the table and move to the next field.                           |
| INSERT mode ~RET~                 | Calls ~org-return~ to re-align the table and move to the same column but next rows.           |
| ~S-<up>~                          | Call ~org-metaup~ to move current row up                                                      |
| ~S-<down>~                        | Call ~org-metadown~ to move current row down                                                  |
| ~S-<left>~                        | Call ~org-metaleft~ to move current column to left                                            |
| ~S-<right>~                       | Call ~org-metaright~ to move current column to right                                          |
|                                 |                                                                                             |
| [Dired]                         |                                                                                             |
| ~C-x d~                           | Call ~dired~                                                                                  |
| ~(~                               | Call ~dired-hide-details-mode~ to toggle detail mode                                          |
| ~^~                               | Call ~dired-up-directory~                                                                     |
| ~RET~                             | Call ~dired-find-file~                                                                        |
| ~g o~                             | Call ~dired-find-file-other-window~ to open the file in separated window                      |
| ~m~                               | Call ~dired-mark~ on file at point                                                            |
| ~u~                               | Call ~dired-unmark~ on file at point                                                          |
| ~U~                               | Call ~dired-unmark-all-marks~                                                                 |
| ~t~                               | Call ~dired-toggle-marks~ to mark or unmark all files                                         |
| ~M~                               | Call ~dired-do-chmod~ to run ~chmod~                                                            |
| ~C~                               | Call ~dired-do-copy~                                                                          |
| ~R~                               | Call ~dired-do-rename~ to rename or move file or directory                                    |
| ~D~                               | Call ~dired-do-delete~                                                                        |
| ~Z~                               | Call ~dired-do-compress~                                                                      |
| ~C-x C-q~                         | Call ~dired-toggle-read-only~ to turn the buffer into ~wdired-change-to-wdired-mode~            |
| ~C-c C-k~                         | Call ~wdired-abort-changes~ to discard changes in ~wdired-change-to-wdired-mode~                |
| ~C-c C-c~                         | Call ~wdired-finish-edit~ to accept changes in ~wdired-change-to-wdired-mode~                   |
|                                 |                                                                                             |
| [Dired] create                  |                                                                                             |
|                                 | Call ~make-empty-file~ to create empty file                                                   |
|                                 | Call ~mkdir~ or ~make-directory~ to create directories                                          |
|                                 |                                                                                             |
| [Dired] image                   |                                                                                             |
| ~C-j~                             | Call ~image-next-file~ to render next image (image-mode)                                      |
| ~C-k~                             | Call ~image-previous-file~ to render previous image (image-mode)                              |
|                                 |                                                                                             |
| [Dired] shell                   |                                                                                             |
| ~!~                               | Call ~dired-do-shell-command~ reads a shell command on the marked files.                      |
| ~&~                               | Call ~dired-do-async-shell-command~ reads a shell command on the marked files asynchronously. |
|                                 |                                                                                             |
| [Dired] filter                  |                                                                                             |
| ~*%~                              | Call ~dired-mark-files-regexp~ to prompt the regexp to do filtering on current dired buffer   |
| ~t~                               | Call ~dired-toggle-marks~ to toggle the marked items                                          |
| ~K~                               | Call ~dired-do-kill-lines~ to kill (or say filter out) the marked items                       |
|                                 | Call ~revert-buffer~ to refresh the folder (back to before filtering)                         |
|                                 |                                                                                             |
| [Shell command]                 |                                                                                             |
| =:=                               | Runs the command ~evil-ex~ (found in =evil-motion-state-map=) to evaluate LISP expression       |
| =:!=                              | Runs the command ~evil-shell-command~ on a given shell command                                |
|                                 |                                                                                             |
| [Image Dired]                   |                                                                                             |
|                                 | Call ~image-dired~                                                                            |
| ~RET~                             | Call ~image-dired-display-thumbnail-original-image~                                           |
| ~C-j~                             | Call ~image-next-file~ to render next image (image-dired-image-mode)                          |
| ~C-k~                             | Call ~image-previous-file~ to render previous image (image-dired-image-mode)                  |
| ~-~                               | Call ~image-decrease-size~ to zoom out the rendered image                                     |
| ~+~                               | Call ~image-increase-size~ to zoom out the rendered image                                     |
|                                 | Call ~image-transform-fit-to-window~ to zoom out the rendered image                           |
|                                 |                                                                                             |
| [Info]                          |                                                                                             |
| ~~C-h i~                          | Call ~info~, the documentation browser.                                                       |
| ~d~                               | Call ~Info-directory~ to go back to the Info catalog                                          |
| ~RET~                             | Call ~Info-follow-nearest-node~ to go into a topic node                                       |
| ~i~                               | Call ~Info-index~ then you can search sub categories in current info topic                    |
| ~u~                               | Call ~Info-up~ to go up/parent topic search sub categories in current info topic              |
|                                 |                                                                                             |
| [Projects]                      |                                                                                             |
| ~C-x p !~                         | Call ~project-shell-command~ to run shell command in project root folder                      |
| ~C-x p &~                         | Call ~project-async-shell-command~ to run shell command async in project root folder          |
| ~C-x p D~                         | Call ~project-dired~ to open dired in project root folder                                     |
| ~C-x p f~                         | Call ~project-find-file~ to do fuzzy finding in project root folder                           |
| ~C-x p p~                         | Call ~project-switch-project~ to select another project root folder                           |
| ~C-x p b~                         | Call ~project-switch-to-buffer~ to switch opened buffers in current project                   |
|                                 |                                                                                             |
| [Color]                         |                                                                                             |
|                                 | Call ~list-colors-display~                                                                    |
|                                 |                                                                                             |
| [Faces]                         |                                                                                             |
|                                 | Call ~list-faces-display~                                                                     |
|                                 |                                                                                             |
| [Theme]                         |                                                                                             |
|                                 | Call ~consult-theme~ to preview theme                                                         |
| [Misc]                          |                                                                                             |
|                                 | Call ~restart-emacs~ to restart emacs instance                                                |
|                                 | Call ~emacs-init-time~ to print the emacs start time                                          |
|                                 |                                                                                             |


** How to customize keybindgins

*** Concepts: Key, Mode, Keymap and Hook

**** 1. Key

Usually, you should use ~(kbd KEY)~ to present a key combination that you want to bind.

One important point to note is that you must surround special keys with =<= and =>=. That includes Function-Keys, Arrow keys and Home row keys, like so: =<home>=, =<f8>=, =<up>=, =<down>=, =<tab>=, =<backtab>=, and =<return>=.

And you can evalute the ~(kbd KEY)~ function to see its value like below:

#+begin_src emacs-lisp :tangle no
  ;; (message "(kbd \"TAB\"): %s" (kbd "TAB"))
  ;; (message "(kbd \"<tab>\"): %s" (kbd "<tab>"))

  ;; (message "(kbd \"S-TAB\"): %s" (kbd "S-TAB"))
  ;; (message "(kbd \"S-<tab>\"): %s" (kbd "S-<tab>"))
  ;; (message "(kbd \"<backtab\"): %s" (kbd "<backtab"))

  ;; (message "(kbd \"RET\"): %s" (kbd "RET"))
  ;; (message "(kbd \"<return>\"): %s" (kbd "<return>"))

  ;; (message "(kbd \"S-RET\"): %s" (kbd "S-RET"))
  ;; (message "(kbd \"S-<return>\"): %s" (kbd "S-<return>"))
#+end_src

Then you can see the value in =*Messages*= buffer like this:

=(kbd "TAB"):=
=(kbd "<tab>"): [tab]=
=(kbd "S-TAB"): [33554441]=
=(kbd "S-<tab>"): [S-tab]=
=(kbd "<backtab"): <backtab>=
=(kbd "RET"): 
=(kbd "<return>"): [return]=
=(kbd "S-RET"): [33554445]=
=(kbd "S-<return>"): [S-return]=

So, there are the stuffs you lean:

- ="TAB"= is different with ="<tab>"=, ="RET"= is different with ="<return>"=.
- You should choose ="<tab>"=, ="<return>"= instead of ="TAB"= and ="RET"= for most of the cases.


More examples:

| Key                | Description         |
|--------------------+---------------------|
| ~(kbd "<tab>")~      | Tab key             |
| ~(kbd "<backtab>")~  | Shift + Tab         |
| ~(kbd "<return>")~   | Return key          |
| ~(kbd "S-<return>")~ | Shfit + Return key  |
| ~(kbd "s-m")~        | Super-m             |
| ~(kbd "H-m")~        | Hyper-m             |
| ~(kbd "A-m")~        | Alt-m               |
| ~(kbd "C-x C-o")~    | Ctrl-C, then Ctrl-O |
| ~(kbd "<leader>df")~ | Space then d then f |


**** 2. Modifer keys

There are a few rules when using modifer key in =Emacs=:

1) Control-modified alphabetical characters are =case-insensitive=, that's why:

   - =C-a= is the same with =C-A=
   - =C-z= is the same with =C-Z=

2) Control-modified non-alphabetical characters are =case-sensitive=, that's why:

   - =C-2= is the NOT the same with =C-@= (even that's the key physical key but with or without a =Shift= key pressed)

3) Meta-modified, Alt-modified, Hyper-modified are =case-sensitive= all the time, that's why:
   
   - =M-a= is different with =M-A=
   - =A-a= is different with =A-A=
   - =s-a= is different with =s-A=

4) Not all terminal emulators support =Shift (S-)=, =Super (s-)=, =Hyper (H-)=, and =Alt (A-)=, that said you can use those modifier keys in =GUI= version but NOT in =terminal= version!!!


 One more trick about knowing whether the given key combination is valid or not is that you can use run the ~(key-valid-p "KEY_STRING_HERE")~ function, it returns =t= if key is valid or returns =nil= if key is invalid.

 For examples:

 #+begin_src emacs-lisp :tangle no
   ;; (key-valid-p "b")
   ;; (key-valid-p "C-a")
   ;; (key-valid-p "s-a")
   ;; (key-valid-p "X-a") ;; This returns nil!!!
 #+end_src


**** 3. Mode

=Mode= means =FileType= in =Vim=. You got different =modes= when you open different files into the buffer. For example:

- =typescript-mode= is available when you open =*.ts= files
- =c-mode= is available when you open =*.c= files
- =org-mode= is available when you open =*.org= files
- =message-mode= the current buffers is =*Messages*=
- =lisp-mode= the current buffers is =*scratch*=
- =help-mode= the current buffers is =*Help*=
- =ivy-minibuffer-map= the current buffer is ivy minibuffer
=- ivy-switch-buffer-map= the current buffer is opened for switching buffer
etc. 

Different =mode= effects the visual result in buffer, and you can turn the current buffer into any =Mode= you want, just run =xxx-mode= function.


+ What is =Major= mode and =Minor= mode???

  When you open a buffer, the current buffer has =Major= mode which determined by the opened file type and =Minor= mode which means all alternative mode attached to this buffer.

  For example:

  1) When you open an =*.org= file and run ~describe-mode~, then you should see the following description:

      #+begin_comment
        =Minor= modes enabled in this buffer: =Command-Log= =Company=
        =Display-Line-Numbers= =Evil-Collection-Unimpaired= =Evil-Local=
        =Evil-Surround= =Font-Lock= =Olivetti= =Org-Indent= =Visual-Line=

        The major mode is =Org= mode defined in org.el:
      #+end_comment


  2) When you open a =*.c= file and ~describe-mode~, then you should see the following description:

      #+begin_comment
        =Minor= modes enabled in this buffer: =Command-Log= =Company=
        =Display-Line-Numbers= =Eldoc= =Evil-Collection-Unimpaired= =Evil-Local=
        =Evil-Surround= =Flymake= =Font-Lock= =Highlight-Indent-Guides= =Lsp-Completion=
        =Lsp-Diagnostics= =Lsp-Headerline-Breadcrumb= =Lsp-Managed= =Lsp=
        =Lsp-Modeline-Code-Actions= =Lsp-Modeline-Diagnostics=
        =Lsp-Modeline-Workspace-Status= =Lsp-Ui-Doc= =Lsp-Ui= =Lsp-Ui-Sideline=

        The major mode is =C/*l= mode defined in cc-mode.el:

        Major mode for editing C code.
      #+end_comment


    The =Major= mode is the =File type=, and the =Minor= mode is added by the packages you installed, they all work together. Usually, the =Major= mode (=xxx-mode= of the file type) should be the target mode if you want to bind some keys to buffer.


**** 4. Keymap

A =keymap= is a Lisp data structure that specifies key bindings for various key sequences.

Its value looks like this:

=(keymap=
=(tab)=
=(11)=
=(normal-state keymap "Auxiliary keymap for Normal state"=
                =(13 . org-cycle))=
=(leader keymap=
            =(99 keymap=
                =(98 . org-insert-structure-template)))=
=(67108899 . org-table-rotate-recalc-marks)=
=(10)=
=(13 . org-return)=

Basically, it's talking about =pressing what key (combination) to call what function= and that's it:)

So, different =modes= have different =keymaps=, e.g.:

+ =global-map= is for holding the =keys -> functions= relationship of default modes (a lot of them).
+ =typescript-mode-map= is for holding the =keys -> functions= relationship of =typescript-mode=.
+ =c-mode-map= is for holding the =keys -> functions= relationship of =c-mode= 

That said when you use =global-map=, =xxx-mode-map= in the =define-key= function, you should make sure to evaluate its map value!!!!

- The correct example:

    #+BEGIN_SRC emacs-lisp :tangle no
      (define-key global-map (kbd "<tab>") nil)
      (define-key (list global-map org-mode-map) (kbd "<tab>") nil)
    #+END_SRC

    The =global-map= and =(list global-map org-mode-map)= will be evaluted to its map value!!!

- The wrong example:

    #+BEGIN_SRC emacs-lisp :tangle no
      (define-key 'global-map (kbd "<tab>") nil)
      (define-key '(global-map org-mode-map) (kbd "<tab>") nil)
    #+END_SRC

    The ='global-map= and ='(global-map org-mode-map)= won't be evaluted to its map value and it will cause =(define-key YOUR_MAP "\n" YOUR_FUNCTION_OR_NIL)= error!!!


**** 5. Hook

Sometimes, =xxx-mode= and =xxx-mode-map= are only available after finishing loading the file, that said the following keybinding will fail as the paritcular =mode= and =mode-map= don't exists before the file has been loaded.

~(define-key (list c-mode-map typescript-mode-map) (kbd "Q") 'exit)~

For solving that problem, you can use =xxx-mode-hook= to defer binding.


*** How to bind keys in Emacs

**** What functions you can use to bind keys

Plz keep that in mide:

The following keybinding functions only can bind =KEY= to =COMMAND= (which means a function uses =(interactive)= and be able to list in the =M-x= list).

You got a few ways to bind keys in =Emacs=:

***** ~(global-set-key KEY COMMAND)~

~global-set-key~ binds the ~KEY~ to the =global-map= to call the ~COMMAND~

Here is the example:

#+BEGIN_SRC emacs-lisp :tangle no
  (global-set-key (kbd "<tab>") 'switch-to-next-buffer)
  (global-set-key (kbd "<backtab>") 'switch-to-prev-buffer)
#+END_SRC


~globa-set-key~ is a legacy function; see ~keymap-global-set~ for the recommended function to use instead. Here are some examples:

Pay attention that: you don't need to call ~(kbd)~ when using ~keymap-global-set~!!!

#+BEGIN_SRC emacs-lisp :tangle no
  (keymap-global-set "C-c y" 'clipboard-yank)
  (keymap-global-set "C-M-q" 'query-replace)
  (keymap-global-set "<f5>" 'flyspell-mode)
  (keymap-global-set "C-<f5>" 'display-line-numbers-mode)
  (keymap-global-set "C-<right>" 'forward-sentence)
  (keymap-global-set "<mouse-2>" 'mouse-save-then-kill)
#+END_SRC


***** ~(define-key KEYMAP KEY DEF &optional REMOVE)~

This is the better way to use, as it gives you a chance to bind to different =mode=.

=global-set-key= is a shortcut for (=define-key global-map KEY COMMAND)=.

Let's have a look how to bind the =Q= to =kill-current-buffer= command in all =modes=:

#+BEGIN_SRC emacs-lisp :tangle no
  ;; Unbind 'Q'
  (define-key dired-mode-map (kbd "Q") nil)

  ;; Re-bind 'Q'
  (define-key evil-normal-state-map (kbd "Q") 'kill-current-buffer)
  (define-key evil-motion-state-map (kbd "Q") 'kill-current-buffer)
#+END_SRC



***** ~(keymap-set KEYMAP KEY DEFINITION)~ This is the recommended way!!!

~define-key~ is a legacy function; see ~keymap-set~ for the recommended function to use instead. Here are some examples:

Pay attention that: you don't need to call ~(kbd)~ when using ~keymap-set~!!!

#+BEGIN_SRC emacs-lisp :tangle no
  (keymap-set texinfo-mode-map "C-c p" 'backward-paragraph)
  (keymap-set texinfo-mode-map "C-c n" 'forward-paragraph)))
  (keymap-set texinfo-mode-map "C-c C-x x" nil)
#+END_SRC


***** ~(evil-define-key STATE KEYMAP KEY DEF &rest BINDINGS)~

This only exists after installing ~evil~ package!!!

When you need to set a keybinding to the particular =state= and =mode=, you can use ~evil-define-key~ instead. Here is the example:

#+BEGIN_SRC emacs-lisp :tangle no
  (evil-define-key 'normal org-mode-map (kbd "RET") 'org-cycle)
#+END_SRC


~STATE~ is one of ~normal~, ~insert~, ~visual~, ~replace~, ~operator~, ~motion~, ~emacs~, or a list of one or more of these.

Omitting a state by using ~nil~ corresponds to a standard Emacs binding using ~define-key~. The remaining arguments are like those of ~define-key~. For example:

#+BEGIN_SRC emacs-lisp :tangle no
  (evil-define-key 'normal foo-map "a" 'bar)
#+END_SRC

This creates a binding from a to bar in ~normal~ state, which is active whenever ~foo-map~ is active. Using ~nil~ for the state, the following lead to identical bindings:

#+BEGIN_SRC emacs-lisp :tangle no
  (evil-define-key nil foo-map "a" 'bar)
  (define-key foo-map "a" 'bar)
#+END_SRC


***** ~(evil-local-set-key STATE KEY DEF)~

This only exists after installing ~evil~ package!!!

Each evil state also has a =buffer-local keymap= which is specific to the current buffer, and which takes precedence over the global keymap.

These maps are most suitably modified by a mode hook.  They are named ~evil-XXX-state-local-map~, where the ~xxx~ is one of the valid evil state.

Example:

#+BEGIN_SRC emacs-lisp :tangle no
  ;;
  ;; Add a binding ('w' to call 'some-function') in evil 'motion' state
  ;; when a buffer has been set to 'some-mode'!!!
  ;;
  ;; Or say like this (if you're a vim/Neovim user):
  ;; Add a binding to the local buffer (with 'some-mode' filetype) in normal
  ;; mode and visual mode.
  ;;
  (add-hook 'some-mode-hook
  	(lambda ()
  		;;
  		;; 
  		;;
  		(evil-local-set-key 'motion (kbd "w") 'some-function)
  	)
  )

  ;;
  ;; The followings are totally identical, just pick it you like:
  ;;
  ;; (evil-local-set-key 'motion (kbd "w") 'some-function)
  ;;
  ;; (keymap-set evil-motion-state-local-map "w" 'some-function)
  ;;
  ;; (define-key evil-motion-state-local-map (kbd "w") 'some-function)
  ;;
#+END_SRC


**** How to unbind/disable the default keybindings that you don't use

It's very important that you should know =How to disable/unbind the default keybindings that you don't use=!!!! Otherwise, your keybinding won't work as you expected!!!

Here are the steps of how you can find which =mode= already have the keybindings you want to set and unbind it

***** 1. Run ~describe-key~ and then press your key, for example =Q=

It should show the command info into a new buffer (if your key has been bound to some modes).

At the very top part, it should say what function your =Q= has been bound to already, and the =Key Bindings= section should show you that your =Q= also bound to in which =mode= like this:

--------------------------------------------------
=Key Bindings=
completion-list-mode-map z
evil-motion-state-map Q
evil-normal-state-map Q
--------------------------------------------------

That said, you should unbind all those =modes= for your =Q= (if that's NOT what you want).


***** 2. But sometimes, ~describe-key~ doesn't list all =modes= as some modes won't exists before opening the file has that mode

For that situation, you should run ~clm/toggle-command-log-buffer~ to show the command log buffer. And then, go to any UIs/modes to press your key (for exmaple =Q= in this case) and see what functions it binds to.

After that, run ~describe-function~ and put the function name there, help buffer should show you the =Key Bindings= section (if keybinding exists). That's how you can get the hidden =modes= in different situations.

***** 3. So, how to unbind/unset keybindings you found?

The answer is just bind it to =nil=.

=(define-key YOUR_MODE_NAME_HERE (kbd YOUR_KEY_HERE) nil)=


**** How to bind key via hooks

Sometimes, =xxx-mode= and =xxx-mode-map= are only available after finishing loading the file, that's why you should bind key via a =hook= in those situations.

***** 1. Bind key to =xxx-mode-map=

#+begin_src emacs-lisp :tangle no
  ;;
  ;; Command to run when pressing 'C-c a'
  ;;
  (defun print_a_message()
      (interactive)
      (message "Print something by pressing 'C-c a'.")
  )

  ;;
  ;; The bind function to be called when 'org-mode' is available
  ;;
  (defun bind-test-key-to-org-mode-via-hook()
    (message ">>> [ org-mode-hook-test ] Set temp keybinding 'C-c a' org mode")
    (define-key org-mode-map (kbd "C-c a") 'print_a_message)
  )

  ;;
  ;; Add the bind function to 'org-mode-hook'
  ;;
  (add-hook 'org-mode-hook #'bind-test-key-to-org-mode-via-hook)
#+end_src

If you evaluate the above functions, then run ~describe-variable~ on =org-mode-hook=, you should see the following value has been added to that hook:

~bind-test-key-to-org-mode-via-hook my/org-mode-setup~

Then when you open an =org= file or run ~org-mode~ (to reload), then run ~describe-variable~ on =org-mode-map= again, you should see the follwing key->function relationship has been add to its keymap:

=(3 keymap=
    =(97 . print_a_message)=

And then press ~C-c a~, you should see the ~Print something by pressing ’C-c a’.~ debug message has been printed to the =*Messages*= buffer, that said your mode-hook settings is working:)


***** 2. Bind key to local buffer

The example above binds the ~C-c a~ to =org-mode-map=, But you can't stop other installed packages from binding the same keybindings to the same hook sometimes. If that happens, then duplicated binding to =org-mode-map= might happen. So, if there is no special needs, you should use =xxx-mode-hook= to do defer binding to the local buffer, as this promises no duplicated bindings.

Let's fix the above duplicated bindings:

#+begin_src emacs-lisp :tangle no
  ;;
  ;; Command to run when pressing 'C-c a'
  ;;
  (defun print_a_message()
      (interactive)
      (message "Print something by pressing 'C-c a'.")
  )

  ;;
  ;; The bind function to be called when 'org-mode' is aviable
  ;;
  (defun bind-test-key-to-org-mode-via-hook()
    (message ">>> [ bind-test-key-to-org-mode-via-hook ] Set temp keybinding 'C-c a' local buffer")

    ;;
    ;; Bind the local buffer scope rather than the 'org-mode-map'
    ;;
    (define-key evil-normal-state-local-map (kbd "C-c a") 'print_a_message)

    ;;
    ;; '(evil-local-set-key 'normal KEY COMMAND)' is the same with 
    ;; '(define-key evil-normal-state-local-map KEY COMMAND)',
    ;;
    ;; Just pick the one you like to use
    ;;
    ;; (evil-local-set-key 'normal (kbd "C-c a") 'print_a_message)
  )

  ;;
  ;; Add the bind function to 'org-mode-hook'
  ;;
  (add-hook 'org-mode-hook #'bind-test-key-to-org-mode-via-hook)
#+end_src

Then when you open an =org= file or run ~org-mode~ (to reload), then run ~describe-variable~ on =org-mode-map=, you won't see any key binding to call the ~print_a_message~ command.

But if you run ~describle-bindings~ (in the org file buffer),  you should see the following setting is on the top part:

~=evil-normal-state-local-minor-mode' Minor Mode Bindings:~
    ~Key             Binding~
    ~C-c a		print_a_message~

That means the ~C-c a~ only bind to the current opened buffer, try to press ~C-c a~, you should see the ~Print something by pressing ’C-c a’.~ debug message has been printed to the =*Messages*= buffer, that said your mode-hook settings is working:)


*** How to unbind all keybindings for the given mode

If you really want to unbind all keybindings for the particular mode, do like this:

#+BEGIN_SRC emacs-lisp :tangle no
  (setf (cdr YOUR_MODE_NAME_HERE) nil)
#+END_SRC


** How to pipe stdout into Emacs =scratch= buffer

You can't do something like this:

#+BEGIN_SRC fish
  cat ~/temp/data.txt | emacs --no-window-system

  #
  # Error:
  #
  # emacs: standard input is not a tty 
#+END_SRC

Instead, you should redirect the pipe content into a temp file and then open =Emacs= by call the ~insert-file~ function like this:

#+BEGIN_SRC fish
  #
  # '/tmp/emacs_temp' is the temp file
  #
  cat ~/temp/data.txt > /tmp/emacs_temp && emacs --no-window-system --eval "(insert-file \"/tmp/emacs_temp\")" 
#+END_SRC


** How to customize abbreviation

When you need help, run ~info~ and goto the section: =Elisp -> Abbrevs=

*** Quick introduction

=Abbreviation= in Emacs means that you type something, it expands to something else for you: =abbr --> expansion=

=Abbreviation= lives in different tables:

- =global-abbrev-table=: The abbrev table whose abbrevs affect all buffers.

- =xxx-mode-abbrev-table=: Abbrev table for xxx mode, it only affects the related buffer with the same mode.

For example, if you add some abbrevs into ~emacs-lisp-mode-abbrev-table~ and ~global-abbrev-table~, and if you run:

~describe-variable global-abbrev-table
~describe-variable emacs-lisp-mode-abbrev-table~


Then you got something like this:

#+BEGIN_SRC emacs-lisp :tangle no
  ;;
  ;; 'emacs-lisp-mode-abbrev-table'
  ;;
  (define-abbrev-table 'emacs-lisp-mode-abbrev-table
  	'(
  	  ("bg" "background" nil :count 0)
  	  ("btw" "By the way" nil :count 0)
  	)
  )

  ;;
  ;; 'global-abbrev-table'
  ;;
  (define-abbrev-table 'global-abbrev-table
    '(
      ("afaik" "as far as I know" nil :count 0)
      ("atm" "at this moment" nil :count 0)
      ("bg" "background" nil :count 0)
      ("fg" "foreground" nil :count 0)
  	)
  )
#+END_SRC

That's how abbreviation works in Emacs, really simple:)

But one thing you need to keep that in mind:

If you have the same abbr in =global-abbrev-table= and =xxx-mode-abbrev-table=, then the abbr in =xxx-mode-abbrev-table= will be used if you're in =xxx-mode=!!!


Here are the steps customize your own abbrs:


*** How to list abbrs?

#+BEGIN_SRC emacs-lisp :tangle no
  ;;
  ;; Display a list of the defined abbrevs.
  ;;
  ;; (list-abbrevs &optional LOCAL)
  ;;

  ;; Only list the abbr table that in current buffer's mode 
  (list-abbrevs t)

  ;; List all abbr tables
  (list-abbrevs)
#+END_SRC


*** How to add/remove your own abbrs

#+BEGIN_SRC emacs-lisp :tangle no
  ;;
  ;; Define ABBREV in TABLE, to expand into EXPANSION and optionally call HOOK.
  ;;
  ;; (define-abbrev TABLE ABBREV EXPANSION &optional HOOK &rest PROPS)

  ;;
  ;; For example:
  ;;

  ;;
  ;; For all buffers (no matter what mode is)
  ;;
  (define-abbrev global-abbrev-table "bg" "background")
  (define-abbrev global-abbrev-table "fg" "foreground")
  (define-abbrev global-abbrev-table "afaik" "as far as I know")
  (define-abbrev global-abbrev-table "atm" "at this moment")
  (define-abbrev global-abbrev-table "mygithub" "https://github.com/wisonye")
  (define-abbrev global-abbrev-table "mylinkedin" "https://www.linkedin.com/in/wison-y-51888887/")

  ;;
  ;; Only for 'emacs-lisp-mode' buffers
  ;;
  (define-abbrev emacs-lisp-mode-abbrev-table "setql" "(setq-local")
  (define-abbrev emacs-lisp-mode-abbrev-table "func" "(defun XXX ()\n\t(interactive)\n\n)")
  (define-abbrev emacs-lisp-mode-abbrev-table "km" "(keymap-set MODE-MAP \"KEY\" ')")
  (define-abbrev emacs-lisp-mode-abbrev-table "when" "(when CONDITION BODY)")

  (define-abbrev emacs-lisp-mode-abbrev-table "stringempty" "(string-empty-p VAR)")
  (define-abbrev emacs-lisp-mode-abbrev-table "stringnotempty" "(not (string-empty-p VAR))")
  (define-abbrev emacs-lisp-mode-abbrev-table "stringmatch" "(string-match-p STRING-TO-CHECK VAR)")
  (define-abbrev emacs-lisp-mode-abbrev-table "stringnotmatch" "(not (string-match-p STRING-TO-CHECK VAR))")

  ;;
  ;; Remove the abbr by setting the 'EXPANSION' to 'nil'!!!
  ;;
  (define-abbrev global-abbrev-table "bg" nil)
  (define-abbrev emacs-lisp-mode-abbrev-table "setql" nil)
#+END_SRC



*** Enable the ~abbrev-mode~ for your buffer

#+BEGIN_SRC emacs-lisp :tangle no
  ;;
  ;; Only enable 'abbrev-mode' for the current buffer, not very useful.
  ;;
  (abbrev-mode)

  ;;
  ;; Use 'hook' to enable 'abbrev-mode', for example:
  ;;
  (add-hook 'prog-mode-hook #'abbrev-mode)
#+END_SRC


*** How to trigger abbrev compleiton

After enabling the ~abbrev-mode~, press ~SPC~ to trigger abbr expansion.



*** How to add an interactive and flexible abbrev like a snippet

Read the doc again:

#+BEGIN_SRC emacs-lisp :tangle no
  (define-abbrev TABLE ABBREV EXPANSION &optional HOOK &rest PROPS)

  If HOOK is non-nil, it should be a function of no arguments, it is called after EXPANSION
  is inserted.

  If EXPANSION is not a string (and not nil), the abbrev is a special one, which does not
  expand in the usual way but only runs HOOK.
#+END_SRC


That said you can do something like this to make that happen:

**** The basic hook tricks

#+BEGIN_SRC emacs-lisp :tangle no
  (defun my-abbr-now ()
      "Abbr expension to now datetime"
  	(insert (current-time-string))
  )

  (defun my-abbr-now-only-date ()
      "Abbr expension to now datetime"
  	(insert (format-time-string "%Y-%m-%d %H:%M:%S"))
  )

  (defun my-abbr-now-only-time ()
      "Abbr expension to now datetime"
  	(insert (format-time-string "%H:%M:%S"))
  )

  ;;
  ;; When typing 'now' and press 'SPC', it runs the hook function
  ;; to 'insert' your custom string into the current pos!!!
  ;;
  (define-abbrev global-abbrev-table "now" "" 'my-abbr-now)
  ;; (define-abbrev global-abbrev-table "now" "" 'my-abbr-now-only-date)
  ;; (define-abbrev global-abbrev-table "now" "" 'my-abbr-now-only-time)
#+END_SRC


**** Interactive abbr

#+BEGIN_SRC emacs-lisp :tangle no
  ;;
  ;; Ask you to provide the 'mode-map', 'key' and the 'function/command' to insert
  ;; this text:
  ;;
  ;; (keymap-set MODE_MAP "KEY" 'FUNCTION) 
  ;;
  (defun my-keymap-set ()
      "Abbr for insert the interactive 'keymap-set'"
  	(interactive)
  	(insert (format
  				"(keymap-set %s \"%s\" '%s)"
  				(read-string "Your mode map: ")
  				(read-string "Your key: ")
  				(read-string "Your function: ")
  			)
  	)
  )

  ;;
  ;; when typing 'mkm' and press 'SPC', expand to nothing (empty "") and run the
  ;; hook function, then you're able insert any complicated text as the final
  ;; expansion:)
  ;;
  (define-abbrev emacs-lisp-mode-abbrev-table "mkm" "" 'my-keymap-set)
#+END_SRC


** How to customize the =minibuffer=

*** The default prompt format

By default, you will see the following minibuffer pops up if you press ~C-x b~:

#+BEGIN_SRC conf
  1/7    Switch to buffer (default *scratch*):
  ,*scratch*                                                     **-  265      Lisp Interaction
  ,*Messages*                                                    %*-  5.5k     Messages
  lisp-quick-tutorial.org                                       ---  45k      Org                    ~/.config/emacs/lisp-quick-tutorial.org
  ,*info*                                                        %%-  2.8k     Info                                  (emacs) Basic Minibuffer
#+END_SRC

That ~(default *scratch*)~ part is set by the ~minibuffer-default-prompt-format~ variable, and its default value is ~" (default %s)"~.

So, you can change it like this:

#+BEGIN_SRC emacs-lisp :tangle no
  (setq minibuffer-default-prompt-format " [ default - %s ]")
#+END_SRC

It becomes:

#+BEGIN_SRC conf
  1/7    Switch to buffer [ default - *scratch* ]:
#+END_SRC


*** The height of the minibuffer

**** Minimal height

#+BEGIN_SRC emacs-lisp :tangle no
  ;;
  ;; The default value,which means let mini-windows grow only; they return to their
  ;; normal size when the minibuffer is closed, or the echo area becomes empty.
  ;;
  (setq resize-mini-windows 'grow-only)

  ;;
  ;; The minibuffer window never changes size automatically.
  ;;
  (setq resize-mini-windows nil)

  ;;
  ;; The minibuffer window will also shrink automatically if you remove some lines
  ;; of text from the minibuffer, down to a minimum of one screen line.
  ;;
  (setq resize-mini-windows t)
#+END_SRC


**** Maximal height

#+BEGIN_SRC emacs-lisp :tangle no
  ;;
  ;; If a float, it means a percentage of current frame window's height.
  ;;
  ;; If an integer, it means the number of lines.
  ;;
  ;; Default is '0.25'
  ;;
  (setq max-mini-window-height 0.25)

#+END_SRC


*** The ~minibuffer-mode~ hook

When active, the minibuffer is usually in ~minibuffer-mode~.  This is an internal Emacs mode without any special features.

If you want to run some commands when the this mode is active, you SHOULD use ~minibuffer-setup-hook~ and ~minibuffer-exit-hook~ rather than the mode hook of this mode!!!


*** Enable fuzzy searching in minibuffer

By default, the ~completion-styles~ default value is: ~(basic partial-completion emacs22)~

With this default value, you have to type =*scra= to search in =Buffers list= and type =lo-them= to search for =load-theme=.

But if you add the ~'flex~ symbol to the list, it will support fuzzy searching. That said, you can type =scra= (without the =*=) and =lothe= with the =-=!!!

#+BEGIN_SRC emacs-lisp :tangle no
  (push 'flex completion-styles)
#+END_SRC

For more detail info, run ~info~ and goto the section:

=Emacs -> Minibuffer -> Completion -> Completion Styles=



** How ~consult-ripgrep~ works

This is source code, super simple:
 
#+BEGIN_SRC emacs-lisp :tangle no
  (defun consult-ripgrep (&optional dir initial)
  	"Search with `rg' for files in DIR with INITIAL input.
  	See `consult-grep' for details."
  	(interactive "P")
  	(consult--grep "Ripgrep" #'consult--ripgrep-make-builder dir initial)
  )
#+END_SRC


*** Here is how it works:

- It calls ~consult--grep~ with the prompt ~"Ripgrep"~ and a =grep= command line build function.

- ~consult--ripgrep-make-builder~ (the command line build function) generates the =Riggrep= commmand line to run. It read from the default ~rg~ command line string from the global var ~consult-ripgrep-args~, which has the following default string value:

  #+BEGIN_SRC fish
    rg --null --line-buffered --color=never --max-columns=1000 --path-separator /   --smart-case --no-heading --with-filename --line-number --search-zip
  #+END_SRC

That causes ~consult--grep~ to use ~rg~ external command instead of the default ~grep~!!!
  

*** Here are something you need to know

**** ~dir~ parameter

It can be any forms of the following:

- ~nil~, which means pick the current ~default-diretory~ I believe

- A directory string, e.g.: ~/home/wison/temp~

- A list of file/directory path, e.g.: 

  #+BEGIN_SRC emacs-lisp :tangle no
    (let (
    		(odin_root (string-trim (getenv "ODIN_ROOT")))
    		(odin_utils_path (expand-file-name "./odin/odin-utils" (getenv "HOME")))
    	)
    	(list odin_root odin_utils_path)
    )
  #+END_SRC


**** The ~input~ string rules

For example, if you type the following input text in the prompt:

#+BEGIN_SRC fish
  Ripgrep (~/.config/emacs): #defun odin-rg-search#v2
#+END_SRC

That means:

- The =defun odin-rg-search= (the string after the first ~#~ and before the second ~#~) will be passed into the ~rg~ external command as regex pattern
- The =v2= (the string starts after the second ~#~) will be used to filter inside the result minibuffer



If you want to pass specific ~rg~ CLI options, you can do that in the format:

#+BEGIN_SRC fish
  Ripgrep (~/.config/emacs): #defun odin-rg-search -- -A2#v2
#+END_SRC

That means:

- The =defun odin-rg-search= (the string after the first ~#~ and before the second ~#~) will be passed into the ~rg~ external command as regex pattern
- The =-A2= (the string starts after the ~--~ ) will be passed as the ~rg~ command options!!!
- The =v2= (the string starts after the second ~#~) will be used to filter inside the result minibuffer




**** Escape the ~space~

By default, ~consult-ripgrep~ use =space= to separate multiple regular expression.

For example:

#+BEGIN_SRC fish
  1/7    Ripgrep (…/../odin-utils, …/../Odin): #^make_dynamic_array ::
#+END_SRC

This means you run ~rg~ with ~-e "^make_dynamic_array" -e ~" :: "~!!!!


If you want your input become a single regular expression, you need to escape the =space= character like this:

#+BEGIN_SRC fish
  1/2    Ripgrep (…/../odin-utils, …/../Odin): #^make_dynamic_array\ ::
#+END_SRC


* My configuration

** Basic settings

*** Use =Super= key as =Meta= (But it works in =GUI= mode only)

#+begin_src emacs-lisp
  ;;
  ;; For MacOS
  ;;
  (if (string-equal "darwin" system-type)
      (progn
  		(setq mac-command-modifier 'meta)
  		(message ">>> MacOS, set 'super' key as 'meta' key." system-type)
  	)
  )

  ;;
  ;; For Linux
  ;;
  (if (string-equal "gnu/linux" system-type)
  	(progn
  		(setq x-super-keysym 'meta)
  		(message ">>> Linux, set 'super' key as 'meta' key." system-type)
  	)
  )
#+end_src


*** Hide all UIs that I don't need

#+BEGIN_SRC emacs-lisp
  (if (fboundp 'menu-bar-mode)
    (menu-bar-mode -1)
  )
  (if (fboundp 'tool-bar-mode)
    (tool-bar-mode -1)
  )
  (if (fboundp 'scroll-bar-mode)
    (scroll-bar-mode -1)
  )

  (setq inhibit-startup-message t
        use-dialog-box nil)
#+END_SRC


*** Use =y-or-n-p= for prompts:

By default, =Emacs= prompts for user confirmation using =yes= or =no=. The following setting changes to use =y= or =n= for shorter and faster responses.

#+begin_src emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+end_src


*** Auto refresh buffer when file has been updated outside Emacs

#+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode 1)
  (setq global-auto-revert-non-file-buffers t)
#+END_SRC


*** No auto backup and auto save

#+BEGIN_SRC emacs-lisp
(setq make-backup-files nil
      auto-save-default nil)
#+END_SRC


*** Disable remember opened file positions

#+BEGIN_SRC emacs-lisp
  ;; Enable it
  ;;(save-place-mode 1)

  ;; Disable it
  (setq save-place-mode nil)
#+END_SRC


*** Line number related

#+BEGIN_SRC emacs-lisp
  (global-display-line-numbers-mode 1)
  (setq display-line-numbers-type 'relative)
  (setq column-number-mode t)
#+END_SRC


*** Enable current line background highlight both in terminal and GUI

#+BEGIN_SRC emacs-lisp
;; (when window-system (global-hl-line-mode t))
(global-hl-line-mode t)
#+END_SRC


*** Customized variable file

By default, =Emacs= writes some custom settings back to =init.el= when you call ~customize~ related functions and then mess up your =init.el= file. For avoiding this, you need to tell =Emacs= where to save those customized settings and re-load that file.

Also, I don't want to see error message when loading that custom file even it has.

#+BEGIN_SRC emacs-lisp
(setq custom-file (locate-user-emacs-file "custom-vars.el"))
(load custom-file 'noerror 'nomessage)
#+END_SRC


*** Dired settings

Show hidden files by default.

#+BEGIN_SRC emacs-lisp
;; (when window-system (global-hl-line-mode t))
(setq dired-listing-switches "-lhta")
#+END_SRC


*** Auto select =help= window

=describe-xxxx= function opens a new help buffer and window, but the help window doesn't be selected by default, it's quite annoying as you need to move to that window before you can close it.

But you can make it auto be selected by the following settings:

#+begin_src emacs-lisp
  (setq help-window-select t)
#+end_src


*** Always display on the right-side window for these buffers: ~Shell, Help, helpful, Emabrk~

#+BEGIN_SRC emacs-lisp
  (setq display-buffer-alist
        '(
           ("\\*helpful"
               (display-buffer-reuse-window display-buffer-in-side-window)
               (side . right)
               (window-width . 0.5)
           )
           ("\\*Help"
               (display-buffer-reuse-window display-buffer-in-side-window)
               (side . right)
               (window-width . 0.5)
           )
           ("\\*Embark"
               (display-buffer-reuse-window display-buffer-in-side-window)
               (side . right)
               (window-width . 0.5)
           )
           ("\\*Shell"
               (display-buffer-reuse-window display-buffer-in-side-window)
               (side . right)
               (window-width . 0.5)
           )
         )
  )
#+END_SRC


*** Fixed =TAB= width

#+BEGIN_SRC emacs-lisp
  (setq tab-width 4)
#+END_SRC


*** Enable auto pair mode

Auto pair =()= and =[]=

#+BEGIN_SRC emacs-lisp
  (electric-pair-mode)
#+END_SRC


*** Disable native compilation warnings and errors

Disable report warnings and errors from asynchronous native compilation.

#+BEGIN_SRC emacs-lisp
  (setq native-comp-async-report-warnings-errors nil)
#+END_SRC



*** Don't use actual image size for inline images and show inline image by default

#+BEGIN_SRC emacs-lisp
  (setq org-image-actual-width nil)
  (setq org-startup-with-inline-images t)
#+END_SRC

After you set ~org-image-actual-width~ to ~nil~, then you're able to use the following attributes to specific the size of any inline images:

#+BEGIN_SRC emacs-lisp :tangle no
  ;;
  ;; Display image with half of the current window size
  ;;
  #+ATTR_HTML: :width 50%
  [[file:~/...your_image_file]]

  ;;
  ;; Display image with exactly pixels width
  ;;
  #+ATTR_HTML: :width 100px
  [[file:~/...your_image_file]]
#+END_SRC

Because you set ~org-startup-with-inline-images~, that's why sometimes the size doesn't work well when opening an org file in a separated window (it still use the full Emacs window width to display the inline image)!!!

The way to fix that is by running ~org-toggle-inline-images~ twice to refresh it.


*** Add extra module load path

Load your custom dynamically loaded module from the given path.

#+BEGIN_SRC emacs-lisp
  ;; Just for debugging purpose:
  ;;
  ;; When developing your dynamically Loaded Module for emacs, you can
  ;; add your library output folder to the 'load-path' for testing.
  ;;
  ;; After adding your testing library folder to 'load-path', then you
  ;; can load it by running:
  ;; 
  ;; (load-library "YOUR_LIB_FILENAME_HERE")
  ;; (CALL_YOUR_MODULE_FUNCTION)
  ;;
  ;; For example:
  ;; (load-library "libemacs-module-demo")
  ;; (get-module-version)
  ;; (get-module-version-string)
  ;;
  (push (expand-file-name "~/zig/emacs-module-template/zig-out/lib") load-path)

  (push "~/.config/emacs/lib" load-path)
#+END_SRC


*** Auto kill previous unfinished async shell command process

When I run =project-async-shell-command=, it actually execute =async-shell-command= and direct its output to the buffer whose name is =*Async Shell Command*=, but somehow somtimes command doesn't exit correct. So, when I try to run another =project-async-shell-command=, it always ask me to choose what action I want to do, as the buffer =*Async Shell Command*= still being using by the previous (unfinished) command, that's quite annoying.

Here is the solution, always kil the previous running process:

#+BEGIN_SRC emacs-lisp
  (setq async-shell-command-buffer 'confirm-kill-process)
#+END_SRC


*** Enable fuzzy searching in minibuffer

Without this, you have to type =*scra= to search in =Buffers= and type =lo-them= to search for =load-theme=. But with this settings, it does fuzzy searching then you can type =scra= (without the =*=) and =lothe= with the =-=!!!

#+BEGIN_SRC emacs-lisp
  (push 'flex completion-styles)
#+END_SRC


** Speed up booting speed by increasing the 'gc-cons-threshold', it should be in ~early-init.el~

The default ~gc-cons-threshold~ setting is ~800000~ (bytes), that causes around ~33~ garbage collections during the booting process.

The following setting improves a lot, reduces only ~1~ garbage collection!!!

You will see the message output from ~after-make-frame-functions~ hook handler and ~emacs-startup-hook~ hook handler in the following section.

#+BEGIN_SRC emacs-lisp :tangle ./early-init.el
  ;;
  ;; Speed up booting speed by increasing the 'gc-cons-threshold'
  ;;
  (message ">>> [ early-init ] default 'gc-cons-threshold': %d" gc-cons-threshold)
  (setq gc-cons-threshold (* 100 1000 1000))
  (message ">>> [ early-init ] increased 'gc-cons-threshold': %d" gc-cons-threshold)
#+END_SRC


** Set fonts and transparent background, it has to be in ~early-init.el~

For some setttings, you have to place them into the =early-init.el=

For example, I need to run some functions to set transparent background via the ~after-make-frame-functions~ hook. If you run ~describe-variable~ on that hook, you should see it says:

=="Note that these functions are usually not run for the initial frame, unless you add them to the hook in your early-init file."=

That's why the following code has to be placed into =early-init.el= instead of =init.el=!!!

#+BEGIN_SRC emacs-lisp :tangle ./early-init.el
  ;; --------------------------------------------------------------------------------------------
  ;; GUI version only, as no effects on the TUI version:
  ;;
  ;; - Remove title bar
  ;; - Increase the internal window gaps
  ;;
  ;; You can find all supported frame attributes from the emacs source code 'frame.el':
  ;;
  ;; For example:
  ;;
  ;; '/usr/local/Cellar/emacs-plus@30/30.1/share/emacs/30.1/lisp/frame.el'
  ;;
  ;; After opening the 'frame.el', search for the 'frame-geometry' function, then see all of them
  ;;
  ;; --------------------------------------------------------------------------------------------
  (progn
  	(add-to-list 'default-frame-alist '(undecorated . t))
  	(add-to-list 'default-frame-alist '(internal-border-width . 20))
  	(message ">>> Applied custom settings to the GUI version: Removed title bar, increase the window gaps.")
  )

  ;; --------------------------------------------------------------------------------------------
  ;; Set font and transparent after creating the frame (window)
  ;; --------------------------------------------------------------------------------------------

  ;;
  ;; Set my font
  ;;
  (defun my-set-font ()
  	(set-face-attribute 'default nil
  		:family "JetBrainsMono Nerd Font"
  		:weight 'semi-bold
  		:height 140
  		;; :italic t
  	)

  	(if (display-graphic-p nil)
  		(progn
  			(let ((font-size-in-pixel 170))
  				(if (and (eql (display-pixel-width) 2560) (eql (display-pixel-height) 1440))
  					(setq font-size-in-pixel 190))
  				(set-face-attribute 'default nil
  					:family "JetBrainsMono Nerd Font"
  					:weight 'semi-bold
  					:height font-size-in-pixel
  					;; :italic t
  					)

  				(message
  					">>> [ my-set-font ] GUI mdoe, font-size-in-pixel: %d"
  					font-size-in-pixel)
  			))
  	)
  )

  ;;
  ;; Set transparent background for GUI
  ;;
  (defun my-set-transparent-gui ()
  	(message ">>> [ early-init > my-set-transparent-gui ] - called")

  	(if (string-equal "darwin" system-type)
  		(progn
  			(set-frame-parameter nil 'alpha 95)
  			(add-to-list 'initial-frame-alist '(alpha . 95))
  			(add-to-list 'default-frame-alist '(alpha . 95))
  		)
  		(progn
  			(set-frame-parameter nil 'alpha-background 95)
  			(add-to-list 'initial-frame-alist '(alpha-background . 95))
  			(add-to-list 'default-frame-alist '(alpha-background . 95))
  		)
  	)
  )

  ;;
  ;; Set transparent background for terminal
  ;;
  (defun my-set-transparent-terminal()
  	(message ">>> [ early-init > my-set-transparent-terminal() ] - called")
  	(set-face-background 'default "unspecified-bg" nil)
  )

  ;;
  ;; Setting the transparent background is very different between GUI mode and Terminal mode, so you
  ;; better do that in the a hook handler (especially after the init window frame has been created
  ;; and the color theme has been loaded)
  ;;
  ;; For detailed steps about =Emacs= startup sequence, read this:
  ;;
  ;; https://www.gnu.org/software/emacs/manual/html_node/elisp/Startup-Summary.html
  ;;
  (defun my-set-transparent-background ()
  	(message
  		">>> [ early-init > my-set-transparent-background ] - display-graphic-p result: %s"
  		(display-graphic-p (selected-frame)))

  	(if (display-graphic-p (selected-frame))
  			(my-set-transparent-gui)
  			(my-set-transparent-terminal)
  	)
  )

  ;;
  ;; Call set font function in both standalone mode or daemon mode
  ;;
  (if (daemonp)
      (add-hook 'after-make-frame-functions
          (lambda (frame)
              (with-selected-frame frame
                (message ">>> [ early-init ] Run lambda funtion in 'after-make-frame-functions' hook.")
                (my-set-font)
                (message ">>> [ early-init ] lambda funtion set font in 'after-make-frame-functions' hook.")
                (message ">>> [ early-init ] Startup took %s seconds with %d garbage collections" (emacs-init-time "%.2f") gcs-done)
              )
          )
      )
      (add-hook 'emacs-startup-hook
          (lambda ()
              (message ">>> [ early-init ] Run lambda funtion in 'emacs-startup-hook' hook.")
              (my-set-font)
              (message ">>> [ early-init ] lambda funtion set font in 'emacs-startup-hook' hook.")
              (message ">>> [ early-init ] Startup took %s seconds with %d garbage collections" (emacs-init-time "%.2f") gcs-done)
          )
      )
  )
#+END_SRC



** Package init and settings

*** Init package and install =use-package=

#+BEGIN_SRC emacs-lisp
  (require 'package)
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)

  ;; Only use to install 'chatgpt'
  ;; (add-to-list 'package-archives '( "jcs-elpa" . "https://jcs-emacs.github.io/jcs-elpa/packages/") t)

  (unless package-archives
          (package-refresh-contents))
  ;;(package-refresh-contents)
  (package-initialize)

  ;;
  ;; (unless condition nil
  ;;         statement-to-execute)
  ;;
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))

  (require 'use-package)

  ;; Auto install all missing packages when using =(use-packge)`
  ;; It's equal to use `:ensure t` in `(use-package)`
  (setq use-package-always-ensure t)
#+END_SRC



*** ~(use-package)~ quick manual

#+begin_src emacs-lisp :tangle no
  ;;
  ;; Load the package, but only if 'PACKAGE_NAME' is available on your system. If not, a
  ;; warning is logged to the '*Messages*' buffer.
  ;;
  ;;
  (use-package 'PACKAGE_NAME
    ;;
    ;; Install if it doesn't exists, and because of '(setq use-package-always-ensure t)'
    ;; has been set already, that said ':ensure t' will be applied to all '(use-package)',
    ;; that's why you don't need to set ':ensure t' anymore.
    ;;
    :ensure t

    ;; 
    ;; Lazy load this package
    ;; Using 'bind' and 'command' will cause the package to lazy load as well!!!
    ;;
    ;; The keywords ':commands,' et al, provide "triggers" that cause a package to
    ;; be loaded when certain events occur. However, if 'use-package' cannot determine
    ;; that any trigger has been declared, it will load the package immediately (when
    ;; Emacs is starting up) unless :defer t is given. The presence of triggers can be
    ;; overridden using ':demand t' to force immediately loading anyway.
    ;; For example, :hook represents a trigger that fires when the specified hook is run.
    ;; 
    ;; In almost all cases you don't need to manually specify ':defer t', because this is
    ;; implied whenever ':bind' or ':mode' or ':interpreter' are used. Typically, you only
    ;; need to specify ':defer' if you know for a fact that some other package will do
    ;; something to cause your package to load at the appropriate time, and thus you would
    ;;  like to defer loading even though 'use-package' has not created any autoloads for you.
    ;;
    :defer t

    ;; 
    ;; Use the ':init' keyword to execute code before a package is loaded. It accepts one
    ;; or more forms, up to the next keyword:
    ;;
    :init
        ;;
        ;; All settings belong to ':init' part
        ;;
        (setq YOUR_VARS t)

    ;; 
    ;; Use the ':config' keyword to execute code after a package is loaded. In cases where
    ;; loading is done lazily (see more about autoloading below), this execution is deferred
    ;; until after the autoload occurs
    :config
        ;;
        ;; All settings belong to ':config part
        ;;
        (your-mode t)

    ;; 
    ;; Load this package after another package
    ;;
    :after ANOTHER_PACKAGE_NAME

    ;; 
    ;; Run the commands when the package is actually loaded.
    ;; The ':commands' keyword takes either a symbol or a list of symbols.
    ;;
    :commands SINGLE_COMMAND
    :commands (COMMAND_1 COMMAND_2 COMMAND_3 etc)

    ;; 
    ;; Keybindings
    ;;
    :bind (("M-o l" . COMMAND_TO_BIND)
           ("M-o r" . COMMAND_TO_BIND)
           ("M-o w" . COMMAND_TO_BIND)))

    ;; 
    ;; The ':hook' keyword allows adding functions onto package hooks. The same
    ;; effect with using '(add-hook)'. The following ':hook' setting is the same:
    ;;
    ;; :init
    ;; (add-hook 'prog-mode-hook #'company-mode))
    ;;
    :hook (prog-mode . company-mode))

    ;; 
    ;; The ':custom' keyword allows customization of package custom variables.
    ;; Same thing with using '(setq NAME VALUE)' in ':init' but with comments.
    ;; The documentation string is not mandatory.
    ;;
    ;; NOTE: these are only for people who wish to keep customizations with their
    ;;       accompanying use-package declarations. Functionally, the only benefit
    ;;       over using setq in a :config block is that customizations might execute
    ;;       code when values are assigned.
    ;; 
    ;; NOTE: The customized values are not saved in the Emacs custom-file. Thus you
    ;;       should either use the :custom option or you should use M-x customize-option
    ;;       which will save customized values in the Emacs custom-file. Do not use both.
    ;;
    :custom
        (comint-buffer-maximum-size 20000 "Increase comint buffer size.")
        (comint-prompt-read-only t "Make the prompt read only."))
    ;;
    ;; The ':disabled' keyword can turn off a module you're having difficulties with, or
    ;; stop loading something you're not using at the present time:
    ;;
    :disabled

    ;;
    ;; Print out the error if you want
    ;;
    :catch (lambda (keyword err)
            (message ">>> Package load failed with error: %s" (error-message-string err)))

  )
#+end_src


** Enable system clipboard

 #+begin_src emacs-lisp
   (use-package xclip
      :config
          (xclip-mode 1)
   )
 #+end_src


** Command log  

#+BEGIN_SRC emacs-lisp
  (use-package command-log-mode
      :defer t
      :config
          (global-command-log-mode 1)
  )
#+END_SRC


** Better help buffer

=Helpful= is a replacement for *help* buffers that provides much more contextual information.

#+BEGIN_SRC emacs-lisp
  (use-package helpful
      :defer t
      ;; ;;
      ;; ;; 'counsel' related configuration
      ;; ;;
      ;; :init
      ;;     (setq counsel-describe-function-function #'helpful-callable)
      ;;     (setq counsel-describe-variable-function #'helpful-variable)
      ;;     :bind
      ;;     ([remap describe-function] . counsel-describe-function)
      ;;     ([remap describe-variable] . counsel-describe-variable)
      ;;     ([remap describe-command] . helpful-command)
      ;;     ([remap describe-key] . helpful-key)
  )
#+END_SRC

Here is what =Helpful= improved, it shows you the help information with the following patterns:


=Signature=
(describe-function FUNCTION)

=Documentation=
Display the full documentation of FUNCTION (a symbol).
......

=View in manual= (Click here will bring you to the detail function document)

=Key Bindings=
.....

=References=
......

=Debugging=
......

=Source Code=
......



** Edit/UX improve related

*** =Olivetti=: works like =Goyo= in =Neovim=

#+BEGIN_SRC emacs-lisp
  (use-package olivetti
    :defer t
    :init
        (setq olivetti-body-width 0.6)
  )
#+END_SRC


*** =which-key=: Display keybinding in group

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :defer t
    :init
        (which-key-setup-side-window-right-bottom)
        (setq which-key-idle-delay 0.2)
        ;; (setq which-key-sort-order 'which-key-local-then-key-order)
        (setq which-key-sort-order 'which-key-prefix-then-key-order)
        (setq which-key-prefix-prefix "> " )
    :config
        (which-key-mode)
  )
#+END_SRC


*** =Highlight indent=

#+begin_src emacs-lisp
  (use-package highlight-indent-guides
  	:disabled
  	:defer t
  	:hook (prog-mode . highlight-indent-guides-mode)
  	:config
  		(setq highlight-indent-guides-method 'character)
  		;; (setq highlight-indent-guides-method 'bitmap)
  		;; (setq highlight-indent-guides-method 'column)
  		(setq highlight-indent-guides-character ?\|)
  		;;(setq highlight-indent-guides-responsive 'top)
  )
#+end_src


*** =Vertico= completion

=Vertico= is new and lightweight completion UI based on the default completion system, it uses all =Emacs= builtin functionalities, no need to add something new (heavery) on top like =Ivy=.

 #+begin_src emacs-lisp
   (use-package vertico
     :init
        (vertico-mode)
        (vertico-multiform-mode)

        ;;
        ;; Configure Vertico modes per command or completion category.
        ;;
        ;; 'buffer' means 'vertico-buffer-mode' to display vertico in a buffer instead of minibuffer
        ;;
        ;; For more details, watch this video: https://www.youtube.com/watch?v=hPwDbx--Waw
        ;;
        (setq vertico-multiform-commands
            '((consult-imenu buffer)
              (consult-ripgrep buffer)
              (odin-rg-search-v2 buffer) ;; This is important !!!
             )
        )

        ;; How many lines needs to show in minibuffer before hit the top or bottom
        (setq vertico-scroll-margin 3)

        ;; Show more lines in minibuffer
        (setq vertico-count 20)

        ;; Grow and shrink the Vertico minibuffer
        ;; (setq vertico-resize t)

        ;; Optionally enable cycling for `vertico-next' and `vertico-previous'.
        (setq vertico-cycle t)

     :config

        ;;
        ;; Auto tidy up the directory prompt when changing to '~' or '/' directory
        ;; This works with 'file-name-shadow-mode' enabled. When you're in the sub directory, and you
        ;; type '~' or '/' path in 'find-file' or 'dired', then 'vertico' clear the old path and keep
        ;; the curent path.
        ;;
        (add-hook 'rfn-eshadow-update-overlay-hook #'vertico-directory-tidy)
   )

   (use-package savehist
    :init
        (savehist-mode)
   )
 #+end_src


*** Vertico Extensions

***** Marginalia

Rich annotations in the minibuffer

#+begin_src emacs-lisp
  (use-package marginalia
    ;; Bind `marginalia-cycle' locally in the minibuffer.  To make the binding
    ;; available in the *Completions* buffer, add it to the
    ;; `completion-list-mode-map'.
    :bind (:map minibuffer-local-map
           ("M-A" . marginalia-cycle))
    :init
       ;; Marginalia must be activated in the :init section of use-package such that
       ;; the mode gets enabled right away. Note that this forces loading the
       ;; package.
       (marginalia-mode)
  )
#+end_src


***** Consult

Useful search and navigation commands, here is the best video to explain how it works:
https://www.youtube.com/watch?v=HwBHBwYgs2g

#+begin_src emacs-lisp
  ;; Enable rich annotations using the Marginalia package
  (use-package consult
    :after vertico
  )
#+end_src


Here are the useful commands:

| Function         | Description                                                 |
|------------------+-------------------------------------------------------------|
| ~consult-imenu~    | The enhanced ~imenu~                                          |
| ~consult-yank-pop~ | List all yanked content, press =RET= to replace at point.     |
| ~consult-ripgrep~  | Run ~ripgrep~ and preview                                     |
| ~consult-line~     | Better search like ~/~ or ~*~ but with preview                  |
| ~consult-theme~    | Choose theme with live preview                              |
| ~consult-man~      | Search for man page, result in buffer with syntax highlight |
|                  |                                                             |


I prefer to disable the grouping feature in ~consult-ripgrep~ buffer:

#+BEGIN_SRC emacs-lisp
 (consult-customize consult-ripgrep :group nil)
#+END_SRC

But this doesn't work if you call ~consult-ripgrep~ programmatically!!!

That's why I copied the ~consult-ripgrep~ and ~consult--grep~ source to make my own version by adding the ~:group nil~ !!!


***** vertico-posframe

=vertico-posframe= is an =vertico= extension, which lets =vertico= use posframe to show its candidate menu.

NOTE: =vertico-posframe= requires Emacs 26 and do not support mouse click.

#+begin_src emacs-lisp
  ;;
  ;; Only enabled in GUI mode!!!
  ;;
  (if (display-graphic-p nil)
    (use-package vertico-posframe
        :after vertico
        :init
            ;;
            ;; The following setting is saying:
            ;;
            ;; All rest 'vertico-multiform-commands' use default popup
            ;; except the 'consult-imenu' and 'consult-ripgrep' (use 'vertico-buffer-mode')
            ;;
            (setq vertico-multiform-commands
                '(
                   (consult-imenu buffer)     ; Uses 'vertico-buffer-mode'
                   (consult-ripgrep buffer)   ; Uses 'vertico-buffer-mode'

                   ;;
                   ;; Use popup as default
                   ;;
                   (t posframe
                       (vertico-posframe-poshandler . posframe-poshandler-frame-center)
                       (vertico-posframe-border-width . 2)
                   )
                 )
            )

            ;; The popup position specified by the 'vertico-posframe-poshandler' and the
            ;; default value is 'posframe-poshandler-frame-center'.
            ;;
            ;; You can change it on your own, the value defined in:
            ;; '~/.config/emacs/elpa/posframe-20230714.227/posframe.el'
            ;;
            ;; The builtin poshandler functions are listed below:
            ;;
            ;; posframe-poshandler-frame-center
            ;; posframe-poshandler-frame-top-center
            ;; posframe-poshandler-frame-top-left-corner
            ;; posframe-poshandler-frame-top-right-corner
            ;; posframe-poshandler-frame-top-left-or-right-other-corner
            ;; posframe-poshandler-frame-bottom-center
            ;; posframe-poshandler-frame-bottom-left-corner
            ;; posframe-poshandler-frame-bottom-right-corner
            ;; posframe-poshandler-window-center
            ;; posframe-poshandler-window-top-center
            ;; posframe-poshandler-window-top-left-corner
            ;; posframe-poshandler-window-top-right-corner
            ;; posframe-poshandler-window-bottom-center
            ;; posframe-poshandler-window-bottom-left-corner
            ;; posframe-poshandler-window-bottom-right-corner
            ;; posframe-poshandler-point-top-left-corner
            ;; posframe-poshandler-point-bottom-left-corner
            ;; posframe-poshandler-point-bottom-left-corner-upward
            ;; posframe-poshandler-point-window-center
            ;; posframe-poshandler-point-frame-center
            ;;
            ;; (setq vertico-posframe-poshandler 'posframe-poshandler-frame-center)

            ;;
            ;; Control popup left and right paddings
            ;;
            (setq vertico-posframe-parameters
                '((left-fringe . 10)
                  (right-fringe . 10)
                 )
            )

        :config
            (vertico-multiform-mode 1)

            ;;
            ;; When enabling 'vertico-multiform-mode', 'vertico-posframe-mode' will be
            ;; activated/deactivated by 'vertico-multiform-mode' dynamically when you
            ;; add ‘posframe’ setting to 'vertico-multiform-commands,' please do not
            ;; enable 'vertico-posframe-mode' globally at the moment!!!
            ;;
            ;; (vertico-posframe-mode 1)
    )
  )
#+end_src



***** Embark

=Embark= allows you to do something (aka, run an action) on the following targets:

- A single item or all items inside the completion list/Minibuffer/imenu result/rg result/etc
- Selection of text

For example:

If you run ~describe-function~, then a mini buffer pops up to allow you to filter the function you want to see the help for. Because that's mini buffer, you can't copy it if you want:)

But if you have =Embark=, then you can bind a hotkey to run ~embark-act~ to popup a embark action list like this:

#+BEGIN_SRC emacs-lisp :tangle no
  Act on symbol ‘execute-extended-command--shorter-1’

  RET   helpful-callable      Show help for function, macro or special form named SYMBOL.
  ;; ignore...
  A     embark-act-all        Prompt the user for an action and perform it on each candidate.
  S     embark-collect        Create an Embark Collect buffer.
  w     embark-copy-as-kill   Join STRINGS and save on the ‘kill-ring’.
  i     embark-insert         Join STRINGS and insert the result at point.
  ;; ignore...
#+END_SRC

So, you can press the following key to do something very useful:

- ~A,w~: Copy all the function names.
- ~w~: Only copy the selected funciton name.
- ~i~: Only copy the selected funciton name and paste it to the current buffer at cursor position.
- ~S~: Take all function names to create a =Embark collect buffer=, so you can move up and down and press =RET= to view the function help info in a super convenient way. (as you don't need to re-run the ~describe-function~ to filter and select the function again).


****** Work with =which-key= 

Be able to show keybindings via =which-key=

#+BEGIN_SRC emacs-lisp
  (defun embark-which-key-indicator ()
    "An embark indicator that displays keymaps using which-key.
  The which-key help message will show the type and value of the
  current target followed by an ellipsis if there are further
  targets."
    (lambda (&optional keymap targets prefix)
      (if (null keymap)
          (which-key--hide-popup-ignore-command)
        (which-key--show-keymap
         (if (eq (plist-get (car targets) :type) 'embark-become)
             "Become"
           (format "Act on %s '%s'%s"
                   (plist-get (car targets) :type)
                   (embark--truncate-target (plist-get (car targets) :target))
                   (if (cdr targets) "…" "")))
         (if prefix
             (pcase (lookup-key keymap prefix 'accept-default)
               ((and (pred keymapp) km) km)
               (_ (key-binding prefix 'accept-default)))
           keymap)
         nil nil t (lambda (binding)
                     (not (string-suffix-p "-argument" (cdr binding))))))))
#+END_SRC


****** Install and configure

#+BEGIN_SRC emacs-lisp
  (use-package embark
    :init
      ;; Optionally replace the key help with a completing-read interface
      (setq prefix-help-command #'embark-prefix-help-command)

      ;;
      ;; Work with 'which-key', 'embark-which-key-indicator' must defined!!!
      ;;
      ;; (setq embark-indicators '(embark-which-key-indicator
      ;;                           embark-highlight-indicator
      ;;                           embark-isearch-highlight-indicator)
      ;; )

    :config
      ;;
      ;; Hide the mode line of the Embark live/completions buffers
      ;;
      ;; (add-to-list 'display-buffer-alist
      ;; 						'("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
      ;; 						nil
      ;; 						(window-parameters (mode-line-format . none))))
  )

  ;;
  ;; Consult users will also want the embark-consult package.
  ;;
  (use-package embark-consult
    :hook
        (embark-collect-mode . consult-preview-at-point-mode))
#+END_SRC




****** Disable line number mode

#+BEGIN_SRC emacs-lisp
  (defun embark-disable-line-number ()
  	(display-line-numbers-mode -1)
  )

  (add-hook 'embark-collect-mode-hook #'embark-disable-line-number)
#+END_SRC


*** =evil-mode= and =evil-surround=

**** What is =Evil=

=Evil= is an extensible =vi= layer for =Emacs=. It emulates the main features of =Vim=, turning =Emacs= into a modal editor. Like =Emacs= in general, =Evil= is extensible in =Emacs Lisp=.


**** Evil =modes= and =state=

=Evil= uses the term =state= for what is called a =mode= in regular =vi= usage, because modes are understood in =Emacs= terms to mean something else.

=Evil= defines a number of states by default:

| state                        | description                                                                        |
|------------------------------+------------------------------------------------------------------------------------|
| normal state (<N>)           |                                                                                    |
| insert state (<I>)           |                                                                                    |
| visual state (<V>)           |                                                                                    |
| replace state (<R>)          |                                                                                    |
| operator-pending state (<O>) | A special state entered after launching an operator, but before specifying the     |
|                              | corresponding motion or text object.                                               |
|                              |                                                                                    |
| motion state (<M>)           | A special state useful for buffers that are read-only, where motions are available |
|                              | but editing operations are not.                                                    |
|                              |                                                                                    |
| Emacs state (<E>)            | All =Evil= keybindings are disabled, switch back to original =Emacs= keybindings.      |
|                              |                                                                                    |


By default, toggle between =Evil state= and =Emacs sate= by pressing ~C-z~, but I disabled it (as I need the ~C-z~ to go back to terminal). So I if you need that, you can run ~evil-emacs-state~ and ~evil-normal-state~ manually.

Why you need the =Emacs state=??? For example, if =Evil= keybinding overwrites the original =Emacs= hotkey, then you need to disable it temporary by going back to =Emacs state=.


**** Evil settings

Important keybindings when using =Evil=:

- =:q= uses to quit the entire =Emacs= client (connection), completely different with =Vim=!!! The function name is  =evil-quit=.

- =:bd= uses to close the current buffer, use this instead of =:q=. The function name is  =kill-current-buffer=.

- =Q= binds to =evil-window-delete= which ONLY used to close the splitted window (but NOT close the related buffer).


#+BEGIN_SRC emacs-lisp
  ;;
  ;; Evil custom settings, you can found all settings here:
  ;; https://evil.readthedocs.io/en/latest/settings.html
  ;;

  ;;
  ;; Set the following modes to 'normal state after 'evil-mode' loaded
  ;;
  ;; Why do this?
  ;; 
  ;; If the buffer switches to 'Evil-Normal-State' by default, then the upcomming
  ;; keybindins "(evil-global-set-key 'normal)" which targets to 'normal' state will
  ;; work automatically.
  ;; 
  ;; That will save a lot of keybinding settings.
  ;;
  ;; More info, run 'info' and goto the section: evil -> evil -> settings -> The initial state
  ;;
  (defun my-evil-default-to-normal-state-for-these-modes ()
  	(dolist (mode '(
  				helpful-mode
  				help-mode
  				messages-buffer-mode
  				emacs-lisp-compilation-mode
  				debugger-mode
  				package-menu-mode
  				term-mode
  				custom-mode
  				org-mode
  				org-agenda-mode
  				fundamental-mode
  				shell-command-mode
  				snippet-mode
  			))

  		;;
  		;; I have no idea why this doesn't for the 'messages-buffer-mode' (only this mode)!!!
  		;;
  	    (evil-set-initial-state mode 'normal)

  		(message ">>> Evil set inital state to 'normal' for '%s'" mode)

  	)
  )

  ;;
  ;; By default, `evil-repeat` repeats the last command when pressing `.` key. If you DO NOT
  ;; want some commands to be repeatable, then you should use `evil-declare-abort-repeat`
  ;; to disable them.
  ;;
  ;; Here is the default disabled settings:
  ;;
  ;; File: ~/.config/emacs/elpa/evil-20230828.1342/evil-integration.el
  ;; (mapc #'evil-declare-abort-repeat
  ;;       '(balance-windows
  ;;         eval-expression
  ;;         execute-extended-command
  ;;         exit-minibuffer
  ;;         compile
  ;;         delete-window
  ;;         delete-other-windows
  ;;         find-file-at-point
  ;;         ffap-other-window
  ;;         recompile
  ;;         redo
  ;;         save-buffer
  ;;         split-window
  ;;         split-window-horizontally
  ;;         split-window-vertically
  ;;         undo
  ;;         undo-tree-redo
  ;;         undo-tree-undo))
  (defun my-evil-disable-repeatable-for-these-functions ()
  	;;
  	;; I don't want the following commands to be repeatable!!!
  	;;
  	(mapc #'evil-declare-abort-repeat
  	      '(my-search-next            ; 'n' for next search
  	        my-search-previous        ; 'N' for prev search
  	        flymake-goto-next-error   ; '<C-n>' for next LSP error
  	        flymake-goto-prev-error   ; '<C-p>' for prev LSP error
  	       )
  	)
  )

  ;;
  ;;
  ;;
  (use-package evil
  	:init
  	(setq
  		evil-auto-indent t          ; Enable auto indent
  		evil-echo-state t           ; State/mode in status bar
  		evil-want-C-u-scroll t      ; Enable <C-u> scroll up
  		evil-want-C-i-jump t        ; <C-i> inserts a tab character
  		evil-want-Y-yank-to-eol t   ; Enable `Y`: Yank to end of line
  		evil-vsplit-window-right t  ; Always vsplit window on the rigth
  		evil-want-integration t     ; This is optional since it's already set to t by default.
  		evil-want-keybinding nil
  	)

  	:custom
  	(evil-undo-system 'undo-redo)

  	:config
  	(evil-mode 1)

  	;; Leader key
  	(evil-set-leader '(normal visual) (kbd "SPC"))
  	(my-evil-disable-repeatable-for-these-functions)
  )

  ;;
  ;; 'my-evil-default-to-normal-state-for-these-modes' has to be called when all 'xxx-mode'
  ;; are avaiable. Otherwise, it won't be called for some modes!!!
  ;;
  ;; That's why you should call this function for the 'after-init-hook', as all 'xxx-mode'
  ;; should be ready after the frame has been inited.
  ;;
  (add-hook
  	'after-init-hook
  	(lambda ()
  		(my-evil-default-to-normal-state-for-these-modes)
  		(message ">>> 'my-evil-default-to-normal-state-for-these-modes' has been called by 'after-init-hook'")
  	)
  )

  ;;
  ;; 
  ;;
  (use-package evil-collection
  	:after evil
  	:config
  		(evil-collection-init)
  )
#+END_SRC


**** Evil-surrond settings

#+begin_src emacs-lisp
  (use-package evil-surround
      :init
      (global-evil-surround-mode 1)
      :config
          (add-hook 'org-mode-hook (lambda ()
                                      (push '(?= . ("=" . "=")) evil-surround-pairs-alist)))
  )
#+end_src


**** Evil-goggles settings 

=evil-goggles-mode= displays a visual hint when editing with =evil=.

#+BEGIN_SRC emacs-lisp
  (use-package evil-goggles
    :ensure t
    :init
       ;;
       ;; Only enalbe yank effect, 't' by default
       ;;
       ;; (setq evil-goggles-enable-yank t)

       ;;
       ;; Disable the following effects
       ;;
       (setq evil-goggles-enable-delete nil
             evil-goggles-enable-change nil
             evil-goggles-enable-indent nil
             evil-goggles-enable-join nil
             evil-goggles-enable-fill-and-move nil
             evil-goggles-enable-paste nil
             evil-goggles-enable-shift nil
             evil-goggles-enable-surround nil
             evil-goggles-enable-commentary nil
             evil-goggles-enable-nerd-commenter nil
             evil-goggles-enable-replace-with-register nil
             evil-goggles-enable-set-marker nil
             evil-goggles-enable-undo nil
             evil-goggles-enable-redo nil
             evil-goggles-enable-record-macro nil)
    :config
    (evil-goggles-mode)

    ;; optionally use diff-mode's faces; as a result, deleted text
    ;; will be highlighed with `diff-removed` face which is typically
    ;; some red color (as defined by the color theme)
    ;; other faces such as `diff-added` will be used for other actions
    (evil-goggles-use-diff-faces))
#+END_SRC


*** =Org= mode settings

**** Org mode edit src in current window

When pressing =C-c '= inside the code block, which way I prefer to open the src editing window: ~current-window~

#+BEGIN_SRC emacs-lisp
  (setq org-src-window-setup 'current-window)
  ;; (setq org-src-window-setup 'split-window-rIght)
#+END_SRC

Inside the src editing window, press =C-c '= again to accept change and exit; press ~C-c C-k~ to abort and exit.


**** Heading font and =org-bullets= settings

#+BEGIN_SRC emacs-lisp
  (defun my/org-mode-setup ()
  	(interactive)
  	(org-indent-mode)           ;; Enable org indent mode
  	(variable-pitch-mode -1)
  	(visual-line-mode 1)

  	;;
  	;; Heading font size (only works in GUI mode)
  	;; 
  	;; But the following settings only work in 'GUI' mode, nothing will happen in 'Terminal' mode!!!
  	;;
  	(dolist (face '((org-level-1 . 1.5)
  					(org-level-2 . 1.3)
  					(org-level-3 . 1.2)
  					(org-level-4 . 1.1)
  					(org-level-5 . 1.0)
  					(org-level-6 . 1.0)
  					(org-level-7 . 1.0)))
  		(set-face-attribute (car face) nil
  							:height (cdr face))
  	)
  	(message ">>> [ my/org-mode-setup ] - called")
  )

  (use-package org
  	:hook (org-mode . my/org-mode-setup)
  	:config
  	(setq org-ellipsis " ..."			; Ellipsis string when `S-TAB`
  		org-hide-emphasis-markers t		; Hide the marker (bold, link etc)
  		))

  (use-package org-bullets
  	:after org
  	:init
  		;; (setq org-bullets-bullet-list '("" "" ">" "●" "◆" "*"))
  		;; (setq org-bullets-bullet-list '("①" "②" "③" "④" "⑤" "⑥"))
  		(setq org-bullets-bullet-list '("➊" "➋" "➌" "➍" "➎" "➏"))
  	:hook (org-mode . org-bullets-mode)
  )
#+END_SRC



**** Disable line number mode


#+BEGIN_SRC emacs-lisp
  (defun disable-line-number ()
  	(display-line-numbers-mode -1)
  )

  (add-hook 'org-mode-hook #'disable-line-number)
#+END_SRC


**** =org-auto-tangle=

#+BEGIN_SRC emacs-lisp
  (use-package org-auto-tangle
    :defer t
    :hook (org-mode . org-auto-tangle-mode))
#+END_SRC


*** =Org agenda= mode settigns

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files
  	'(
  		 "~/.config/emacs/todo.org"
  	)
  )
#+END_SRC


** Better search

*** =ripgrep=

#+BEGIN_SRC emacs-lisp
  (use-package rg
    :config
         (setq rg-command-line-flags (list "--trim"))
         (setq rg-group-result nil) ;; "--no-heading"
  )
#+END_SRC


** Treesitter

*** Install language grammar libraries

Before you can have ~xxx-ts-mode~ (~xxx~ is the language name), you need to walk through the following steps:

**** 1. Set the ~treesit-language-source-alist~ with all langauges you needed:

If you don't set this, you can't run the batch command to install all of them in one-shot (as it will ask you the confirm git URL).

If you can't find the language gammar in =https://github.com/tree-sitter/tree-sitter-xxx=, then take a look at the Neovim treesitter README, it includes some third-party implementations:

=~/.local/share/nvim/site/pack/packer/start/nvim-treesitter/README.md=

#+begin_src emacs-lisp
  (setq treesit-language-source-alist
    '((c "https://github.com/tree-sitter/tree-sitter-c")
      (cpp "https://github.com/tree-sitter/tree-sitter-cpp")
      (zig "https://github.com/maxxnino/tree-sitter-zig")
      (rust "https://github.com/tree-sitter/tree-sitter-rust")
      (bash "https://github.com/tree-sitter/tree-sitter-bash")
      (cmake "https://github.com/uyha/tree-sitter-cmake")
      (css "https://github.com/tree-sitter/tree-sitter-css")
      (elisp "https://github.com/Wilfred/tree-sitter-elisp")
      (go "https://github.com/tree-sitter/tree-sitter-go")
      (html "https://github.com/tree-sitter/tree-sitter-html")
      (javascript "https://github.com/tree-sitter/tree-sitter-javascript" "master" "src")
      (json "https://github.com/tree-sitter/tree-sitter-json")
      (make "https://github.com/alemuller/tree-sitter-make")
      (markdown "https://github.com/ikatyang/tree-sitter-markdown")
      (python "https://github.com/tree-sitter/tree-sitter-python")
      (toml "https://github.com/tree-sitter/tree-sitter-toml")
      (tsx "https://github.com/tree-sitter/tree-sitter-typescript" "master" "tsx/src")
      (typescript "https://github.com/tree-sitter/tree-sitter-typescript" "master" "typescript/src")
      (yaml "https://github.com/ikatyang/tree-sitter-yaml")
      (fish "https://github.com/ram02z/tree-sitter-fish")
      (java "https://github.com/tree-sitter/tree-sitter-java")
      (hare "https://git.sr.ht/~ecs/tree-sitter-hare")
      (odin "https://github.com/amaanq/tree-sitter-odin")
      (lua "https://github.com/MunifTanjim/tree-sitter-lua")
      ;(hare "https://git.sr.ht/~rockorager/tree-sitter-hare")
      ;(hare "https://git.sr.ht/~ghishadow/tree-sitter-hare")
      ;(hare "https://github.com/amaanq/tree-sitter-hare")
     )
    )

  ;;
  ;; Change the default major mode
  ;;
  (add-to-list 'auto-mode-alist '("\\.toml\\'" . toml-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.rs\\'" . rust-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.c\\'" . c-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.h\\'" . c-or-c++-ts-mode))
  (add-to-list 'auto-mode-alist '("CMakeLists.txt" . cmake-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
  (add-to-list 'auto-mode-alist '("\\.fish\\'" . fish-mode))
  (add-to-list 'auto-mode-alist '("lfrc" . bash-mode))
  (add-to-list 'auto-mode-alist '("bspwmrc" . bash-mode))
  (add-to-list 'auto-mode-alist '("\\.clang-format\\'" . bash-mode))
  (add-to-list 'auto-mode-alist '("\\.json\\'" . json-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.js\\'" . js-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.ts\\'" . typescript-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.java\\'" . java-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.ha\\'" . hare-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.odin\\'" . odin-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.lua\\'" . lua-ts-mode))

  ;;
  ;; remap the non-treesitter mode to treesitter mode
  ;;
  (setq major-mode-remap-alist
   '((c-mode . c-ts-mode)
     (c++-mode . c++-ts-mode)
     (bash-mode . bash-ts-mode)
     (sh-mode . bash-ts-mode)
     (cmake-mode . cmake-ts-mode)
     (css-mode . css-ts-mode)
     (elisp-mode . elisp-ts-mode)
     (go-mode . go-ts-mode)
     (html-mode . html-ts-mode)
     (make-mode . make-ts-mode)
     (json-mode . json-ts-mode)
     (js-json-mode . json-ts-mode)
     (python-mode . python-ts-mode)
     (tsx-mode . tsx-ts-mode)
     (typescript-mode . typescript-ts-mode)
     (js-mode . js-ts-mode)
     (yaml-mode . yaml-ts-mode)
     (java-mode . java-ts-mode)
     (hare-mode . hare-ts-mode)
     (odin-mode . odin-ts-mode)
    )
  )
#+end_src


**** 2. Install all of them

You can either ~M-x~ then ~treesit-install-language-grammar~ to install one-by-one, or you can run the following batch command to install all of them in one-shot:

#+begin_src emacs-lisp :tangle no
  ;; (mapc #'treesit-install-language-grammar (mapcar #'car treesit-language-source-alist))
#+end_src


They should be installed to your =~/.config/emacs/tree-sitter= folder like this:

#+begin_src bash
  ls -lht tree-sitter/

  # total 9.5M
  # 230K  libtree-sitter-yaml.so*
  # 1.2M  libtree-sitter-typescript.so*
  # 1.2M  libtree-sitter-tsx.so*
  #  40K  libtree-sitter-toml.so*
  # 529K  libtree-sitter-python.so*
  # 825K  libtree-sitter-markdown.so*
  # 168K  libtree-sitter-make.so*
  #  16K  libtree-sitter-json.so*
  # 353K  libtree-sitter-javascript.so*
  #  38K  libtree-sitter-html.so*
  # 300K  libtree-sitter-go.so*
  #  60K  libtree-sitter-elisp.so*
  #  76K  libtree-sitter-css.so*
  # 100K  libtree-sitter-cmake.so*
  # 638K  libtree-sitter-bash.so*
  # 3.2M  libtree-sitter-cpp.so*
  # 668K  libtree-sitter-c.so*
  # 812K  libtree-sitter-zig.so*
  # 829K  libtree-sitter-rust.so*
#+end_src


You can check each of them to see whether has been install successfully or not:

#+begin_src emacs-lisp :tangle no
  ;;
  ;; Return 't' means install successfully
  ;;
  (treesit-language-available-p 'c)
  (treesit-language-available-p 'cpp)
  (treesit-language-available-p 'zig)
  (treesit-language-available-p 'rust)
  (treesit-language-available-p 'bash)
  (treesit-language-available-p 'cmake)
  (treesit-language-available-p 'css)
  (treesit-language-available-p 'elisp)
  (treesit-language-available-p 'go)
  (treesit-language-available-p 'html)
  (treesit-language-available-p 'javascript)
  (treesit-language-available-p 'json)
  (treesit-language-available-p 'make)
  (treesit-language-available-p 'markdown)
  (treesit-language-available-p 'python)
  (treesit-language-available-p 'toml)
  (treesit-language-available-p 'tsx)
  (treesit-language-available-p 'typescript)
  (treesit-language-available-p 'yaml)
  (treesit-language-available-p 'fish)
  (treesit-language-available-p 'hare)
#+end_src



** Note taking

*** =denote=

#+BEGIN_SRC emacs-lisp
  (use-package denote
    :init
        ;;
        ;; Where your denotes save to
        ;;
        (setq denote-directory(expand-file-name "~/my-notes"))

        ;;
        ;; Your denote default file type, 'nil' means use 'org' file
        ;;
        ;; Value is one of these options: nil/markdown-yaml/markdown-toml/text
        ;;
        (setq denote-file-type nil)

        ;;
        ;; Default keyword list, this is the fixed value list.
        ;;
        ;; By default, the 'denote-infer-keywords' is set to 't', that said denote
        ;; tries to walk through the 'denote-directory' to extract all keywords from
        ;; the filename and add to the list. If you don't want this behavior then
        ;; set it to 'nil'.
        ;;
        (setq denote-known-keywords '("Zig" "C"  "Todo" "ProblemAndSolution" "Misc"))

        ;;
        ;; What steps do I want to in the prompt?
        ;;
        ;; 1. Ask me the 'title' of the note
        ;;
        ;; 2. Ask me the 'keywords' of the note, multiple keywords separated by ','
        ;;
        ;; 3. Ask me the 'sub directory' of the note (related to 'denote-directory')
        ;;
        ;;
        ;; 'denote-prompts's value is a list with the following options:
        ;;
        ;; title/keywords/file-type/subdirectory/date
        ;;
        (setq denote-prompts '(title keywords subdirectory))
  )
#+END_SRC


**** How to create or open a note

| Function              | Description                                                     |
|-----------------------+-----------------------------------------------------------------|
| ~denote~                | It prompts you step-by-step which you set to the ~denote-prompts~ |
| ~denote-date~           | It prompts you for a date.                                      |
| ~denote-type~           | It prompts you for a file type.                                 |
| ~denote-template~       | It prompts you for a template.                                  |
| ~denote-org-capture~    | Create note directly via ~org-capture-templates~.                 |
| ~denote-subdirectory~   | It prompts for a subdirectory.                                  |
| ~denote-open-or-create~ | If file does not exist, invoke ~denote~ to create a file.         |
|                       |                                                                 |


**** How to change the current file =meta= data (=title/date/filetags/identifier=)

Just by running ~denote-rename-file~ and then select the file and finish the new note prompt and save it.


**** How to handle links in your note

| Function              | Description                                             |
|-----------------------+---------------------------------------------------------|
| ~denote-link~           | Create a link to the existing node                      |
| ~denote-link-or-create~ | Create a link to a node (create it if not exists)       |
| ~denote-find-link~      | List all note links in current buffer                   |
| ~denote-backlinks~      | List all backlinks to the current note.                 |
| ~denote-add-links~      | Create a list of links that based on your regexp search |
|                       |                                                         |


** Programming related

*** Langauge mode

**** =Zig=

#+begin_src emacs-lisp
  (use-package zig-mode)
#+end_src
 
**** =Rust=

#+begin_src emacs-lisp
  (use-package rust-mode)
#+end_src


**** =Fish=

#+begin_src emacs-lisp
  (use-package fish-mode)
#+end_src


**** =Markdown=

#+begin_src emacs-lisp
  (use-package markdown-mode)
#+end_src


**** =TypeScript=

#+begin_src emacs-lisp
  (use-package typescript-mode
    :mode "\\.ts\\'"
    :config
    (setq typescript-indent-level 4)
  )
#+end_src


**** =Web=

#+begin_src emacs-lisp
  ;; (use-package web-mode
  ;;   :config
  ;;       (setq web-mode-markup-indent-offset 4
  ;;             web-mode-css-indent-offset 4
  ;;             web-mode-code-indent-offset 4
  ;;             web-mode-style-padding 4
  ;;             web-mode-script-padding 4
  ;;             web-mode-enable-auto-closing t
  ;;             web-mode-enable-auto-opening t
  ;;             web-mode-enable-auto-pairing t
  ;;             web-mode-enable-auto-indentation t)
  ;;   :mode
  ;;       (".html$" "*css$" "*.tsx")
  ;; )
#+end_src


**** =Python=

#+begin_src emacs-lisp :tangle no
  ;; (use-package lsp-pyright
  ;;     :hook (python-mode . (lambda ()
  ;;             (setq indent-tabs-mode t)
  ;;             (setq tab-width 4)
  ;;             (setq python-indent-offset 4)
  ;;             (company-mode 1)
  ;;             (require 'lsp-pyright)
  ;;             (pyvenv-autoload)
  ;;             (lsp))
  ;;     )
  ;; )
#+end_src
 



*** =Comment/Uncomment=

#+begin_src emacs-lisp
  (use-package evil-commentary
      :defer t
      :hook (prog-mode . evil-commentary-mode)
  )
#+end_src


*** =Yasnippet= 

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "~/.config/emacs/snippets")

  ;;
  ;; Fix 'company' can't list 'yasnippet' candidates in dropdown list
  ;;
  (defun my-fix-company-yasnippet()
     ;; (add-to-list 'company-backends '(company-capf :with company-yasnippet))

     ;;
     ;; Make 'yassnippet' list first
     ;;
     (add-to-list 'company-backends '(:separate company-yasnippet company-capf))
  )

  (use-package yasnippet
    :config
      ;;
      ;; Enable 'yasnippet' in global minor mode
      ;;
      ;; (yas-global-mode 1)

      ;;
      ;; But I prefer only neable 'yasnippet' in coding mode
      ;;
      (yas-reload-all)

      (add-hook 'org-mode-hook #'yas-minor-mode)
      (add-hook 'prog-mode-hook #'yas-minor-mode)
      ;; (add-hook 'c-ts-mode-hook #'yas-minor-mode)
      ;; (add-hook 'c++-ts-mode-hook #'yas-minor-mode)
      ;; (add-hook 'rust-ts-mode-hook #'yas-minor-mode)
      ;; (add-hook 'zig-mode-hook #'yas-minor-mode)
      ;; (add-hook 'zig-ts-mode-hook #'yas-minor-mode)
      ;; (add-hook 'org-mode-hook #'yas-minor-mode)
      ;; (add-hook 'cmake-ts-mode-hook #'yas-minor-mode)
      ;; (add-hook 'js-ts-mode-hook #'yas-minor-mode)
      ;; (add-hook 'typescript-ts-mode-hook #'yas-minor-mode)
      ;; (add-hook 'hare-mode-hook #'yas-minor-mode)
      ;; (add-hook 'hare-ts-mode-hook #'yas-minor-mode)
  	;; (add-hook 'emacs-lisp-mode-hook #'yas-minor-mode)
  	;; (add-hook 'lisp-interaction-mode #'yas-minor-mode)

      ;;
      ;; Fix 'company' can't list 'yasnippet' candidates in dropdown list
      ;;
      (add-hook 'eglot-managed-mode-hook #'my-fix-company-yasnippet)

  	;;
  	;; Fix 'company' can't list 'yasnippet' in the following modes,
  	;; as those modes won't trigger 'eglot' (NO LSP support yet)!!!
  	;;
  	(add-hook 'prog-mode-hook #'my-fix-company-yasnippet)
  	;; (add-hook 'hare-mode-hook #'my-fix-company-yasnippet)
  	;; (add-hook 'hare-ts-mode-hook #'my-fix-company-yasnippet)
  	;; (add-hook 'emacs-lisp-mode-hook #'my-fix-company-yasnippet)
  	;; (add-hook 'lisp-interaction-mode #'my-fix-company-yasnippet)
  )
#+END_SRC

**** Where's your snippets

Snippets are located in the ~yas-snippet-dirs~ which I've already set in the ~'load-path~ above.

The folder structure looks like this (aka, ~snippet tables~):

#+BEGIN_SRC bash
#  ~/.config/emacs/snippets
#                    |-- c-ts-mode
#                    |   |-- printf
#                    |-- rust-ts-mode
#                    |   |-- println
#                    |-- zig-mode
#                        |-- print
#+END_SRC


**** Useful commands

| Command                | Description                                         |
|------------------------+-----------------------------------------------------|
| ~yas-describe-tables~    | Show the YASnippet tables for all modes             |
| ~yas-new-snippet~        | Create a new snippet                                |
| ~yas-visit-snippet-file~ | Open exists snippet                                 |
| ~yas-tryout-snippet~     | Open a buffer with given mode to try snippet        |
| ~yas-reload-all~         | Reload all snippets on the fly (good for debugging) |



*** =Company=

Completion to provide a dropdown selection.

#+begin_src emacs-lisp
  (use-package company
    :custom
       (company-minimum-prefix-length 2)
       (company-idel-delay 0.0)
    :config
        ;;
        ;; Enable completion for all buffers
        ;;
        (global-company-mode 1)
  )

  ;;
  ;; A company front-end with icons.
  ;;
  (use-package company-box
    :hook (company-mode . company-box-mode))
#+end_src


*** Custom compilation error

By default, the ~compile~ command runs a COMMAND, a shell command, in a separate process asynchronously
with output going to the buffer =compilation=.

Inside the =compilation= buffer, you will see some errors if the compilnation fails:

#+BEGIN_SRC fish
  src/main_test.c:31:5: error: call to undeclared library function 'rintf' with type 'float (float)'; ISO C99 and later do not support implicit function declarations [-Wimplicit-function-declaration]
#+END_SRC

If your press ~RET~ on the error line, Emacs will call ~compile-goto-error~ for you and take you to the source code and locate the error position.

That works because of the following 2 global variables:

~compilation-error-regexp-alist~: It symbol a list, the symbol usually is the command name. Emacs uses it to get back the exact error regex string from the ~compilation-error-regexp-alist-alist~.

~compilation-error-regexp-alist-alist~: It's a list to store the pair of =command-symobl <-=-> error regex=.


That means if can't jump to the source code when pressing ~RET~ on the error line, then you should add the new =command-symobl <-=-> error regex= to ~compilation-error-regexp-alist-alist~!!!


**** Odin

To help you to figure the exact regex string, you can switch to the =compilation= buffer and run ~regexp-builder~. It shows a small buffer at the bottom, then you can type and test your regex to see the matching result in real-time.


#+BEGIN_SRC emacs-lisp
  ;;
  ;; The command name as 'symbol'
  ;;
  (push 'odin compilation-error-regexp-alist)

  ;;
  ;; The real error regex
  ;;
  (add-to-list
  	'compilation-error-regexp-alist-alist
  	'(
  		;;
  		;; The 'symbol' that you use in 'compilation-error-regexp-alist'
  		;;
  		odin

  		;;
  		;; Regex pattern to match: '/path/file.odin(line:column) '
  		;;
  		;; Here are the rules:
  		;;
  		;; The regex has different match groups in order:
  		;; 'FILE [LINE COLUMN TYPE HYPERLINK HIGHLIGHT...]'
  		;;
  		;; The first 'FILE' group is a must, and the other groups are optional.
  		;;
  		"^\\([^(\n]+\\)(\\([0-9]+\\):\\([0-9]+\\))\\ .*$"

  		;;
  		;; The rest parts to indicated which group is for what
  		;;
  		1	; FILE group
  		2	; LINE group
  		3	; COLUMN group
  	)
  )
#+END_SRC

/Users/wison/odin/temp-odin/src/main_test.odin(31:6) Syntax Error: Expected ';', got identifier 



** =eglot= LSP support

=Emacs Polyglot= is the built-in Emacs LSP client.

- Github: https://github.com/joaotavora/eglot
- Manual: https://joaotavora.github.io/eglot

*** Upgrade to latest version

You can run ~eglot-upgrade-eglot~ to the latest version.


*** Install language server

Before you can active =eglot=, you have to install your language server separated.

**** =clangd=

#+BEGIN_SRC bash
  # For Arch Linux
  doas pacman --refresh --sync clang
#+END_SRC

  
**** =zls=

#+BEGIN_SRC bash
  # Build the `zls` from source:

  mkdir ~/temp/ && cd ~/temp
  git clone --recurse-submodules https://github.com/zigtools/zls
  cd zls
  zig build -Doptimize=ReleaseSafe

  # Then move `./zig-out/bin/zls` to your $PATH folder

  # Remove the repo folder
  cd .. && rm -rf zls
#+END_SRC


**** =rust-analyzer=

#+BEGIN_SRC bash
  # Better to upgrade =rust= to latest version (optional)
  # rustup upgrade

  # Remove the old version that comes from `rustup`
  rm -rf ~/.cargo/bin/rust-analyzer

  # Then install the latest version

  # For Arch Linux
  doas pacman --refresh --sync rust-analyzer
#+END_SRC



**** =cmake-language-server=

#+BEGIN_SRC bash
  pip3 install cmake-language-server 

  # Arch linux via paru
  paru --sync --refresh cmake-language-server
#+END_SRC


**** =typescript language server=

By default, it supports the filetypes below:

- javascript
- javascriptreact
- javascript.jsx
- typescript
- typescriptreact
- typescript.tsx

#+BEGIN_SRC bash
    npm install -g typescript typescript-language-server
#+END_SRC


**** Java language server

Download LSP from [[https://download.eclipse.org/jdtls/milestones/?d][here]]

For example, download the latest version: ~jdt-language-server-1.9.0-202203031534.tar.gz~

- Extract

    #+BEGIN_SRC bash
    mkdir java-lsp-server
    tar zxf jdt-language-server-1.9.0-202203031534.tar.gz --directory java-lsp-server 
    #+END_SRC


- Configure =Java= LSP

   Just add =java-lsp-server/bin= to your =$PATH= environment var.


**** =Python=

#+BEGIN_SRC bash
  pip install python-lsp-server
  pip install --upgrade autopep8 
#+END_SRC


*** Setup langauge server list (optional)

~eglot-server-programs~ is the variable that use to list all relationships between =mode= and =language server=.

Basically, the default value covers all you need already, you can check it in the github home page:

https://github.com/joaotavora/eglot

If you run ~describe-variable~ on ~eglot-server-programs~, you should be able to see something like the following:

#+BEGIN_SRC emacs-lisp :tangle no
  ;; (((rust-ts-mode rust-mode)
  ;;   "rust-analyzer")
  ;;  (zig-mode "zls")
  ;;  ((cmake-mode cmake-ts-mode)
  ;;   "cmake-language-server")
  ;;  ((js-mode js-ts-mode tsx-ts-mode typescript-ts-mode typescript-mode)
  ;;   "typescript-language-server" "--stdio")
  ;;  ((dockerfile-mode dockerfile-ts-mode)
  ;;   "docker-langserver" "--stdio")
  ;;  ((bash-ts-mode sh-mode)
  ;;   "bash-language-server" "start")
  ;;  ((c-mode c-ts-mode c++-mode c++-ts-mode)
  ;;   .
  ;;       [("clangd" "ccls")
  ;;   ;; ...ignore the rest
  ;; )
#+END_SRC

That said, you don't need to do anything:)

But if you have to use another language servers, then you can have a look at here:

https://joaotavora.github.io/eglot/#Setting-Up-LSP-Servers


*** ~eglot-server-programs~ extra settings for ~ols~ (Odin LSP server))

If you want to pass extra arguments/options to the specific LSP server, you can do that in the following ways:

#+BEGIN_SRC emacs-lisp :tangle no
  ;;
  ;; Here is the code and comment from 'eglot-server-programsr'
  ;;
  (defvar eglot-server-programs `())

  ;;
  ;; How the command 'eglot' guesses the server to start.
  ;; An association list of '(MAJOR-MODE . CONTACT)' pairs.
  ;;
  ;; 'MAJOR-MODE' identifies the buffers that are to be managed by a specific language server.
  ;; 'CONTACT' specifies how to connect to a server for those buffers.
  ;;
  ;; The value of 'CONTACT' can be either:
  ;;
  ;; - '(program args…)'
  ;;   This says to invoke program with zero or more arguments args; the program is expected
  ;;   to communicate with Emacs via the standard input and standard output streams.
  ;; 
  ;; - '(program args… :initializationOptions options…)'
  ;;   program is invoked with args but options specifies how to construct the
  ;;   ‘:initializationOptions’ JSON object to pass the server on during the LSP handshake
  ;;
#+END_SRC

So, for letting the ~ols~ to know where your Odin collections located, you need the following settings:

#+BEGIN_SRC emacs-lisp
  ;; (setq init_options (concat (getenv "HOME") "/odin/odin-utils"))
  (with-eval-after-load 'eglot
  	(add-to-list 'eglot-server-programs
  		`(
  			(odin-mode odin-ts-mode)
  			.
  			(
  				"ols"
  				:initializationOptions
  				(:collections
  					(
  						:name "utils"
  						:path "/home/wison/odin/odin-utils" 
  					)
  				)
  			)
  		)
  	)
  )
#+END_SRC


This part:

#+BEGIN_SRC emacs-lisp :tangle no
  :initializationOptions
  (:collections
  	(
  		:name "utils"
  		:path init_options 
  	)
  )
#+END_SRC

is Emacs’s representation in =plist= format of a simple =JSON= object:

#+BEGIN_SRC json-ts
  {
    "initializationOptions": {
      "collections": {
        "name": "utils",
        "path": "/home/wison/odin/odin-utils" 
      }
    }
  }
#+END_SRC

After opening a =odin= file and the =eglot= runs, you can run ~eglot-events-buffer~ to see the realtime LSP server log to confirm that =initializationOptions= works as expected:

#+BEGIN_SRC fish
  jsonrpc: 2.0
  id:      1
  method:  initialize
  params:
    processId:             35937
    clientInfo:
      name:    Eglot
      version: 1.18
    rootPath:              /home/wison/odin/temp-odin/
    rootUri:               file:///home/wison/odin/temp-odin
    initializationOptions:
      collections:
        name: utils
        path: /home/wison/odin/odin-utils
#+END_SRC


*** Start =eglot=

**** Start =eglot= manually

The most common way to start Eglot is to simply visit a source file of a given language and use the command ~M-x eglot~. This starts the language server suitable for the visited file’s =major-mode,= and attempts to connect to it. If the connection to the language server is successful, you will see the =[eglot:project]= indicator on the mode line which reflects the server that was started. 

For example:

#+BEGIN_SRC bash

  #[eglot] Connected! Server `clangd' now managing `(c-ts-mode c-mode c++-mode c++-ts-mode)' buffers in project `ping-pong-tron-legacy'.

#+END_SRC


A single =Eglot= session for a certain =major-mode= usually serves all the buffers under that mode which visit files from the same project, so you don’t need to invoke =M-x eglot= again when you visit another file from the same project which is edited using the same =major-mode.= This is because =Eglot= uses the Emacs project infrastructure, as described in Buffers, Projects, and Eglot, and this knows about files that belong to the same project. Thus, after starting an Eglot session for some buffer, that session is automatically reused when visiting files in the same project with the same =major-mode=.


**** Start =eglot= automatically

***** Fix =tab= issue

Before you setup the start hook, you better to fix the =indentation= style.

****** What is a =style=

A =style= is a named collection of customizations that can be used in C mode and the related modes. There are many of them with very different settings.

For example, this is the default =gnu= style and =linux= style:

#+BEGIN_SRC emacs-lisp :tangle no
  ;; GNU
  ("gnu"
   (c-basic-offset . 2)
   (c-comment-only-line-offset 0 . 0)
   (c-hanging-braces-alist
    (substatement-open before after)
    (arglist-cont-nonempty))
   (c-offsets-alist
    (statement-block-intro . +)
    (knr-argdecl-intro . 5)
    (substatement-open . +)
    (substatement-label . 0)
    (label . 0)
    (statement-case-open . +)
    (statement-cont . +)
    (arglist-intro . c-lineup-arglist-intro-after-paren)
    (arglist-close . c-lineup-arglist)
    (inline-open . 0)
    (brace-list-open . +)
    (brace-list-intro first c-lineup-2nd-brace-entry-in-arglist c-lineup-class-decl-init-+ +)
    (topmost-intro-cont first c-lineup-topmost-intro-cont c-lineup-gnu-DEFUN-intro-cont))
   (c-special-indent-hook . c-gnu-impose-minimum)
   (c-block-comment-prefix . ""))

  ;;  Linux
  ("linux"
    (indent-tabs-mode . t)
      (c-basic-offset . 8)
      (c-comment-only-line-offset . 0)
      (c-hanging-braces-alist
       (brace-list-open)
       (brace-entry-open)
       (substatement-open after)
       (block-close . c-snug-do-while)
       (arglist-cont-nonempty))
      (c-cleanup-list brace-else-brace)
      (c-offsets-alist
       (statement-block-intro . +)
       (knr-argdecl-intro . 0)
       (substatement-open . 0)
       (substatement-label . 0)
       (label . 0)
       (statement-cont . +)))
#+END_SRC

As you can see, they're very different in the detail, it effects your indentation (every time you type =(, [, {= and press =<return>= to add a new line, it will cause reindentation. If you pick the wrong one, you got a mess code and it's very annoying!!!

And the variable =c-default-style= to specify the default style for various major modes( NOT just for the =c-mode=), its default value looks like this:

#+BEGIN_SRC emacs-lisp :tangle no
  ((java-mode . "java")
   (awk-mode . "awk")
   (other . "gnu"))
#+END_SRC

That said except the =java-mode= and =awk-mode=, all the other major modes apply the =gnu= style, that's why your C/C++ code gets messed up!!!

For detailed information, plz take a look at the [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Custom-C-Indent.html][Customizing C Indentation]] chapter.


****** How to set default style

If you only want to change the current buffer style, you can press ~C-c .~ then pick a style and press ~<return>~. Or you can call ~c-set-style~ in CC mode, ~c-ts-mode-set-style~ in =c-ts-mode= based on tree-sitter. But keep that in mind, that setting only affects the current buffer!!!

Here is the way to set the default style via the hook:

#+BEGIN_SRC emacs-lisp
  (setq my-tab-width 4)

  ;;
  ;; 
  ;;
  (defun my-c-style-settings()
      ;;
      ;; Very important to reset!!!
      ;;
      (setq tab-width my-tab-width)                

      ;;
      ;;This setting ONLY for for 'c-mode'!!!
      ;;
      (setq c-default-style "linux")               ;; Default is 'gun'
      (setq c-basic-offset my-tab-width)           ;; Default is 2

      ;;
      ;; In 'c-ts-mode' you have to use another settings!!!
      ;;
      (setq c-ts-mode-indent-style "linux")        ;; Default is 'gun'
      (setq c-ts-mode-indent-offset my-tab-width)  ;; Default is 2

      ;;
      ;; Back to normal TAB behavior rather than 'indent-for-tab-command' 
      ;;
      (keymap-set evil-insert-state-local-map "TAB" 'tab-to-tab-stop)

      (message ">>> my-c-style-settings [done]")
  )

  ;; ;;
  ;; ;; In 'c-ts-mode' you have to use another settings!!!
  ;; ;;
  ;; (defun my-c-treesitter-style-settings()
  ;;     (setq c-ts-mode-indent-style "linux")        ;; Default is 'gun'
  ;;     (setq c-ts-mode-indent-offset my-tab-width)  ;; Default is 2
  ;;     (message ">>> my-c-treesitter-style-settings [done]")
  ;; )

  ;;
  ;;
  ;;
  (defun my-emacs-lisp-style-settings()
      (setq tab-width 4)

      (setq lisp-indent-offset my-tab-width)  ;; Default is 2

      ;;
      ;; Back to normal TAB behavior rather than 'indent-for-tab-command'
      ;;
      (keymap-set evil-insert-state-local-map "TAB" 'tab-to-tab-stop)

      (message ">>> my-emacs-lisp-style-settings [done]")
  )


  ;;
  ;; 
  ;;
  (defun my-js-ts-style-settings()
      ;;
      ;; Very important to reset!!!
      ;;
      (setq tab-width my-tab-width)                

      ;;
      ;; Back to normal TAB behavior rather than 'indent-for-tab-command' 
      ;;
      (keymap-set evil-insert-state-local-map "TAB" 'tab-to-tab-stop)

      (message ">>> my-js-ts-style-settings [done]")
  )


  (add-hook 'c-mode-hook #'my-c-style-settings)
  (add-hook 'c-ts-mode-hook #'my-c-style-settings)
  (add-hook 'c++-ts-mode-hook #'my-c-style-settings)
  (add-hook 'zig-mode-hook #'my-c-style-settings)
  (add-hook 'rust-ts-mode-hook #'my-c-style-settings)
  (add-hook 'emacs-lisp-mode-hook #'my-emacs-lisp-style-settings)
  (add-hook 'lisp-interaction-mode-hook #'my-emacs-lisp-style-settings)
  (add-hook 'snippet-mode-hook #'my-emacs-lisp-style-settings)
  (add-hook 'cmake-ts-mode-hook #'my-c-style-settings)
  (add-hook 'typescript-ts-mode-hook #'my-js-ts-style-settings)
  (add-hook 'js-ts-mode-hook #'my-js-ts-style-settings)
  (add-hook 'java-ts-mode-hook #'my-js-ts-style-settings)
  (add-hook 'python-ts-mode-hook #'my-c-style-settings)
#+END_SRC


***** Setup hook to start =eglot=

Here is the way to start =eglot= automatically:

#+BEGIN_SRC emacs-lisp
  (defun start-eglot()
     (eglot-ensure)
     (setq eldoc-echo-area-prefer-doc-buffer t)
     (message ">>> start-elogt")
  )

  (dolist (hook '(c-mode-hook
                  c-ts-mode-hook
                  c++-ts-mode-hook
                  rust-ts-mode-hook
                  zig-mode-hook
                  cmake-ts-mode-hook
                  js-ts-mode-hook
                  typescript-ts-mode-hook
                  java-ts-mode-hook
                  odin-ts-mode-hook
                  python-ts-mode-hook 
                  ))
     (add-hook hook #'start-eglot)
  )
#+END_SRC


The following settings try to disable 'inlay-hint', but it seems doesn't work, have no idea why....

#+BEGIN_SRC emacs-lisp :tangle no
  ;; (defun my-eglot-disable-inlay-hint()
  ;;    (message ">>> [ my-eglot-disable-inlay-hint ]")
  ;;    (eglot-inlay-hints-mode -1)
  ;;    (message ">>> [ my-eglot-disable-inlay-hint ] done.")
  ;; )
  ;; 
  ;; (add-hook 'eglot-connect-hook #'my-eglot-disable-inlay-hint)
#+END_SRC


*** Stop =eglot=

If you don't want to run the =eglot= anymore for any reasons, just run =M-x eglot-shutdown=.


*** =eglot= commands

**** M-x eglot

This command adds the current buffer and the file it visits to the group of buffers and files managed by Eglot on behalf of a suitable language server. If a language server for the buffer’s major-mode (see Major Modes in GNU Emacs Manual) is not yet running, it will be started; otherwise the buffer and its file will be added to those managed by an existing server session.


**** M-x eglot-shutdown

This command shuts down a language server. It prompts for a language server to shut down (unless there’s only one server session, and it manages the current buffer). Then the command shuts down the server and stops managing the buffers the server was used for. Emacs features (see Eglot Features) that Eglot configured to work with the language server are restored back to their original configuration.

Normally, this command kills the buffers used for communicating with the language server, but if invoked with a prefix argument C-u, the command doesn’t kill those buffers, allowing them to be used for diagnostics and problem reporting (see Troubleshooting Eglot).


**** M-x eglot-shutdown-all

This command shuts down all the language servers active in the current Emacs session. As with eglot-shutdown, invoking this command with a prefix argument avoids killing the buffers used for communications with the language servers.


**** M-x eglot-rename

This command renames the program symbol (a.k.a. identifier) at point to another name. It prompts for the new name of the symbol, and then modifies all the files in the project which are managed by the language server of the current buffer to implement the renaming.


**** M-x eglot-format

This command reformats the active region according to the language-server rules. If no region is active, it reformats the entire current buffer.


**** M-x eglot-format-buffer

This command reformats the current buffer, in the same manner as eglot-format does.



**** M-x eglot-code-actions

***** M-x eglot-code-action-organize-imports
***** M-x eglot-code-action-quickfix
***** M-x eglot-code-action-extract
***** M-x eglot-code-action-inline
***** M-x eglot-code-action-rewrite


**** M-x eglot-inlay-hints-mode

This command toggles LSP inlay hints on and off for the current buffer. Inlay hints are small text annotations to specific parts of the whole buffer, not unlike diagnostics, but designed to help readability instead of indicating problems. 


**** M-x eglot-stderr-buffer

This command pops up the buffer with the debug info printed by the language server to its standard error stream.


**** M-x eldoc

Ask the ElDoc system for help at point.

***** M-x eldoc-mode

Toggle echo area display of Lisp objects at point (ElDoc mode), it shows the documentation (at point) in the eacho area.

It's enabled by default after =eglot= has beeen executed and it should become the buffer-loca minor mode which you can see it inside the 'modeline'.

If you turn off this mode, the =eldoc-doc-buffer= won't update anymore!!!


***** M-x eldoc-doc-buffer

It opens a buffer and keep updating the documentation (at point) until the buffer has been killed or you turn off the =eldoc-mode=, it's super convenient.

It bounds to =K= by default.


**** M-x flymake-show-buffer-diagnostics

Ask Flymake system to display diagnostics for the current buffer.


**** M-x flymake-show-project-diagnostics

Ask Flymake to list diagnostics for all the files in the current project.


**** M-x xref-find-definitions

Ask Xref to go the definition of the identifier at point.


**** M-x imenu

Let the user navigate the program source code using buffer index, categorizing program elements by syntactic class (class, method, variable, etc.) and offering completion.

Better to use =consult-imenu= instead.


**** M-x completion-at-point

Request completion of the symbol at point.


** My custom abbrevations

*** Turn off the ~save-abbrevs~

#+BEGIN_SRC emacs-lisp
  ;;
  ;; I hate Emacs asks me every time I if I didn't save the abbrev talbe!!!
  ;;
  (setq save-abbrevs nil)

  ;;
  ;; As I re-create all my abbrevs on the fly after Emacs has been loaded,
  ;; that's why I don't need this!!!
  ;;
  ;; (setq abbrev-file-name "")
#+END_SRC


*** All my abbrevs here

**** Abbrev util functions

#+BEGIN_SRC emacs-lisp
  ;;
  ;; This is a special hook function that prevents inserting the 'space'
  ;; when expanding your abbrev!!!
  ;;
  ;; Here the doc info about that part
  ;; Signature
  ;; (define-abbrev TABLE ABBREV EXPANSION &optional HOOK &rest PROPS)
  ;;
  ;; If HOOK is 'non-nil', it should be a function of no arguments;
  ;;
  ;; If HOOK is a 'non-nil' 'symbol' with a 'non-nil' 'no-self-insert' property,
  ;; it can control whether the character that triggered abbrev expansion
  ;; is inserted ('space' in default case).
  ;; If such a HOOK returns 'non-nil', the character is not inserted.
  ;; If such a HOOK returns 'nil', then so does abbrev-insert (and expand-abbrev),
  ;; as if no abbrev expansion had taken place.
  ;;
  (defun not-insert-space () t)
  (put 'not-insert-space 'no-self-insert t)

  ;;
  ;; Insert now datetime with default format: Wed Aug 27 17:56:23 2025
  ;;
  (defun my-abbr-now ()
      "Abbr expension to now datetime"
  	(insert (current-time-string))
  	t
  )
  (put 'my-abbr-now 'no-self-insert t)

  ;;
  ;; Insert now datetime with this format: 2025-08-27 17:56:27
  ;;
  (defun my-abbr-now-only-date ()
      "Abbr expension to now datetime"
  	(insert (format-time-string "%Y-%m-%d %H:%M:%S"))
  	t
  )
  (put 'my-abbr-now-only-date 'no-self-insert t)

  ;;
  ;; Insert now datetime with this format: 17:56:27
  ;;
  (defun my-abbr-now-only-time ()
      "Abbr expension to now datetime"
  	(insert (format-time-string "%H:%M:%S"))
  	t
  )
  (put 'my-abbr-now-only-time 'no-self-insert t)
#+END_SRC


**** global-abbrev-table

#+BEGIN_SRC emacs-lisp :tangle (expand-file-name "~/.config/emacs/my-abbrevs.el")
    ;;
    ;; Clear it
    ;;
    (clear-abbrev-table global-abbrev-table)

    ;;
    ;; Signature
    ;; (define-abbrev-table TABLENAME DEFINITIONS &optional DOCSTRING &rest PROPS)
    ;;
    ;; Documentation
    ;; Define TABLENAME (a symbol) as an abbrev table name.
    ;;
    ;; Define abbrevs in it according to DEFINITIONS, which is a list of elements
    ;; of the form (ABBREVNAME EXPANSION ...) that are passed to define-abbrev.
    ;;
    (define-abbrev-table 'global-abbrev-table '(
        ("afaik" "as far as I know" not-insert-space)
        ("bg" "background" not-insert-space)
        ("fg" "foreground" not-insert-space)
        (":mygithub" "https://github.com/wisonye" not-insert-space)
        (":mylinkedin" "https://www.linkedin.com/in/wison-y-51888887/" not-insert-space)
        (":now" "" my-abbr-now)
        (":nowdateonly" "" my-abbr-now-only-date)
        (":nowtimeonly" "" my-abbr-now-only-time)
    ))


  ;;
  ;; The ":mg" aabrev above needs an extra settings to make it work, as ':' is NOT
  ;; considered at part of the word you expected!!!
  ;;
  ;; You need to modify the properties of the abbreviation table to accept characters
  ;; that are not word consituents.
  ;;
  ;; You need to call `abbrev-table-put' to set the 'props' to the abbrev table:
  ;;
  ;; Signature
  ;; (abbrev-table-put TABLE PROP VAL)
  ;;
  ;; To know more about the ':regexp' property, you can run 'info' and goto the section:
  ;; 'Elisp -> Abbrevs -> Abbrev Properties'
  ;;
  (abbrev-table-put global-abbrev-table :regexp "\\(?:^\\|[\t\s]+\\)\\(?1:[:_].*\\|.*\\)")
#+END_SRC


**** emacs-lisp-mode-abbrev-table

#+BEGIN_SRC emacs-lisp :tangle (expand-file-name "~/.config/emacs/my-abbrevs.el")
  ;;
  ;; Clear it if exists
  ;;
  (when (boundp 'emacs-lisp-mode-abbrev-table)
  	(clear-abbrev-table emacs-lisp-mode-abbrev-table)
  )

  (define-abbrev-table 'emacs-lisp-mode-abbrev-table '(
      ("km" "(keymap-set MODE-MAP \"KEY\" ')" not-insert-space)
      ;; ("mkm" my-keymap-set)
      ("setql" "(setq-local" not-insert-space)
      ("stringempty" "(string-empty-p VAR)" not-insert-space)
      ("stringmatch" "(string-match-p STRING-TO-CHECK VAR)" not-insert-space)
      ("stringnotempty" "(not (string-empty-p VAR))" not-insert-space)
      ("stringnotmatch" "(not (string-match-p STRING-TO-CHECK VAR))" not-insert-space)
  ))
#+END_SRC


*** Lazy load my abbrevs from file

#+BEGIN_SRC emacs-lisp
  (defun my-load-addbrevs-from-file ()
  	;;
  	;; Load my file
  	;;
  	(load  "~/.config/emacs/my-abbrevs.el")

  	;;
  	;; Enable 'abbrev-mode' by hooks
  	;;
  	;; 'text-mode' covers a lot another modes
  	;; 'prog-mode' covers all programming modes
  	;;
  	(add-hook 'text-mode-hook #'abbrev-mode)
  	(add-hook 'prog-mode-hook #'abbrev-mode)
  )

  (add-hook 'after-init-hook #'my-load-addbrevs-from-file)
#+END_SRC


** Color theme

*** =Nerd icons=

#+BEGIN_SRC emacs-lisp
  (use-package nerd-icons)
#+END_SRC

After =nerd-icons= has been installed, you need to run ~nerd-icons-install-fonts~ once to install particular icon font until you can see the nerd icons!!!


*** ++All-the-icons (=treemacs= depends on this fonts)+

Another option you can choose is =all-the-icons= (But I disabled at this momment, as I use =nerd-icons=).

#+BEGIN_SRC emacs-lisp :tangle no
  ;; (use-package all-the-icons)
#+END_SRC

After =all-the-icons= has been installed, you need to run ~all-the-icons-install-fonts~ once to install particular icon font until you can see the icons!!!


*** Doom themes

This package includes a lot of color themes.

;; #+BEGIN_SRC emacs-lisp
#+BEGIN_SRC emacs-lisp
  (use-package doom-themes
      ;; :disabled
      :config
      ;; Global settings (defaults)
      (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
            doom-themes-enable-italic t) ; if nil, italics is universally disabled

      ;; Load theme, pick the one you like
      ;; (load-theme 'doom-gruvbox t)
      ;;(load-theme 'doom-nord-aurora t)
      ;;(load-theme 'doom-one t)
      ;;(load-theme 'doom-solarized-dark t)
      ;;(load-theme 'doom-pine t)
      ;;(load-theme 'doom-zenburn t)
      ;;(load-theme 'doom-laserwave t)
      ;;(load-theme 'doom-henna t)
      ;;(load-theme 'doom-xcode t)
      ;;(load-theme 'doom-lantern t)
      ;;(load-theme 'doom-miramare t)
      ;;(load-theme 'doom-old-hope t)

      ;; Enable flashing mode-line on errors
      ;;(doom-themes-visual-bell-config)

      ;; Enable custom neotree theme (all-the-icons must be installed!)
      (doom-themes-neotree-config)
      ;; or for treemacs users
      (setq doom-themes-treemacs-theme "doom-atom") ; use "doom-colors" for less minimal icon theme
      (doom-themes-treemacs-config)
      ;; Corrects (and improves) org-mode's native fontification.
      (doom-themes-org-config)
    )
#+END_SRC


**** How to customize any theme you're using???

Basically, you can use ~describe-variable~ and put your theme name there and ~tab~ to see what theme variable you can use, then pick any one of them to go to the help document.

After that, you can click the theme source code link and you're able to customize from the source code:)

For example, the current theme link in the theme variable help document, put your cursor to the =doom-solarized-light-theme.el= and press ~RET~. Modify all colors you want and save, then reload:)

=doom-solarized-light-padded-modeline= is a variable defined in =doom-solarized-light-theme.el=.


*** +Doom modeline (status bar concept in =Vim=)+

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package doom-modeline
    :disabled
    :after doom-themes
    :init
        (setq doom-modeline-buffer-file-name-style 'truncate-from-project)
        (setq nerd-icons-color-icons nil)
        (doom-modeline-mode 1)
  )
#+END_SRC


*** EF themes

#+BEGIN_SRC emacs-lisp
  (use-package ef-themes
      ;; :disabled
      :config
  )
#+END_SRC


*** =Tron-legacy-theme=

**** +This is the original version which I don't use anymore+

#+BEGIN_SRC emacs-lisp :tangle no
  ;; (use-package tron-legacy-theme
  ;;    :init
  ;;    :config
  ;;        ;; Gloden cursor, only effects the 'GUI' mode
  ;;        (setq tron-legacy-theme-vivid-cursor t)

  ;;        ;; The foreground to be dimmed and comments to be brighter
  ;;        ;; (setq tron-legacy-theme-dark-fg-bright-comments t)

  ;;        ;; changes the background color to a dark gunmetal grey,
  ;;        ;; instead of the default pure black. It doesn't work, as I
  ;;        ;; set a solid background color in 'settings.org'!!!
  ;;        ;; (setq tron-legacy-theme-softer-bg t)

  ;;        (load-theme 'tron-legacy t)
  ;; )
#+END_SRC


**** This is my modified version

I modified the =tron-legacy-theme= and place it in =~/.config/emacs/themes=.

Here are the steps to modify the setting on the fly:

1. Open =~/.config/emacs/themes/my-tron-legacy-theme.el= and change colors

2. Run ~M-x byte-recompile-file~ to re-generate the =~/.config/emacs/themes/my-tron-legacy-theme.elc=

3. In any =emacs= instance, run ~(load-theme 'my-tron-legacy t)~ to take affect.


#+BEGIN_SRC emacs-lisp
  (add-to-list 'custom-theme-load-path "~/.config/emacs/themes/")

  ;; Gloden cursor, only effects the 'GUI' mode
  (setq tron-legacy-theme-vivid-cursor t)

  ;; The foreground to be dimmed and comments to be brighter
  ;; (setq tron-legacy-theme-dark-fg-bright-comments t)

  ;; changes the background color to a dark gunmetal grey,
  ;; instead of the default pure black. It doesn't work, as I
  ;; set a solid background color in 'settings.org'!!!
  ;; (setq tron-legacy-theme-softer-bg t)

  ;; (load-theme 'my-tron-legacy t)
#+END_SRC


*** My custom modeline

**** What is ~mode-line-format~

~mode-line-format~ is the variable that you should set a formatted string to represent your custom mode line.

This is the default ~mode-line-format~ value:

#+BEGIN_SRC emacs-lisp :tangle no
  ("%e" mode-line-front-space
   (:propertize
    ("" mode-line-mule-info mode-line-client mode-line-modified mode-line-remote)
    display
    (min-width
     (5.0)))
   mode-line-frame-identification mode-line-buffer-identification "   " mode-line-position evil-mode-line-tag
   (vc-mode vc-mode)
   "  " mode-line-modes mode-line-misc-info mode-line-end-spaces)
#+END_SRC


When =eglot= enabled, ~(eglot--mode-line-format)~ get called and add its extra info to the =mode-line-misc-info=. That said you SHOULD include =mode-line-misc-info= in your custom =mode-line-format= if want the =eglot= to be shown.

#+BEGIN_SRC emacs-lisp :tangle no
  (add-to-list 'mode-line-misc-info
               `(eglot--managed-mode (" [" eglot--mode-line-format "] ")))
#+END_SRC


**** How to customize ~mode-line-format~

Here are the steps to customize your own mode line:

1. Use ~defvar~ to declare your own variables that will be used in the ~mode-line-format~ strintg value.

2. After ~defvar~ your own variables, you have to use ~put~ to add the ~risky-local-variable~ property to it and set that property's value to ~t~!!!

3. Use ~(setq-default mode-line-format '())~ to customize your mode line and that's it:)


Here are some useful functions you will use to customize your ~mode-line-format~:

| Function name               | Description                                                                |
|-----------------------------+----------------------------------------------------------------------------|
| ~propertize~                  | Return a copy of STRING with text properties added, for example add        |
|                             | custom face (font) to the string.                                          |
| ~major-mode~                  | Symbol for current buffers major mode.                                     |
| ~symbol-name~                 | Return SYMBOL's name, a string.                                            |
| ~capitalize~                  | Convert argument to capitalized form and return that.                      |
| ~put~                         | Store SYMBOL's PROPNAME property with value VALUE.                         |
| ~defface~                     | Declare FACE (font settings) as a customizable face that defaults to SPEC. |
| ~mode-line-window-selected-p~ | ~t~ when updating the mode line for the active window                        |



**** My ~mode-line-format~ settings

Read the comment carefully to understand how it works:

#+BEGIN_SRC emacs-lisp
  ;; -------------------------------------------------------------------------------
  ;; All custom faces (font settings)
  ;; -------------------------------------------------------------------------------
  ;; (defface my-modeline-light-blue-font '((t :foreground "#ACE6FE" :inherit italic bold)) "Modeline light blue font")
  ;; (defface my-modeline-blue-green-font '((t :foreground "#4BB5BE")) "Modeline blue-green font")
  ;; (defface my-modeline-light-orange-font '((t :foreground "#DEB45B")) "Modeline light-orange font")
  ;; (defface my-modeline-orange-font '((t :foreground "#FF9F1C")) "Modeline orange font")
  ;; (defface my-modeline-yellow-font '((t :foreground "#FFE64D")) "Modeline yellow font")
  ;; (defface my-modeline-light-red-font '((t :foreground "#f44747")) "Modeline light-red font")
  ;; (defface my-modeline-light-green-font '((t :foreground "#BBF0EF")) "Modeline light-green font")
  ;; (defface my-modeline-dark-green-font '((t :foreground "#5A7387")) "Modeline dark-green font")


  ;; -------------------------------------------------------------------------------
  ;; Override the default face for change mode line background
  ;; -------------------------------------------------------------------------------
  ;; (set-face-attribute 'mode-line-active nil :background "#2F2F2F")
  ;; (set-face-attribute 'mode-line-inactive nil :background nil)


  ;; -------------------------------------------------------------------------------
  ;; All modeline variables
  ;; -------------------------------------------------------------------------------

  ;;
  ;; 'my-modeline-major-mode' variable related
  ;;

  (defun my-get-major-mode ()
  	"Return 'major-mode' as a string but discard the '-mode' part."
  	(string-replace "-mode" "" (symbol-name major-mode)))

  (defun my-get-major-mode-2 ()
  	"Return 'major-mode' as a string."
  	(symbol-name major-mode))

  (defun my-get-major-mode-capitalize ()
  	"Return capitalized 'major-mode' as a string."
  	(capitalize (string-replace "-mode" "" (symbol-name major-mode))))

  (defvar-local my-modeline-major-mode
  	'(:eval
  		(propertize (my-get-major-mode-2)
  			'face '(
  					   :weight bold
  					   :slant italic
  					   ;; :background (face-attribute 'eglot-mode-line :background nil 'default)
  					   ;;:background "red"
  					)
  			;; 'face 'my-modeline-orange-font
  		)
  	)
  	"Mode line constructor to display major mode"
  )

  ;;
  ;; 'my-modeline-buffer-name' variable related
  ;;
  (defun my-get-current-name () 
  	(if (mode-line-window-selected-p)
  		(buffer-name)
  		(format " %s" (buffer-name))
  	)
  )

  (defvar-local my-modeline-buffer-name
  	'(:eval
  		 (propertize (my-get-current-name))
  	)
  	"Mode line constructor to display buffer name"
  )

  (defvar-local my-modeline-buffer-file-name
  	'(:eval
  		(propertize (format " %s" (buffer-file-name))))
  	"Mode line constructor to display buffer name"
  )

  ;;
  ;; 'my-modeline-evil-state' variable related
  ;;
  (defun my-get-evil-state()
  	"Return 'evil-state' as a string."
  	(format " %s  " (upcase (symbol-name evil-state))))

  (defvar-local my-modeline-evil-state
  	'(:eval
  		(when (mode-line-window-selected-p)
  			(propertize (my-get-evil-state)
  				'face '(:weight bold)
  			)
  		)
  	)
  	"Mode line constructor to display current evil state"
  )


  ;;
  ;; 'my-modeline-git-branch' variable related
  ;;
  (defun my-get-git-branch-name()
  	(format "%s %s" (nerd-icons-mdicon "nf-md-source_branch") (substring vc 5))
  )

  (defvar-local my-modeline-git-branch
  	'(:eval
  		(when (mode-line-window-selected-p)
  			(when-let (vc vc-mode)
  				(propertize (my-get-git-branch-name))
  			))
  	)
  )

  ;;
  ;; 'my-modeline-flymake' variable related
  ;;
  (declare-function flymake--severity "flymake" (type))
  (declare-function flymake-diagnostic-type "flymake" (diag))

  ;; Based on `flymake--mode-line-counter'.
  (defun prot-modeline-flymake-counter (type)
  	"Compute number of diagnostics in buffer with TYPE's severity.
  	TYPE is usually keyword `:error', `:warning' or `:note'."
  	(let ((count 0))
  		(dolist (d (flymake-diagnostics))
  		(when (= (flymake--severity type)
  				(flymake--severity (flymake-diagnostic-type d)))
  			(cl-incf count)))
  		(when (cl-plusp count)
  		(number-to-string count))))

  (defun my-get-lsp-error-indicator()
  	;; (insert (nerd-icons-octicon "nf-oct-bug"))  2
  	;; (insert (nerd-icons-codicon "nf-cod-bug"))  2
  	;; (insert (nerd-icons-faicon "nf-fa-bug"))    2
  	(nerd-icons-octicon "nf-oct-bug")
  )

  (defun my-modeline-flymake-error()
  	(when-let (count (prot-modeline-flymake-counter (intern ":error")))
  		(propertize
  			(format " %s %s" (my-get-lsp-error-indicator) count)
  		)
  	)
  )

  (defun my-get-lsp-warning-indicator()
  	;; (insert (nerd-icons-octicon "nf-oct-copilot_warning"))  2
  	;; (insert (nerd-icons-codicon "nf-cod-warning"))          2
  	;; (insert (nerd-icons-faicon "nf-fa-warning"))            2
  	(nerd-icons-faicon "nf-fa-warning")
  )

  (defun my-modeline-flymake-warning()
  	(when-let (count (prot-modeline-flymake-counter (intern ":warning")))
  		(propertize
  			(format " %s %s" (my-get-lsp-warning-indicator) count))
  	)
  )

  (defun my-get-lsp-note-indicator()
  	;; (insert (nerd-icons-faicon "nf-fa-exclamation"))          2
  	;; (insert (nerd-icons-mdicon "nf-md-exclamation_thick"))   󱈸 2
  	;; (insert (nerd-icons-faicon "nf-fa-exclamation_circle"))   2
  	(nerd-icons-faicon "nf-fa-exclamation_circle")
  )

  (defun my-modeline-flymake-note()
  	(when-let (count (prot-modeline-flymake-counter (intern ":note")))
  		(propertize
  			(format " %s %s" (my-get-lsp-note-indicator) count))
  	)
  )

  (defvar-local my-modeline-flymake
  	`(:eval
  	(when (and (bound-and-true-p flymake-mode)
  				(mode-line-window-selected-p))
  		(list
  		'(:eval (my-modeline-flymake-error))
  		'(:eval (my-modeline-flymake-warning))
  		'(:eval (my-modeline-flymake-note))
  		)))
  "Mode line construct displaying `flymake-mode-line-format'.
  Specific to the current window's mode line.")


  ;;
  ;; 'my-modeline-misc-info' variable related
  ;;
  (defvar-local my-modeline-misc-info
      '(:eval
        (when (mode-line-window-selected-p)
          mode-line-misc-info))
    "Mode line construct displaying `mode-line-misc-info'.
  Specific to the current window's mode line.")


  ;; -------------------------------------------------------------------------------
  ;; Keep that in mind: Each mode line variable (insdie the 'mode-line-format') must have
  ;; the 'risky-local-variable' property and set to 't'!!!
  ;; -------------------------------------------------------------------------------
  (dolist (my-var '(
  					my-modeline-major-mode
  					my-modeline-buffer-name
  					my-modeline-evil-state
  					my-modeline-git-branch
  					my-modeline-flymake
  					my-modeline-misc-info))
    (put my-var 'risky-local-variable t)
  )



  ;; -------------------------------------------------------------------------------
  ;;
  ;; Set the 'mode-line-format' as default value.
  ;;
  ;; - If you use 'setq' here, then it only applies to the current local buffer, but you see
  ;; the instant effects.
  ;;
  ;; - If you use 'setq-default' here, then it applies to all buffersc, but you can't see
  ;; the instant effects until re-launch Emacs.
  ;; -------------------------------------------------------------------------------
  (setq-default mode-line-format
  	'("%e"
  		my-modeline-evil-state
  		my-modeline-buffer-name
  		"  "
  		;;(:eval (format "MODE: %s" (propertize (symbol-name major-mode) 'face 'warning)))
  		my-modeline-major-mode
  		"  "
  		;; my-modeline-git-branch
  		;; "  "
  		my-modeline-flymake
  		"  "
  		my-modeline-misc-info
  	)
  )
#+END_SRC



*** How to customize font colors in Emacs

**** 1. Open a buffer in the =mode= that you want to change the color and run ~describe-face~ to get all current buffer =face= (font name) list. Also, you can get all result in a separate buffer by calling ~list-faces-display~.

**** 2. Choose the =face= name and press ~<return>~ then you see all the font and color settings in the new buffer.

**** 3. Change the =face= attribute settings for that particular =face=.

You can use ~(set-face-attribute FACE FRAME &rest ARGS)~ to change the given font attributes.

- If ~FRAME~ is a frame, set the FACE's attributes only for that frame.  If ~FRAME~ is =nil=, set attribute values for all existing frames, as well as the default for new frames.  If ~FRAME~ is =t=, change the default values of attributes for new frames.

- ~ARGS~ must come in pairs ATTRIBUTE VALUE.  ATTRIBUTE must be a valid face attribute name and VALUE must be a value that is valid for ATTRIBUTE, as described below for each attribute.

***** Eaxmple to set =org-level-1= heading color

    #+begin_src emacs-lisp :tangle no
      ;;
      ;; Transparent background color
      ;;
      (set-face-attribute 'org-level-1 nil :background nil)

      ;;
      ;; Background color
      ;;
      (set-face-attribute 'org-level-1 nil :background "olivedrab")

      ;;
      ;; Font color
      ;;
      (set-face-attribute 'org-level-1 nil :foreground "olivedrab")
    #+end_src


***** Example to set =show-paren-match= (matched parentheses) color

#+BEGIN_SRC emacs-lisp :tangle no
  (set-face-attribute 'show-paren-match nil
                      :background "#0a84ff"
                      :foreground "black"
                      :weight 'bold)

  ;;
  ;; After that, you can get back the attribute like below:
  ;;
  (internal-get-lisp-face-attribute 'show-paren-match :foreground)
  (internal-get-lisp-face-attribute 'show-paren-match :background)
#+END_SRC


***** Example to set default font color (but keep the background color doesn't change):

   #+begin_src emacs-lisp :tangle no
     (set-face-attribute 'default nil :foreground "#ACE6FE")
   #+end_src


**** 4. How to get the color string?

   Run ~list-color-display~, then pick name string:)


**** 5. Optional, show color as background on the color string

   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package rainbow-mode)
   #+END_SRC


*** Auto load theme

By default, Emacs only autoload the packages after processing the init file. So sometime when it was trying to load a theme, the theme package wasn't loaded!!!

That's why you better to load theme by using the ~after-init-hook~ to make sure your theme package has been loaded at that moment:)

#+BEGIN_SRC emacs-lisp
  (add-hook
  	'emacs-startup-hook
  	;; 'after-init-hook
  	(lambda ()
  		(let (
  				(theme 'ef-cyprus)
  				;; (theme 'ef-melissa-light)
  				;; (theme 'ef-melissa-dark)
  				;; (theme 'ef-elea-dark)
  				;; (theme 'ef-bio)
  				;; (theme 'ef-autumn)
  				;; (theme 'ef-rosa)
  				;; (theme 'doom-henna)
  				;; (theme 'doom-plain-dark)
  				;; (theme 'doom-plain)
  				;; (theme 'doom-nord)
  				;; (theme 'doom-nord-aurora)
  				;; (theme 'doom-lantern)
  				;; (theme 'doom-pine)
  				;; (theme 'doom-horizon)
  				;; (theme 'doom-zenburn)
  				;; (theme 'doom-old-hope)
  				;; (theme 'doom-laserwave)
  				;; (theme 'doom-monokai-pro)
  				;; (theme 'doom-gruvbox)
  				;; (theme 'my-tron-legacy)

  				;; (gui-theme 'nano)
  				(gui-theme 'nano-light)
  				;; (gui-theme 'nano-dark)
  			)

  			;; (consult-theme my-current-theme)
  			(if (display-graphic-p nil)
  				;;
  				;; GUI, load 'nano-light'
  				;;
  				(progn
  					(my-consult-theme gui-theme)
  					(message ">>> Loaded 'gui-theme': %s" gui-theme))

  				;;
  				;; TUI, load 'theme'
  				;;
  				(progn
  					(my-consult-theme theme)
  					(message ">>> Loaded 'tui-theme': %s" theme))
  			)

  		)
  	)
  )
#+END_SRC


** Minibuffer enable =rainbow-mode=

#+BEGIN_SRC emacs-lisp
  ;;
  ;; A company front-end with icons.
  ;;
  (use-package rainbow-mode
    :hook (minibuffer-setup . rainbow-mode))
#+END_SRC


** My personal modules/packages

*** Project command

#+BEGIN_SRC emacs-lisp
  ;;
  ;; Debug flag
  ;;
  (setq project-command-debug-enable nil)
  ;; (setq project-command-debug-enable t)

  ;;
  ;; Logger prefix
  ;;
  (setq project-command-logger-prefix ">>> [ Project command ] -")

  (defun project-command/create-script-files-cmd-list (dir)
  	"Return the script files command list from the given project directory"
  	(let (return_list '())
  		;; (message
  		;; 	"%s 'project_command/create_script_files_cmd_list' get called with %s"
  		;; 	PROJECT_COMMAND_LOGGER_PREFIX
  		;; 	dir)

  		;;
  		;; Filter the '.sh' file in 'dir'
  		;;
  		(setq filenames (directory-files dir))
  		(dolist (filename filenames)
  			(setq ext (url-file-extension filename))
  			;; (message "%s ext: %s" PROJECT_COMMAND_LOGGER_PREFIX ext)

  			(if (string-equal-ignore-case ext ".sh")
  				(progn
  					(add-to-list 'return_list (concat "./" filename) t)
  					;; (message
  					;; 	"%s filename: %s, ext: %s"
  					;; 	PROJECT_COMMAND_LOGGER_PREFIX
  					;; 	filename
  					;; 	ext)
  				))
  		)

  		;; Return the flatten list
  		(append return_list)
  	)
  )


  (defvar
  	project-command-hashmap
  	(make-hash-table :test 'equal)
  	" Project command hashmap:

  key: A string, the project root directory

  value: A 'plist' with the following properties:

  	'selected-cmd - Last cmd selected by the user
  	'cmd-list - Project cmd filename list
  ")


  (defun project-command/run (&optional enable-script-files)
  	"Run a prompt to choose a command inside the current project to run"
  	(let
  		(
  			(current-project-dir (project-root (project-current t)))
  			(current-project-value '()) ;; It's a 'plist'!!!
  			(current-project-cmd-list '()) ;; It's a normal string 'list'
  			(current-selected-cmd "")
  		)

  		;;
  		;; Get back the value by 'current-project-dir'
  		;;
  		(setq current-project-value
  			(gethash current-project-dir project-command-hashmap))

  		(if project-command-debug-enable
  			(message
  				"%s current-project-value: %s"
  				project-command-logger-prefix
  				current-project-value))

  		;;
  		;; Add init value if 'current-project-value' is 'nil'
  		;;
  		(if (not current-project-value)
  			(progn
  				;;
  				;; Prefill
  				;;
  				(if enable-script-files
  					(setq current-project-cmd-list
  						(project-command/create-script-files-cmd-list current-project-dir)))

  				;;
  				;; Add key-value pair to 'project-command-hashmap'
  				;;
  				(puthash
  					current-project-dir (list
  											'selected-cmd ""
  											'cmd-list current-project-cmd-list)
  					project-command-hashmap)

  				;;
  				;; Update 'current-project-value' after init
  				;;
  				(setq current-project-value
  					(gethash current-project-dir project-command-hashmap))


  				;;
  				;; Debug stuff
  				;;
  				(if project-command-debug-enable
  					(message
  						"%s current-project-value (after init): %s"
  						project-command-logger-prefix
  						current-project-value))))

  		;;
  		;; Take out the properties from 'current-project-value' (it's a 'plist')
  		;;
  		(setq current-selected-cmd (plist-get current-project-value 'selected-cmd))
  		(setq current-project-cmd-list (plist-get current-project-value 'cmd-list))

  		;;
  		;; Debug stuff
  		;;
  		(if project-command-debug-enable
  			(message
  				(concat
  					"%s {"
  					"\n\tproject-dir: %s"
  					"\n\tproject-selected-cmd: %s"
  					"\n\tproject-cmd-list: %s"
  					"\n}"
  					)
  				project-command-logger-prefix
  				current-project-dir
  				current-selected-cmd
  				current-project-cmd-list
  				))

  		;;
  		;; Show a prompt and set the user 'selected_cmd'
  		;;
  		(setq current-selected-cmd (completing-read
  			;;
  			;; The prompt
  			;;
  			"Project commands: "								

  			;;
  			;; List: can be either
  			;;
  			;; - A 'list' instance, e.g: (list "./configure.sh" "./run.sh" "./run-test.sh")
  			;; - A 'list' variable name, e.g: cmd-list
  			;; - A 'function': the function is solely responsible for performing completion; 'completion-read'
  			;;                 returns whatever this function returns. The function is called with three
  			;;                 arguments: 'string predicate nil'
  			;;
  			;;				   You can read more from 'Programmed completion':
  			;;				   https://www.gnu.org/software/emacs/manual/html_node/elisp/Programmed-Completion.html
  			;; 
  			current-project-cmd-list

  			;;
  			;; 'PREDICATE' function (not provided)
  			;;
  			nil

  			;;
  			;; 'REQUIRE-MATCH': input must match in the 'List'
  			;;
  			;; - t means that the user is not allowed to exit unless the input is (or
  			;;   completes to) an element of COLLECTION or is null.
  			;;
  			;; - nil means that the user can exit with any input.
  			;;
  			;; - confirm means that the user can exit with any input, but she needs
  			;;   to confirm her choice if the input is not an element of COLLECTION.
  			;;
  			'confirm

  			;;
  			;; 'INIT-INPUT': simulate you type in the input area
  			;;
  			nil

  			;;
  			;; 'HIST': History list (not provided)
  			;;
  			nil

  			;;
  			;; 'DEF': Default value, put it to the top position!!!
  			;;
  			current-selected-cmd
  		))
  		(if project-command-debug-enable
  			(message
  				"%s You selected the command: %s" 
  				project-command-logger-prefix
  				current-selected-cmd))

  		;;
  		;; If 'current-selected-cmd' is NOT empty, do the following steps
  		;;
  		(if (not (string-empty-p current-selected-cmd))
  			(progn
  				;;
  				;; add it to 'current-project-cmd-list' if it doesn't exists yet.
  				;;
  				(add-to-list 'current-project-cmd-list current-selected-cmd t)

  				;;
  				;; After that, update the 'current-project-value'
  				;;
  				(plist-put current-project-value 'selected-cmd current-selected-cmd)
  				(plist-put current-project-value 'cmd-list current-project-cmd-list)

  				;;
  				;; And put it back to the 'project-command-hashmap'!!!
  				;;
  				(puthash
  					current-project-dir
  					current-project-value
  					project-command-hashmap)

  				;;
  				;; Finally, call the 'compile' on the 'current-selected-cmd'!!!
  				;;
  				(let ((default-directory current-project-dir)
  						(compilation-buffer-name-function
  						(or project-compilation-buffer-name-function
  							compilation-buffer-name-function)))
  					(compile current-selected-cmd))

  				))

  	)
  )

  ;;
  ;;
  ;;
  (defun project-command/run-with-enable-script-files ()
  	"Run a prompt to choose a command to run. It calls 'project_command/run' internally and passes 't' to
  it by default, which means pre-filling all scripts '*.sh' into the command list. You can set it to 'nil'
  if you don't want to do this..

  Also, inside the pop-up command list UI, you can type a new command that doesn't exist in the pre-filled
  command list; it will be added to the command list after your confirmation.

  After pressing 'RET' to run the selected command, a reused buffer will be shown int the right side window
  (always) to present the command's output.

  If there is an error inside the output buffer, you can jump to the error line and press 'RET'; it will
  bring you to the source and automatically locate the error position.

  By defualt, the output buffer doesn't scroll to the bottom for you. If you want this, you can set the
  'compilation-scroll-output' global variable to 't'"
  	(interactive)
  	(project-command/run t)
  )
#+END_SRC



*** My modified =consult-ripgrep= related

I prefer to disable the grouping feature in ~consult-ripgrep~ buffer:

#+BEGIN_SRC emacs-lisp
 (consult-customize consult-ripgrep :group nil)
#+END_SRC

But this doesn't work if you call ~consult-ripgrep~ programmatically!!!

That's why I copied the ~consult-ripgrep~ and ~consult--grep~ source code to make my own version by adding the ~:group nil~ !!!


#+BEGIN_SRC emacs-lisp
  ;;
  ;; My version of 'consult--grep' to disable the grouping feature
  ;;
  (defun my-consult--grep (prompt make-builder dir initial)
  	"My version of 'consult--grep' to disable the group feature"
  	(pcase-let* ((`(,prompt ,paths ,dir) (consult--directory-prompt prompt dir))
  				(default-directory dir)
  				(builder (funcall make-builder paths)))
  		(consult--read
  			(consult--process-collection builder
  			:transform (consult--grep-format builder)
  			:file-handler t)
  			:prompt prompt
  			:lookup #'consult--lookup-member
  			:state (consult--grep-state)
  			:initial initial
  			:add-history (thing-at-point 'symbol)
  			:require-match t
  			:category 'consult-grep

  			;;
  			;; This is the key setting to disable the grouping feature in the ripgrep result minibuffer!!!
  			;;
  			:group nil

  			:history '(:input consult--grep-history)
  			:sort nil
  		)
  	)
  )

  ;;
  ;; My version of 'consult-ripgrep' to call 'my-consult--grep'
  ;;
  (defun my-consult-ripgrep (&optional dir initial)
  	"My version of 'consult-ripgrep' to call 'my-consult--grep'"
  	(interactive "P")
  	(my-consult--grep "Ripgrep" #'consult--ripgrep-make-builder dir initial)
  )
#+END_SRC


*** Coding assistant

90% time of my time when I'm dealing with LSP is focused  on two functionalities:

- ~gd~: Go to definition.
- ~K~: Have a pick on the function signature.

So, I prefer to build my own =Coding Assistant= instead of dealing with the LSP (both server and client), as LSP is somewhat slow in =Emacs=.

Basically, how =Go to definition= works is very simple:

You can run ~Ripgrep~ with the function name under the cursor on the given directories, then you have two ways to handle the ~Rigprep~ result:

- You got a single line result:

  For this case, just open the source file into a new/existing buffer and go to the specific line.


- You got a multiple lines result:

  For this case, run ~completing-read~ or ~consult-read~ to show up list in minubuffer, then you can choose which file to open


Here is my implementation:

#+BEGIN_SRC emacs-lisp
  ;;
  ;; Enable debug log flag
  ;;
  ;; (setq my-enable-ca-debug-log t)
  (setq my-enable-ca-debug-log nil)

  (defun my-rg-search-sync (directory search-regex)
  	"Run 'rg' with 'search-regex' on 'directory' in a separate process synchronously. This function
  returns a list containing two elements in the following difference cases:

  - If 'rg' runs successfully, the first element is the 'success symbol and the second element is the
  process stdout string.

  - If 'rg' runs but fails with error, the first element is the 'fail symbol and the second element is
  the process stdout string (as error).

  - If 'rg' fails to run, the first element is the 'error symbol and the second element is the error
  message string.
  "
  	(let* (
  			(process-self)
  			(process-name (concat "rg-search-" (format-time-string "%s")))
  			(process-buffer-name (concat "*-" process-name "-*"))
  			(process-exit-code)
  			(stdout)
  		)

  		(if my-enable-ca-debug-log
  			(progn
  				(message (concat
  							">>> [ my-rg-search-sync ] - {"
  							"\n\tdirectory: %s"
  							"\n\tsearch-regex: %s"
  							"\n\tprocess-buffer-name: %s"
  							"\n}"
  					)
  					directory
  					search-regex
  					process-buffer-name))
  		)

  		(condition-case err
  			(progn
  				(setq
  					process-self
  					(make-process
  						;;
  						;; Unique process name 'rg-search-CURRENT_TIME_IN_SECONDS'
  						;;
  						:name process-name

  						;;
  						;; 'nil' means that this process is not associated with any buffer.
  						;; can be a 'Buffer' or a buffer name string
  						;;
  						:buffer process-buffer-name

  						;;
  						;; Command list: (program-file-name args)
  						;;
  						:command (list
  									"rg"
  									"--line-number"
  									"--line-buffered"
  									"--no-heading"
  									"--with-filename"
  									"--color=never"
  									"--path-separator=/"
  									"--smart-case"
  									search-regex
  									directory
  								)

  						;;
  						;; Use this 'sentinel' setting to avoid adding the 'Process xxx yyy' final
  						;; to the process's buffer!!!
  						;;
  						:sentinel #'ignore
  					))

  				;;
  				;; Wait for it to finish
  				;;
  				(while (process-live-p process-self)
  					(accept-process-output process-self 0.05))

  				;;
  				;; Check exit code
  				;;
  				(setq process-exit-code (process-exit-status process-self))
  				(if my-enable-ca-debug-log
  					(message ">>> [ my-rg-search-sync ] - process-exit-code: %s" process-exit-code))

  				;;
  				;; Return different results based on the 'exit' code
  				;;
  				(cond
  					((equal process-exit-code 0)
  						(with-current-buffer (process-buffer process-self)
  							(setq stdout (buffer-string)))
  						;;
  						;; It's very important to kill the process' buffer, otherwise, it has a chance
  						;; to overlap the previous buffer's content!!!
  						;;
  						(kill-buffer (process-buffer process-self))
  						;; Return the list
  						(list 'success stdout))
  					(t
  						(with-current-buffer (process-buffer process-self)
  							(setq stdout (buffer-string)))
  						;;
  						;; It's very important to kill the process' buffer, otherwise, it has a chance
  						;; to overlap the previous buffer's content!!!
  						;;
  						(kill-buffer (process-buffer process-self))
  						;; Return the list
  						(list 'fail stdout))
  				)
  			)

  			(file-missing
  				(if my-enable-ca-debug-log
  					(message ">>> [ my-rg-search-sync ] - error: %s" err))
  				(list 'error err)
  			)
  			(error
  				(if my-enable-ca-debug-log
  					(message ">>> [ my-rg-search-sync ] - catch everthing: %s" err))
  				(list 'error err)
  			)
  		)
  	)
  )

  (defun my-rg-search-on-multiple-directories (directory-list search-regex)
  	"Call 'my-rg-search-sync' with each directory inside the 'directory-list' and return a list
  lines, which containing the format: 'full-path-filename:line-no:source-code'"
  	(interactive)
  	(let (
  			 (search-result nil) ;; Holds each 'my-rg-search-sync' result
  			 (lines nil)
  			 (result-list nil)
  		)
  		(dolist (dir directory-list)
  			(setf search-result nil)
  			(setq search-result (my-rg-search-sync dir search-regex))
  			;; (message ">>> search-result: %s" search-result)

  			(if (and (string= (type-of search-result) "cons") (equal (length search-result) 2))
  				(let (
  						(result-type (car search-result))
  						(output (car (cdr search-result)))
  					)
  					;; (message ">>> result-type: %s" result-type)
  					;; (message ">>> output type: %s, value: %s" (type-of output) output)

  					(if (eq result-type 'success)
  						(progn
  							;; Separated by '\n' and remove the empty lines
  							(setq lines (string-split output "\n" t))
  							;; Flatten the 'result-list' and 'lines' into a single list
  							(setq result-list (append result-list lines))))
  				)
  			)
  		)

  		;; Return value
  		result-list
  	)
  )


  (defun my-ca-go-to-definition ()
  	"My code-assistant: Go to function definition that is under the cursor position"
  	(interactive)
  	(let* (
  			;;
  			;; Get function name from cursor position
  			;;
  			(function-name (thing-at-point 'symbol t))

  			;;
  			;; Get back the 'rg' search directories based on current major mode, the search order
  			;; is important!!!
  			;;
  			(directories
  				(cond
  					((eq major-mode 'odin-ts-mode)
  						(list
  							(expand-file-name (project-root (project-current t)))
  							(expand-file-name "./odin/odin-utils" (getenv "HOME"))
  							(getenv "ODIN_ROOT")))
  					((eq major-mode 'c-ts-mode)
  						(cond
  							((eq system-type 'darwin)
  								(list
  									(expand-file-name (project-root (project-current t)))
  									(expand-file-name "./c/c-utils" (getenv "HOME"))
  									"/usr/include"))
  							((eq system-type 'berkeley-unix)
  								(list
  									(expand-file-name (project-root (project-current t)))
  									(expand-file-name "./c/c-utils" (getenv "HOME"))
  									"/usr/include"))
  							((eq system-type 'gnu/linux)
  								(list
  									(expand-file-name (project-root (project-current t)))
  									(expand-file-name "./c/c-utils" (getenv "HOME"))
  									"/usr/include"))))
  				)
  			)

  			;;
  			;; Regex rules:
  			;; - Start from the beggin of line
  			;; - Before the function name, can be 0 or more 'space' or 'TAB' characters
  			;; - After the function name, can be 0 or more 'space' or 'TAB' characters before '::'
  			;;
  			(search-regex (concat "^[ \t]*" function-name "[ \t]*:: "))

  			;;
  			;; The final 'rg' lines
  			;;
  			(result-lines nil)
  		)

  		(if my-enable-ca-debug-log
  			(progn
  				(message
  					(concat
  						">>> [ my-ca-go-to-definition ] - {"
  						"\n\tfunction-name: %s"
  						"\n\tsearch-regex: %s"
  						"\n\tdirectories: %s"
  						"\n}")
  					function-name
  					search-regex
  					directories)))

  		;;
  		;; Get back all 'rg' result lines
  		;;
  		(setq result-lines
  			(my-rg-search-on-multiple-directories
  				directories
  				search-regex))

  		(if my-enable-ca-debug-log
  			(progn
  				(message ">>> resu lt-lines len: %s" (length result-lines))
  				(dolist (line result-lines)
  					(message ">>> line: %s" line))
  				))

  		(cond
  			;;
  			;; If got a single line, then open source code and go to that line no
  			;;
  			((= (length result-lines) 1)
  				(let ((temp-list (string-split (car result-lines) ":" t)))
  					(if (>= (length temp-list) 2)
  						(progn
  							;; Push the current position into xref history
  							(xref-push-marker-stack)

  							;; Jump to file and line
  							(with-current-buffer (find-file (car temp-list))
  								;; (message ">>> go to line: %s" (car (cdr temp-list)))
  								(goto-line (string-to-number (car (cdr temp-list))))
  								(evil-scroll-line-to-center nil)
  							)))
  				))
  			;;
  			;; If got more than one line, show in minibuffer and ask user to pick one
  			;;
  			((> (length result-lines) 1)
  				(setq selected-line (completing-read
  					;;
  					;; The prompt
  					;;
  					"Go to definition: "

  					;;
  					;; List: can be either
  					;;
  					result-lines

  					;;
  					;; 'PREDICATE' function (not provided)
  					;;
  					nil

  					;;
  					;; 'REQUIRE-MATCH': input must match in the 'List'
  					;;
  					t

  					;;
  					;; 'INIT-INPUT': simulate you type in the input area
  					;;
  					nil

  					;;
  					;; 'HIST': History list (not provided)
  					;;
  					nil

  					;;
  					;; 'DEF': Default value, put it to the top position!!!
  					;;
  					nil
  				))
  				;; (message ">>> selected-line: %s" selected-line)

  				(let ((temp-list (string-split selected-line ":" t)))
  					(if (>= (length temp-list) 2)
  						(progn
  							;; Push the current position into xref history
  							(xref-push-marker-stack)

  							;; Jump to file and line
  							(with-current-buffer (find-file (car temp-list))
  								;; (message ">>> go to line: %s" (car (cdr temp-list)))
  								(goto-line (string-to-number (car (cdr temp-list))))
  								(evil-scroll-line-to-center nil)
  							)))
  				)
  			)
  		)
  	)
  )
#+END_SRC


*** Run ~gemini-cli~ on selected text

#+BEGIN_SRC emacs-lisp
  ;;
  ;; Gemini search debugging flag
  ;;
  (setq my-enable-gemini-debug-log t)

  ;;
  ;; This is the ':sentinel' function that will be passed into 'make-process'.
  ;;
  ;; A “process sentinel” is a function that is called whenever the associated process changes status
  ;; for any reason, including signals (whether sent by Emacs or caused by the process's own actions)
  ;; that terminate, stop, or continue the process.
  ;;
  ;; The process sentinel is also called if the process exits. The sentinel receives two arguments:
  ;; - Process itself
  ;; - A string describing the type of event.
  ;;
  ;; The string describing the event looks like one of the following (but this is
  ;; not an exhaustive list of event strings):
  ;;
  ;; • ‘"finished\n"’.
  ;;
  ;; • ‘"deleted\n"’.
  ;;
  ;; • ‘"exited abnormally with code EXITCODE (core dumped)\n"’.  The
  ;;   "core dumped" part is optional, and only appears if the process
  ;;   dumped core.
  ;;
  ;; • ‘"failed with code FAIL-CODE\n"’.
  ;;
  ;; • ‘"SIGNAL-DESCRIPTION (core dumped)\n"’.  The SIGNAL-DESCRIPTION is
  ;;   a system-dependent textual description of a signal, e.g.,
  ;;   ‘"killed"’ for ‘SIGKILL’.  The "core dumped" part is optional, and
  ;;   only appears if the process dumped core.
  ;;
  ;; • ‘"open from HOST-NAME\n"’.
  ;;
  ;; • ‘"open\n"’.
  ;;
  ;; • ‘"run\n"’.
  ;;
  ;; • ‘"connection broken by remote peer\n"’.
  ;;
  (defun my-gemini-search-sentinel (self event)
  	(let (
  			(output-file (process-get self 'output-file))
  			(self-buffer (process-buffer self))
  		)

  		(if my-enable-gemini-debug-log
  			(message
  				">>> [ my-gemini-search-sentinel ] - process-event: %s, output-file: %s"
  				event
  				output-file))

  		;;
  		;; Succeed case: Open the output file buffer
  		;;
  		(when (string= event "finished\n")
  			(find-file-noselect output-file)
  			(pop-to-buffer
  				(get-buffer (file-name-nondirectory output-file))
  				'(
  					(display-buffer-reuse-window display-buffer-in-side-window)
  					(side . right)
  					(inhibit-same-window . t)
  				)
  			)
  		)

  		;;
  		;; Error case: open the output file buffer and write the stdout (error message) to that buffer
  		;;
  		(when (or (string-match-p "exited" event) (string-match-p "failed" event))
  			(find-file-noselect output-file)

  			(with-current-buffer (get-buffer (file-name-nondirectory output-file))
  				(erase-buffer)
  				(beginning-of-buffer)
  				;; (insert "Erorr happend.")
  				(insert-buffer-substring (get-buffer self-buffer))
  			)

  			(pop-to-buffer
  				(get-buffer (file-name-nondirectory output-file))
  				'(
  					(display-buffer-reuse-window display-buffer-in-side-window)
  					(side . right)
  					(inhibit-same-window . t)
  				)
  			)
  		)

  		;;
  		;; Make sure to clean up the temporary process buffer
  		;;
  		(when (or (string= event "finished\n") (string-match-p "exited" event))
  			(if my-enable-gemini-debug-log
  				(message ">>> [ my-gemini-search-sentinel ] - kill temp process buffer: %s" self-buffer))
  			(kill-buffer self-buffer)
  		)
  	)
  )

  (defun my-gemini-search (prompt-text)
  	"Run 'gemini' CLI with the given 'prompt-text' and save output into '~/.config/emacs/gemini-output.org'.

  You need to save the following content into '~/.config/emacs/GEMINI.md' to guarantee that GEMINI always
  responds in 'org' format:

  ```markdown
  # Project: This is my emacs configuration

  ## Response format

  - Make sure all responses text use emacs `org` format, then I can copy and paste the response text into emacs.
  ```
  "
  	(let* (
  			(process-self)
  			(process-name (concat "rg-search-" (format-time-string "%s")))
  			(process-buffer-name (concat "*-" process-name "-*"))
  			(output-file (expand-file-name ".config/emacs/gemini-output.org" (getenv "HOME")))

  			;;
  			;; 'cd' into the emacs configuration folder can make sure 'gemini' reads the 'GEMINI.md'!!!
  			;;
  			(command-list (list
  							"sh"
  							"-c"
  							(concat
  								"cd ~/.config/emacs && gemini "
  								"--prompt \""
  								prompt-text
  								" \" > "
  								output-file)))
  		)

  		(if my-enable-gemini-debug-log
  			(message (concat
  						">>> [ my-gemini-search ] - {"
  						"\n\tprompt-text: %s"
  						"\n\toutput-file: %s"
  						"\n\tprocess-buffer-name: %s"
  						"\n\tcommand-list: %s"
  						"\n}"
  				)
  				prompt-text
  				output-file
  				process-buffer-name
  				command-list))

  		(condition-case err
  			(progn
  				(setq
  					process-self
  					(make-process
  						;;
  						;; Unique process name 'my-gemini-search-CURRENT_TIME_IN_SECONDS'
  						;;
  						:name process-name

  						;;
  						;; 'nil' means that this process is not associated with any buffer.
  						;; can be a 'Buffer' or a buffer name string
  						;;
  						:buffer process-buffer-name

  						;;
  						;; Command list: (program-file-name args)
  						;;
  						:command command-list

  						;;
  						;;
  						;;
  						:sentinel #'my-gemini-search-sentinel))
  				;;
  				;; Put the 'output-file' into 'process-ref' properties, otherwise, you can't access
  				;; 'output-file' in the ':sentinel' function, as they're runing different process
  				;; instances!!!
  				;;
  				(process-put process-self 'output-file output-file)
  			)

  			(file-missing
  				(if my-enable-gemini-debug-log
  					(message ">>> [ my-gemini-search ] - error: %s" err))
  			)
  			(error
  				(if my-enable-gemini-debug-log
  					(message ">>> [ my-gemini-search ] - catch everthing: %s" err))
  			)
  		)
  	)
  )

  (defun my-gemini-search-on-selected-text ()
  	"Run 'gemini' CLI on the selected text as 'prompt-text' and save 'org' formatted output into
  '~/.config/emacs/gemini-output.org'.

  You need to save the following content into '~/.config/emacs/GEMINI.md' to guarantee that GEMINI always
  responds in 'org' format:

  ```markdown
  # Project: This is my emacs configuration

  ## Response format

  - Make sure all responses text use emacs `org` format, then I can copy and paste the response text into emacs.
  ```
  "
  	(interactive)
  	(let (
  			 (selected-text "")
  		)
  		(when (use-region-p)
  			(setq selected-text
  				(buffer-substring-no-properties (region-beginning) (region-end))))

  		(if my-enable-gemini-debug-log
  				(message ">>> [ my-gemini-search-on-selected-text ] - selected-text: %s" selected-text))

  		(if (not (string-empty-p selected-text))
  			(progn
  				(if my-enable-gemini-debug-log
  					(message ">>> [ my-gemini-search-on-selected-text ] - running 'my-gemini-search' on selected-text......"))
  				(my-gemini-search selected-text)
  			))
  	)
  )
#+END_SRC


** My keybindgins

1. About =Evil state=

    =Evil mode= has the following =state keymaps= you can used to set your own keybindings:

    + evil-insert-state-map
    + evil-emacs-state-map
    + evil-normal-state-map
    + evil-visual-state-map
    + evil-motion-state-map
    + evil-operator-state-map
    + evil-outer-text-objects-map
    + evil-inner-text-objects-map
    + evil-replace-state-map
    + evil-normal-state-local-map

    The main reason =motion= state exists is for use with =read-only= modes where insertion keybindings aren’t useful. 

    If you bind key to =montion= state, that means you bind the key to =normal, visual and operator= state as well. That's quite convenient to save a lot of bindings!!!

*** Control whether enable =which-key= customize description or not

By default, =which-key= only show the function name with the keybindings like below:

#+BEGIN_SRC
 b → consult-buffer 
 o → +prefix
#+END_SRC

That's fine but not very convenient, as I might forget what the ~o~ prefix means. By using the following settings:

#+BEGIN_SRC emacs-lisp :tangle no
  (which-key-add-key-based-replacements "b" "Switch to buffer")
  (which-key-add-key-based-replacements "o" "(Quick) Open...")
#+END_SRC

Then I got a better =which-key= list like this:

#+BEGIN_SRC
 b → Switch to buffer
 o → (Quick) Open...
#+END_SRC


That means I need to write a lot of ~(which-key-add-key-based-replacements)~ function calls for all of my keybindings, but what if I don't need that (or I prefer to switch back to the original function name display style)? So, for a better choice, I add a global variable ~my-enable-which-key-customized-description~ to enable or disbale that feature just by setting it to ~t~ or ~nil~:

#+BEGIN_SRC emacs-lisp
  ;;
  ;; Enable
  ;;
  (setq my-enable-which-key-customized-description t)

  ;;
  ;; Disable
  ;;
  ;; (setq my-enable-which-key-customized-description nil)
#+END_SRC


*** =ESC= acts like ~C-g~

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)
#+END_SRC


*** Disable ~C-z~

By default, evil binds the ~C-z~ to toggle between =evil-state= and =emacs-state=, but I don't need that.

#+BEGIN_SRC emacs-lisp
  (dolist (map (list
                evil-insert-state-map
                evil-motion-state-map
                ))
      (keymap-set map "C-z" nil)
  )
#+END_SRC


*** Disable ~C-j~ and ~C-k~ 

Disable ~C-j~ and ~C-k~ from the following modes

#+BEGIN_SRC emacs-lisp
  (dolist (map (list
                global-map
                evil-window-map
                evil-normal-state-map
                evil-motion-state-map
                ))
      (keymap-set map "C-j" nil)
      (keymap-set map "C-k" nil)
      ;;(message "State: %s" state);
  )
#+END_SRC


*** Fix =error: Key sequence SPC X starts with non-prefix key SPC=

#+BEGIN_SRC emacs-lisp
  (keymap-set evil-motion-state-map "<SPC>" nil)
#+END_SRC



*** Save buffer by ~W~

#+BEGIN_SRC emacs-lisp
  (dolist (map (list
                evil-motion-state-map
                ))
    (keymap-set map "W" 'save-buffer)
  )

  (if my-enable-which-key-customized-description
      (progn
          (which-key-add-key-based-replacements "W" "Save")
      ))
#+END_SRC


*** Go back to normal mode by ~jj~

#+BEGIN_SRC emacs-lisp
  (defun my-jj-to-escape ()
  	(interactive)
  	(if (memq evil-state '(insert replace))
  	    (let ((changed? (buffer-modified-p)))
  	        (insert "j")
  	        (let* ((tm (current-time))
  	            (ch (read-key)))
  	        (if (and (eq ch ?j)
  	                (< (time-to-seconds (time-since tm)) 0.3))
  	            (save-excursion
  	                (delete-char -1)
  	                (evil-force-normal-state)
  	                (set-buffer-modified-p changed?))
  	            (insert ch))))
  		(call-interactively 'evil-next-line)
  	)
  )

  (keymap-set evil-insert-state-map  "j" 'my-jj-to-escape)
  (keymap-set evil-replace-state-map "j" 'my-jj-to-escape)
#+END_SRC


*** Move to beginning and ending of the line by ~H~ and ~L~

#+BEGIN_SRC emacs-lisp
  (dolist (map (list
                evil-motion-state-map
                ))
    (keymap-set map "H" 'evil-first-non-blank)
    (keymap-set map "L" 'evil-end-of-line)
    ;;(message "State: %s" state);
  )
#+END_SRC


*** Improve ~n~ and ~N~ search

#+begin_src emacs-lisp
  ;;
  ;; Unbind 'n' and 'N'
  ;;
  (keymap-set evil-motion-state-map "n" nil)
  (keymap-set evil-motion-state-map "N" nil)

  (defun my-search-next()
  	(interactive)
  	(evil-search-next)
  	(evil-scroll-line-to-center nil)
  )

  (defun my-search-previous()
  	(interactive)
  	(evil-search-previous)
  	(evil-scroll-line-to-center nil)
  )

  (keymap-set evil-motion-state-map "n" 'my-search-next)
  (keymap-set evil-motion-state-map "N" 'my-search-previous)
#+end_src


*** Go back to last marked position by ~gb~

I can't call ~evil-set-mark~ in my custom function, as it calls ~read-char~ when the function runs, so I can't pass a char in that way.

As a workaround, I can use the default evil keybinding =m= to set a =M= to current position, MAKE SURE that's an uppercase =M=, otherwise, you can go back if you jump to another buffer!!!

#+BEGIN_SRC emacs-lisp
  (defun my-goto-last-marked-position()
  	(interactive)
  	(evil-goto-mark ?m)
  )

  (dolist (map (list
                evil-motion-state-map
                ))
      (keymap-set map "g b" 'my-goto-last-marked-position)
  )

  (if my-enable-which-key-customized-description
      (progn
          (which-key-add-key-based-replacements "gb" "Go back")
      ))
#+END_SRC


*** Search and replace cursor word by ~C-s~ 

#+BEGIN_SRC emacs-lisp
  ;;
  ;; Unbind the default <C-s> for 'isearch-forward'
  ;;
  (keymap-set global-map "C-s" nil)

  ;;
  ;; Replace current word or selection using vim style for evil mode
  ;;
  (defun my-replace-word-under-curor ()
  	(interactive)
  	(if (use-region-p)
  	    (let ((selection (buffer-substring-no-properties (region-beginning) (region-end))))
  	        (if (= (length selection) 0)
  	            (message "empty string")
  	            (evil-ex (concat "'<,'>s/" selection "/"))
  	        )
  	    )
  	    (evil-ex (concat "%s/" (thing-at-point 'word) "/"))
  	)
  )

  ;;
  ;; Rebind <C-s>
  ;;
  (keymap-set evil-motion-state-map "C-s" 'my-replace-word-under-curor)
#+END_SRC


*** Window movement by ~C-h, C-l~

This is only for jumping between left and right windows, for jumping between up and down windows, I prefer to use the default bindings: ~C-w j~ and ~C-w k~.

#+BEGIN_SRC emacs-lisp
  (dolist (map (list
                evil-motion-state-map
                ))
    (keymap-set map "C-l" 'evil-window-right)
    (keymap-set map "C-h" 'evil-window-left)
    ;;(message "State: %s" state);
  )
#+END_SRC


*** Vertico completion jump between candidates by ~C-j~ and ~C-k~

#+BEGIN_SRC emacs-lisp
  (dolist (map (list
                vertico-map
                ))
  	(keymap-set map "C-j" 'vertico-next)
  	(keymap-set map "C-k" 'vertico-previous)
  )
#+END_SRC


*** Evil command line state: command history by ~<C-j>~ and ~<C-k>~

#+BEGIN_SRC emacs-lisp
  ;;
  ;; In command state, <C-j> and <C-k> to cycle command history
  ;;
  (keymap-set evil-command-line-map "C-j" 'next-history-element)
  (keymap-set evil-command-line-map "C-k" 'previous-history-element)
#+END_SRC

**** Here is something that I still don't figure out how to make it happen!!!

I hope that in the =command-line= state (~:~)

- When I type part of the command, then press ~<TAB>~, it shows a completion list pop up buffer
- Then, I can ~<C-j>~ and ~<C-k>~ to cycle through the candidates in the complection list
- when I press ~<RET>~, it accept the current candidate command and run it. 

And I tried the following settings:

#+BEGIN_SRC emacs-lisp :tangle no
  ;;
  ;; 'completion-list-mode': <C-j> and <C-k> to cycle the candidates via
  ;; 'completion-list-mode-hook'
  ;;
  (defun my-accept-completion-and-exit()
  	(interactive)
  	(minibuffer-choose-completion)
  	(exit-minibuffer)
  )

  (defun completion-list-mode-cycle-candidates-via-hook()
  	(keymap-set evil-command-line-map "C-j" 'minibuffer-next-completion)
  	(keymap-set evil-command-line-map "C-k" 'minibuffer-previous-completion)
  	(keymap-set evil-command-line-map "RET" 'my-accept-completion-and-exit)
  	(message ">>> bind <C-j>, <C-k> to 'completion-list-mode' to cycle the candidates")
  )

  ;;
  ;; Add the bind function to 
  ;;
  (add-hook 'completion-list-mode-hook #'completion-list-mode-cycle-candidates-via-hook)
#+END_SRC


It works as expected BUT overrides =Evil command line state: command history by ~<C-j>~ and ~<C-k>~ !!!=




*** Rebind all my common bindings to the local buffer-scope for different modes.

**** Why you need do in this way?

Usually, if your bindings are set to =evil-motion-state-map= (which covers =Normal/Motion/Visual= evil states), they should work for most situtations.

But for some particular modes or installed packages, their original bindings are on top of the ~evil-motion-state-minor-mode~ keymap!!!

For example, if you run ~describe-bindings~ in the =org-mode= buffer, you will see the following keymap orders:

#+BEGIN_SRC emacs-lisp :tangle no
  ▶  Key translations:...
  ▶  `evil-normal-state-local-minor-mode' Minor Mode Bindings:... // 'evil-normal-state-local-map' is alway on the most top!!!
  ▶  `evil-commentary-mode' Minor Mode Bindings:...               // Your installed packages mode map
  ▶  `evil-collection-unimpaired-mode' Minor Mode Bindings:...    //
  ▶  `t' Minor Mode Bindings:...                                  // Don't know what mode map
  ▶  `evil-normal-state-minor-mode' Minor Mode Bindings:...       // 'evil-normal-state-map' Your bindings!!!
  ▶  `evil-collection-unimpaired-mode' Minor Mode Bindings:...    //
  ▶  `evil-motion-state-minor-mode' Minor Mode Bindings:...       // 'evil-motion-state-map' Your bindings!!!
  ▶  `evil-commentary-mode' Minor Mode Bindings:...               // Your installed packages mode map
  ▶  `evil-surround-mode' Minor Mode Bindings:...                 // Your installed packages mode map
  ▶  `evil-collection-unimpaired-mode' Minor Mode Bindings:...    //
  ▶  `org-mode' Major Mode Bindings:...                           // The particular mode map: 'org-mode-map'
  ▶  Global Bindings:...                                          // 'global-map'
#+END_SRC


That's why sometimes your bindings will be overwritten by the default bindings from another installed package or emacs modes.
you still need to rebind all of them to the given modes' local buffer-scope to make sure to override the packages' level bindings IF you want your ~<leader>X~ bindings work on that mode!!!

To solve this issue, the more practical way to set your own bindings is to follow these rules:

#+BEGIN_SRC emacs-lisp :tangle no
  ;;
  ;; Group all the common bindings that are supposed to be shared between different modes.
  ;;
  (defun my-common-bindings (mode-map)
  	(keymap-set mode-map "KEY" 'xxx)
  	(keymap-set mode-map "KEY" 'yyy)

  	;; (evil-local-set-key 'motion (kbd "w") 'xxx)
  	;; (evil-local-set-key 'motion (kbd "w") 'yyy)

  	;; Ignore the rest
  )

  ;;
  ;; Then, have another separate binding only for the particular mode.
  ;;
  (defun my-xxx-mode-bindings (mode-map)
  	(keymap-set mode-map "KEY" 'aaa)
  	(keymap-set mode-map "KEY" 'bbb)

  	;; (evil-local-set-key 'motion (kbd "w") 'aaa)
  	;; (evil-local-set-key 'motion (kbd "w") 'bbb)

  	;; Ignore the rest
  )

  ;;
  ;; Now, this is the function will be called when the 'xxx-mode' is available.
  ;;
  ;; Inside this function, you should call the above 2 functions with the
  ;; 'evil-normal-state-local-map' to make sure your bindings are on the most top priority
  ;; in the bindings order that you've saw in the above example!!!
  ;;
  (defun my-xxx-mode-local-bindings ()
  	;;
  	;; Common bindings first
  	;;
  	(my-common-bindings evil-normal-state-local-map)

  	;;
  	;; And follow the particular mode, just in case your mode-related binding needs to
  	;; overwrite the common one!!!
  	;;
  	(my-xxx-mode-bindings evil-normal-state-local-map)
  )

  ;;
  ;; Now, bind 'my-xxx-mode-local-bindings' to 'xxx-mode-hook'
  ;;
  (add-hook 'xxx-mode-hook #'my-xxx-mode-local-bindings)
#+END_SRC




**** Utils functions that used in ~my-common-bindings~

#+BEGIN_SRC emacs-lisp
  ;; ----------------------------------------------------------------------------
  ;; Buffer related
  ;; ----------------------------------------------------------------------------
  (defun my-switch-to-last-buffer ()
  	(interactive)
  	(switch-to-buffer nil)
  )

  ;; ----------------------------------------------------------------------------
  ;; Window resizing related
  ;; ----------------------------------------------------------------------------
  (defun my-increase-window-width ()
  	(interactive)
  	(evil-window-increase-width 5)
  )

  (defun my-decrease-window-width ()
  	(interactive)
  	(evil-window-increase-width -5)
  )

  (defun my-increase-window-height ()
  	(interactive)
  	(evil-window-increase-height 5)
  )

  (defun my-decrease-window-height ()
  	(interactive)
  	(evil-window-increase-height -5)
  )

  ;; ----------------------------------------------------------------------------
  ;; Quick open related
  ;; ----------------------------------------------------------------------------
  (defun my-open-emacs-configuration ()
  	(interactive)
  	(find-file "~/.config/emacs/configuration.org")
  )

  ;; (defun my-open-lisp-quick-tutorial ()
  ;;    (interactivep)
  ;;    (find-file "~/.config/emacs/lisp-quick-tutorial.org")
  ;; )

  (defun my-open-todo-list ()
  	(interactive)
  	(find-file "~/.config/emacs/todo.org")
  )

  (defun my-open-lisp-quick-manual ()
  	(interactive)
  	(find-file "~/.config/emacs/lisp-quick-tutorial.org")
  )

  (defun my-open-snippet-folder ()
  	(interactive)
  	(find-file "~/.config/emacs/snippets")
  )

  ;; ----------------------------------------------------------------------------
  ;; Fast kill related
  ;; ----------------------------------------------------------------------------
  (defun my-kill-all-special-window-and-buffers-by-type (kill-type)
  "Kill the special window and buffers, here are the avaiable options of 'kill-type' :

  - 'Info
  - 'Help
  - 'ElDoc - Elgot documentation
  - 'Shell - Shell or Aasync command output
  - 'Embark
  - 'ManPage
  - 'Keybindings
  "
  	(interactive)
  	(let (
  		(kill-type-string "")
  		(window-to-be-killed nil)
  		(logger-prefix ">>> [ kill-all-special-window-and-buffers-by-type ] -")
  		)
  		(setq kill-type-string
  			(cond
  					((eq kill-type 'Info) "^*info")
  					((eq kill-type 'Help) "^*helpful")
  					((eq kill-type 'ElDoc) "^*eldoc")
  					((eq kill-type 'Shell) "^\\*\\(Shell\\|Async Shell\\)")
  					((eq kill-type 'Embark) "^*Embark")
  					((eq kill-type 'ManPage) "^*Man")
  					((eq kill-type 'Keybindings) "^*Keybindings")
  					(t ""))
  		)
  		(message "%s kill-type-string: %s" logger-prefix kill-type-string)

  		(if (not (string-empty-p kill-type-string))
  			(dolist (buf (buffer-list))
  				(when (string-match-p kill-type-string (buffer-name buf))
  					;;
  					;; Try to close its window first if exists.
  					;;
  					(setq window-to-be-killed (get-buffer-window (buffer-name buf) nil))
  					(when window-to-be-killed
  						(delete-window window-to-be-killed)
  						(message
  							"%s Closed window associated with buffer: %s"
  							logger-prefix
  							(buffer-name
  							buf))
  					)

  					;;
  					;; Kill the buffer
  					;;
  					(message "%s Killed buffer: %s" logger-prefix (buffer-name buf))
  					(kill-buffer buf)
  				)
  			)
  		)
  	)
  )

  (defun my-kill-info-window-and-buffers ()
  	(interactive)
  	(my-kill-all-special-window-and-buffers-by-type 'Info)
  )

  (defun my-kill-helpful-window-and-buffers ()
  	(interactive)
  	(my-kill-all-special-window-and-buffers-by-type 'Help)
  )

  (defun my-kill-eldoc-window-and-buffers ()
  	(interactive)
  	(my-kill-all-special-window-and-buffers-by-type 'ElDoc)
  )

  (defun my-kill-embark-window-and-buffers ()
  	(interactive)
  	(my-kill-all-special-window-and-buffers-by-type 'Embark)
  )

  (defun my-kill-manpage-window-and-buffers ()
  	(interactive)
  	(my-kill-all-special-window-and-buffers-by-type 'ManPage)
  )

  (defun my-kill-shell-window-and-buffers ()
  	(interactive)
  	(my-kill-all-special-window-and-buffers-by-type 'Shell)
  )

  (defun my-kill-keybindings-window-and-buffers ()
  	(interactive)
  	(my-kill-all-special-window-and-buffers-by-type 'Keybindings)
  )

  ;; ----------------------------------------------------------------------------
  ;; Newline replacement related
  ;; ----------------------------------------------------------------------------
  (defun my-replace-spaces-outside-strings-regex (text)
  	"Replace contiguous spaces with \\n, ignoring spaces inside quoted strings."
  	(let ((result "") (start 0))
  			(while (string-match "\"[^\"]*\"\\|\\( +\\)" text start)
  					;; Add text before the match
  					(setq result (concat result (substring text start (match-beginning 0))))

  					(if (match-beginning 1)
  							;; Matched spaces outside quotes - replace with \n
  							(setq result (concat result "\n"))
  							;; Matched quoted string - add as-is
  							(setq result (concat result (match-string 0 text)))
  					)

  					(setq start (match-end 0))
  			)

  			;; Add remaining text
  			(concat result (substring text start))
  	)
  )

  (defun my-function-newline-replacement ()
  	"Fix function newline on selected text, handle in different ways:
  - Emacs lisp: replace all ' ' (spaces) with the '\\n' in the selected text exclude the
   spaces inside a string.

  - Non Emacs lisp: replace ', ' with the '\\n' in the selected text
  "
  	(interactive)
  	(let (selected_begin selected_end selected_text replaced_text)
  		(when (use-region-p)
  			(setq selected_begin (region-beginning))
  			(setq selected_end (region-end))
  			(setq selected_text (buffer-substring selected_begin selected_end))
  			;; (message ">>> selected_text: %s" selected_text)

  			(if selected_text
  				(progn
  					;; Run the replacement on the 'selected_text'
  					(if (or (eql 'emacs-lisp-mode major-mode)
  							(eql 'lisp-interaction-mode major-mode))
  						(setq replaced_text
  							(my-replace-spaces-outside-strings-regex selected_text))
  						(setq replaced_text
  							(string-replace ", " ",\n" selected_text))
  					)

  					;; (message ">>> replaced_text: %s" replaced_text)

  					;; Delete the selected region
  					(delete-region selected_begin selected_end)

  					;; Insert the replacement
  					(insert replaced_text)
  				)
  			)
  		)
  	)
  )

  ;; ----------------------------------------------------------------------------
  ;; Show keybindings related
  ;; ----------------------------------------------------------------------------
  (setq  MY-KEYBINDINGS-LIST '(
  	(all-mode . (
  		("C-x 1"	. "Delete other windows")
  		("C-x C-c"	. "Close/Exit emacs")
  		("C-x C-f"	. "Find files")
  		("C-x b"	. "Switch buffer")
  		("SPC b"	. "Buffers (bookmarks)")
  		("SPC g"	. "GEMINI CLI")
  		("SPC g s"	. "GEMINI CLI - Run on selected text")
  		("SPC k d"	. "Kill EL-Doc windows and buffers")
  		("SPC k e"	. "Kill Embark windows and buffers")
  		("SPC k h"	. "Kill Help windows and buffers")
  		("SPC k i"	. "Kill Info windows and buffers")
  		("SPC k m"	. "Kill Manpage windows and buffers")
  		("SPC o a"	. "Open agenda")
  		("SPC o c"	. "Open emacs config")
  		("SPC o t"	. "Open todo")
  		("SPC p b"	. "Project switch buffer")
  		("SPC p c"	. "Project command")
  		("SPC p f"	. "Project find files")
  		("SPC p r"	. "Project RG")
  		("SPC v s"	. "Vertical split")
  		("SPC x"	. "M-x")
  	))
  	(dired-mode . (
  		("C-c j"	. "Jump to dired")
  		("% m"		. "Mark by regex")
  		("C"		. "Copy")
  		("D"		. "Delete")
  		("R"		. "Rename/move")
  		("o"		. "Open file in other window")
  		("Z"		. "Compress/uncompress")
  		("m"		. "Mark")
  		("u"		. "Unmark")
  		("U"		. "Unmark all")
  		("t"		. "Toggle mark/umask all")
  		("g b"		. "Go Backup")
  		("g c"		. "Go C")
  		("g d"		. "Go Downloads")
  		("g e"		. "Go emacs config")
  		("g h"		. "Go Home")
  		("g o"		. "Go Odin")
  		("g p"		. "Go Photos")
  		("g r"		. "Go Rust")
  		("g t"		. "Go Temp")
  		("g z"		. "Go Zig")
  		("s h"		. "(Toggle) show hidden")
  		("s n"		. "Sort by name")
  		("s s"		. "Sort by size")
  		("s t"		. "Sort by time")
  		("y p"		. "Yank path")
  	))
  	(org-mode . (
  		("SPC i m"	. "Embark collect")
  		("SPC i l"	. "Insert link")
  		("SPC o l"	. "Open link")
  		("SPC n i"	. "Narrow in")
  		("SPC n o"	. "Narrow out")
  		("C-<left>"	. "Jump up to parent heading")
  		("C-<right>"	. "Cycle through TODO state")
  	))
  	(eww-mode . (
  		("o"		. "Open URL")
  		("O"		. "Open URL in new buffer")
  		("r"		. "Reload")
  		("R"		. "Readable mode")
  		("u"		. "Scroll up")
  		("d"		. "Scroll down")
  		("m"		. "Bookmark")
  		("SPC i m"	. "Embark collect")
  	))
  ))

  (defun my-show-keybindings ()
      "Show my custom key bindings buffer to the right side window; the buffer content
  is generated dynamically based on the current mode."
  	(interactive)
  	(let (
  			(current-mode (symbol-name major-mode))
  			(buffer-name "*Keybindings*")
  			(buffer-text "")
  		)
  		(message ">>> [ my-show-keybindings ] - current-mode: %s" current-mode )

  		;;
  		;; Get all 'Key . Desc' pair by current major mode and concat all
  		;; together as the 'buffer-text'
  		;;
  		(dolist (key-entry-alist (alist-get (intern current-mode) MY-KEYBINDINGS-LIST))
  			;; (message ">>> key-entry-alist: %s" key-entry-alist)
  			(let (
  					(key (car key-entry-alist))
  					(value (cdr key-entry-alist))
  				)
  				(setq buffer-text (concat buffer-text key "\t - " value "\n"))
  			)
  		)

  		(setq buffer-text (concat buffer-text "\n---------------------------------------------\n\n"))

  		;;
  		;; Get all 'Key . Desc' pair by 'all-mode' and concat all together as the 'buffer-text'
  		;;
  		(dolist (key-entry-alist (alist-get 'all-mode MY-KEYBINDINGS-LIST))
  			;; (message ">>> key-entry-alist: %s" key-entry-alist)

  			(let (
  					(key (car key-entry-alist))
  					(value (cdr key-entry-alist))
  				)
  				(setq buffer-text (concat buffer-text key "\t - " value "\n"))
  			)
  		)

  		;;
  		;; Get exists '*Kyes*' buffer or create new and insert the 'buffer-text'
  		;;
  		(with-current-buffer (get-buffer-create buffer-name)
  			(erase-buffer)
  			(insert buffer-text)

  			;;
  			;; Switch to this mode
  			;;
  			;; (text-mode)
  		)

  		;;
  		;; Show the buffer on the right side
  		;;
  		(display-buffer
  			buffer-name
  			;;
  			;; The 'Action alist' will be passed to 'display-buffer'
  			;;
  			'(
  				(display-buffer-reuse-window display-buffer-in-side-window)
  				(side . right)
  				(inhibit-same-window . nil)
  				(window-width . 0.2)
  			)
  		)
  	)
  )


  ;; ----------------------------------------------------------------------------
  ;; Custom load theme related
  ;; ----------------------------------------------------------------------------
  (defun my-consult-theme (theme)
  	"My custom 'consult-theme' without prompt, 'theme' type is 'symbol' (not string)!!!"
  	(interactive)

  	(let (
  		(enabled-transparent-background nil)
  		)

  		(consult-theme theme)
  		(message ">>> [ my-consult-theme ] - theme: %s" theme)

  		;;
  		;; Enable the transparent background for specific themes
  		;;
  		(setq enabled-transparent-background
  			(cond ((equal 'doom-gruvbox theme) t)  ;; if
  					((equal 'ef-elea-dark theme) t)  ;; else if
  					((equal 'my-tron-legacy theme) t)  ;; else if
  					((equal 'doom-monokai-pro theme) t)  ;; else if
  					((equal 'doom-pine theme) t)  ;; else if
  					((equal 'ef-autumn theme) t)  ;; else if
  					((equal 'nano-light theme) t)  ;; else if
  					((equal 'nano-dark theme) t)  ;; else if
  					(t nil)      ;; else
  		))

  		(if enabled-transparent-background
  			(progn
  				(my-set-transparent-background)
  				(message
  					">>> [ my-consult-theme ] - enabled transparent background with theme: %s"
  					theme
  				)
  			)
  		)

  		;;
  		;; Fix 'show-paren-match' color for 'nano-xxxx' theme
  		;;
  		(cond
  			((eql 'nano-light theme)
  				(set-face-attribute
  					'show-paren-match
  					nil
  					:background "#FF6F00"
  					:foreground "black"
  					:weight 'bold)
  				(message
  					">>> [ my-consult-theme ] - Fixed 'show-paren-match' color for theme: %s"
  					theme))
  			((eql 'nano-dark theme)
  				(set-face-attribute
  					'show-paren-match
  					nil
  					:background "#0a84ff"
  					:foreground "black"
  					:weight 'bold)
  				(message
  					">>> [ my-consult-theme ] - Fixed 'show-paren-match' color for theme: %s"
  					theme))
  		)
  	)
  )

  (defun my-consult-theme-prompt (theme-name-list)
  	"My custom verion of 'consult-theme'.

  Usually, I prefer to list only a few themes that interest me, rather than listing
  all available themes. That's what this function does: Accept a list of theme names
  and prompt me to choose one."

  	(interactive)

  	(let (
  		(avail-themes (cons 'default theme-name-list))
  		(saved-theme (car custom-enabled-themes))
  		(my-selected-theme-symbol)
  		(theme-string "")
  		(enabled-transparent-background nil)
  		)

  		(setq my-selected-theme-symbol (consult--read
  			(mapcar #'symbol-name avail-themes)
  			:prompt "Theme: "
  			:require-match t
  			:category 'theme
  			:history 'consult--theme-history
  			:lookup (lambda (selected &rest _)
  						(setq selected (and selected (intern-soft selected)))
  						(or (and selected (car (memq selected avail-themes)))
  							saved-theme))
  			:state (lambda (action theme)
  						(pcase action
  						('return (consult-theme (or theme saved-theme)))
  						((and 'preview (guard theme)) (consult-theme theme))))
  			:default (symbol-name (or saved-theme 'default)))
  		)

  		(setq theme-string (symbol-name my-selected-theme-symbol))
  		(message
  			">>> [ my-consult-theme-prompt ] - theme-symbol: %s, theme-string: %s"
  			my-selected-theme-symbol
  			theme-string)

  		;;
  		;; Enable the transparent background for specific themes
  		;;
  		(setq enabled-transparent-background
  			(cond ((string= "doom-gruvbox" theme-string) t)  ;; if
  					((string= "ef-elea-dark" theme-string) t)  ;; else if
  					((string= "my-tron-legacy" theme-string) t)  ;; else if
  					((string= "doom-monokai-pro" theme-string) t)  ;; else if
  					((string= "doom-pine" theme-string) t)  ;; else if
  					((string= "ef-autumn" theme-string) t)  ;; else if
  					((string= "nano-light" theme-string) t)  ;; else if
  					((string= "nano-dark" theme-string) t)  ;; else if
  					(t nil)      ;; else
  		))

  		(if enabled-transparent-background
  			(progn
  				(my-set-transparent-background)
  				(message
  					">>> [ my-consult-theme-prompt ] - enabled transparent background, theme: %s"
  					theme-string)))

  		;;
  		;; Fix 'show-paren-match' color for 'nano-xxxx' theme
  		;;
  		(cond
  			((string= "nano-light" theme-string)
  				(set-face-attribute
  					'show-paren-match
  					nil
  					:background "#0a84ff"
  					:foreground "black"
  					:weight 'bold)
  				(message
  					">>> [ my-consult-theme-prompt ] - Fixed 'show-paren-match' color for theme: %s"
  					theme-string))
  			((string= "nano-dark" theme-string)
  				(set-face-attribute
  					'show-paren-match
  					nil
  					:background "#0a84ff"
  					:foreground "black"
  					:weight 'bold)
  				(message
  					">>> [ my-consult-theme-prompt ] - Fixed 'show-paren-match' color for theme: %s"
  					theme-string))
  		)
  				  

  		;;
  		;; Fixed the org heading font size if you're the 'org-mode'
  		;;
  		(if (equal major-mode 'org-mode)
  			(my/org-mode-setup))
  	)
  )

  (defun my-load-consult-theme-wrapper ()
  	(interactive)
  	(my-consult-theme-prompt '(
  		ef-cyprus
  		ef-melissa-light
  		ef-melissa-dark
  		ef-elea-dark
  		ef-bio
  		ef-autumn
  		ef-rosa
  		doom-henna
  		doom-plain-dark
  		doom-plain
  		doom-nord
  		doom-nord-aurora
  		doom-gruvbox
  		doom-lantern
  		doom-pine
  		doom-horizon
  		doom-zenburn
  		doom-old-hope
  		doom-laserwave
  		doom-monokai-pro
  		my-tron-legacy
  		nano-light
  		nano-dark
  	))
  )


  ;; ----------------------------------------------------------------------------
  ;; Implement  the 'g C-a' feature in Vim related
  ;; ----------------------------------------------------------------------------
  (defun my-increase-selected-number-in-visual-block-state ()
  	"Increase the selected text (number) from top to bottom:
  Go into 'evil-visual-state' by pressing 'C-v', then select a number columns and
  press 'C-a' to increase all number from top to bottom (starts from the first number)"
  	(interactive)
  	(let (
  			selected-range
  			selected-begin
  			selected-end
  			current-line
  			end-line
  			left-column
  			right-column
  			selected-text '()
  			(current-number 0)
  			(already-done-with-end-line nil)
  		)
  		(unless (evil-visual-state-p) (error "No selected number columns."))

  		;;
  		;; Signature
  		;; (evil-visual-range)
  		;; 
  		;; Documentation
  		;; Return the Visual selection as a range.
  		;; 
  		;; This is a list (BEG END TYPE PROPERTIES...), where BEG is the
  		;; beginning of the selection, END is the end of the selection,
  		;; TYPE is the selection's type, and PROPERTIES is a property list
  		;; of miscellaneous selection attributes.
  		;;
  		;; Example return value: (1232 1307 block :expanded t :corner upper-left)
  		;;
  		(setq selected-range (evil-visual-range))

  		(setq selected-begin (nth 0 selected-range))
          (setq selected-end (nth 1 selected-range))

  		;; Get back the begin line and end line based on the selected range
  		(setq current-line (line-number-at-pos selected-begin))
  		(setq end-line (line-number-at-pos selected-end))

  		;;
  		;; Signature
  		;; (save-excursion &rest BODY)
  		;;
  		;; Documentation
  		;; Save point, and current buffer; execute BODY; restore those things.
  		;;
  		;;
  		;; The following code means:
  		;;
  		;; First, save the point (cursor position), and then goto the 'selected-begin'
  		;; position (it will change the point, that's why you need to save first) and
  		;; get back the column value then save to 'left-column'.
  		;; After that, restore the saved point, which means restore the cursor position.
  		;;
  		(setq left-column (save-excursion
  							  (goto-char selected-begin)
  							  (current-column)))
  		(setq right-column (save-excursion
  							   (goto-char selected-end)
  							   (current-column)))

  		;; (message
  		;; 	(concat
  		;; 		"\nselected-range: %s"
  		;; 		"\nselected-begin: %s"
  		;; 		"\nselected-end: %s"
  		;; 		"\ncurrent-line: %s"
  		;; 		"\nend-line: %s"
  		;; 		"\nleft-column: %s"
  		;; 		"\nright-column: %s"
  		;; 	)
  		;; 	selected-range
  		;; 	selected-begin
  		;; 	selected-end
  		;; 	current-line
  		;; 	end-line
  		;; 	left-column
  		;; 	right-column
  		;; )

  		;;
          ;; Now, let's do this:
  		;;
  		;; - Save the cursor point
  		;; - Loop through all selected lines and extract number text from selected columns
  		;; - Convert into number and increase it, then replace it
  		;; - Restor the cursor point
  		;;
          (save-excursion
  			(goto-char selected-begin)
  			(setq current-line (line-number-at-pos))

  			(while (and (not already-done-with-end-line) (<= current-line end-line))
  				(let* (
  						(line-beg-pos (line-beginning-position))
  						(line-end-pos (line-end-position))
  						(line-start (min line-end-pos
  										(+ line-beg-pos left-column)))
  						(line-end (min line-end-pos
  									(+ line-beg-pos right-column)))
  						(number-text (buffer-substring line-start line-end))
  						(number-value (string-to-number number-text))
  					)

  					;; (message
  					;; 	(concat
  					;; 		"\ncurrent-line: %s"
  					;; 		"\nline-begin-pos: %s"
  					;; 		"\nline-end-pos: %s"
  					;; 		"\nline-start: %s"
  					;; 		"\nline-end: %s"
  					;; 		"\nnumber-text: %s"
  					;; 		"\nnumber-value: %s"
  					;; 		"\ncurrent-value: %s"
  					;; 	)
  					;; 	current-line
  					;; 	line-beg-pos
  					;; 	line-end-pos
  					;; 	line-start
  					;; 	line-end
  					;; 	number-text
  					;; 	number-value
  					;; 	current-number
  					;; )

  					(if (= current-number 0)
  						;; Init case: Save the first number value
  						(progn
  							;; If that's NOT a valid number, exit visual state and throw error!
  							(if (= number-value 0)
  								(progn
  									(evil-exit-visual-state)
  									(error "First select column doesn't contain valid nubmer!")
  								)
  							)

  							(setq current-number number-value)
  						)
  						;; Non-init case: increase the saved number
  						(progn
  							(setq current-number (+ current-number 1))
  						)
  					)

  					;; Delete the selected 'number-text'
  					(delete-region line-start line-end)

  					;; Insert the replacement
  					(goto-char line-start)
  					(insert (number-to-string current-number))

  					;; (message ">>> Ok, done with current-line: %s" current-line)
  				)

  				;;
  				;; Here is a trick to stop the 'while' loop after finishing the 'end-line'
  				;;
  				;; If the 'end-line' (last line of the block selection) is the last line of
  				;; the current buffer, then the following '(forward-line 1)' does nothing, and
  				;; 'current-line' will be still the same value with 'end-line'!!!!
  				;;
  				;; That's why you need a flag to indicate that: You've done with the 'end-line'
  				;; once.
  				;;
  				(if (= current-line end-line)
  					(progn
  						(setq already-done-with-end-line t)
  						;; (message ">>> already-done-with-end-line: %s" already-done-with-end-line)
  					)
  				)

  				;; Move to the next line and maybe hit the last line of the current buffer
  				(forward-line 1)

  				;; Update the 'current-line' after trying to move to next line.
  				(setq current-line (line-number-at-pos))
  				;; (message ">>> update, updated current-line: %s" current-line)

  				;; (message ">>> The while loop condition: %s" (and (not already-done-with-end-line) (<= current-line end-line)))

  			)
  		)

  		;; Make sure to exit visual state
  		(evil-exit-visual-state)
  	)
  )
#+END_SRC


**** My ~my-common-bindings~

#+BEGIN_SRC emacs-lisp
  (defun my-dired-jump ()
  	(interactive)
  	(dired default-directory "-lh")
  )

  ;;
  ;; Group all the common bindings that are supposed to be shared between different modes.
  ;;
  (defun my-common-bindings (map)
  	;;
  	;; Toggle spell check
  	;;
  	(keymap-set map "SPC s c" 'flyspell-mode)

  	;;
  	;; Kill current window by 'Q' h
  	;;
  	(keymap-set map "Q" 'delete-window)

  	;; ;;
  	;; ;; Exit Emacs by '<leader>q'
  	;; ;;
  	;; (keymap-set mode-map "SPC q" 'save-buffers-kill-terminal)

  	;;
  	;; Delete other windows by by '<leader>1'
  	;;
  	(keymap-set map "SPC 1" 'delete-other-windows)

  	;;
  	;; Call 'describe-xxxx' functions by '<leader>df/v/k/b'
  	;;
  	(keymap-set map "SPC d f" 'helpful-callable)
  	(keymap-set map "SPC d v" 'helpful-variable)
  	(keymap-set map "SPC d k" 'describe-key)
  	(keymap-set map "SPC d b" 'describe-bindings)
  	(keymap-set map "SPC d m" 'describe-mode)

  	;;
  	;; Toggle command log mode by '<leader>cl'
  	;;
  	(keymap-set map "SPC c l" 'clm/toggle-command-log-buffer)

  	;;
  	;; Load theme by '<leader>lt'
  	;;
  	;; (keymap-set map "SPC l t" 'consult-theme)
  	(keymap-set map "SPC l t" 'my-load-consult-theme-wrapper)

  	;;
  	;; Evaluate lisp expression by '<leader>eb>', '<leader>es', '<leader>ee', '<leader>ep'
  	;;
  	(keymap-set map "SPC e b" 'eval-buffer)           ;; Evaluate buffer
  	(keymap-set map "SPC e s" 'eval-region)           ;; Evaulate selected region
  	(keymap-set map "SPC e e" 'eval-last-sexp)        ;; Evaulate expression
  	(keymap-set map "SPC e p" 'eval-print-last-sexp)  ;; Evaulate expression and print result

  	;;
  	;; Search for man page  by '<leader>m'
  	;;
  	(keymap-set map "SPC m" 'consult-man)

  	;;
  	;; Run 'execute-extended-command' by '<leader>x'
  	;;
  	(keymap-set map "SPC x" 'execute-extended-command)

  	;;
  	;; Open files or buffers by '<leader>f/b'
  	;;
  	;; (keymap-set map "SPC f" 'find-file)
  	(keymap-set map "SPC b" 'consult-buffer)

  	;;
  	;; Project scope fuzzy searching files and related actions by '<leader>p X'
  	;;
  	(keymap-set map "SPC p f" 'project-find-file)
  	(keymap-set map "SPC p d" 'project-dired)
  	(keymap-set map "SPC p s" 'project-switch-project)
  	(keymap-set map "SPC p b" 'project-switch-to-buffer)
  	(keymap-set map "SPC p c" 'project-command/run-with-enable-script-files)
  	(keymap-set map "SPC p r" 'consult-ripgrep)

  	;;
  	;; Switch between last buffers '<leader>SPC'
  	;;
  	(keymap-set map "SPC SPC" 'my-switch-to-last-buffer)

  	;;
  	;; Toggle 'Olivetti' mode (works like 'GoYo' in 'Neovim') by '<leader>RET'
  	;;
  	(keymap-set map "SPC RET" 'olivetti-mode)

  	;;
  	;; 'imenu' (function and variable list) by '<leader>im'
  	;;
  	(keymap-set map "SPC i m" 'consult-imenu)

  	;;
  	;; Window split by '<leader>vs'
  	;;
  	(keymap-set map "SPC v s" 'evil-window-vsplit)

  	;;
  	;; Window movement by 'C-h, C-l' (Only for jumping between left and right windows)
  	;;
  	(keymap-set map "C-l" 'evil-window-right)
  	(keymap-set map "C-h" 'evil-window-left)

  	;;
  	;; Change window size by '-/+/='
  	;;
  	(keymap-set map "|" 'balance-windows)
  	(keymap-set map "=" 'my-increase-window-width)
  	(keymap-set map "-" 'my-decrease-window-width)
  	(keymap-set map "+" 'my-increase-window-height)
  	(keymap-set map "_" 'my-decrease-window-height)

  	;;
  	;; Open something quickly
  	;;
  	(keymap-set map "SPC o a"   'org-agenda)
  	(keymap-set map "SPC o c"   'my-open-emacs-configuration)
  	(keymap-set map "SPC o q"   'my-open-lisp-quick-manual)
  	(keymap-set map "SPC o s f" 'my-open-snippet-folder)
  	(keymap-set map "SPC o t"   'my-open-todo-list)
  	;; (keymap-set map "SPC o l t" 'my-open-lisp-quick-tutorial)

  	;;
  	;; Emoji insert by '<leader>ei'
  	;;
  	(keymap-set map "SPC e i" 'emoji-insert)

  	;;
  	;; Fast kill buffers and windows by '<leadedr>kX'
  	;;
  	(keymap-set map "SPC k d" 'my-kill-eldoc-window-and-buffers)
  	(keymap-set map "SPC k e" 'my-kill-embark-window-and-buffers)
  	(keymap-set map "SPC k h" 'my-kill-helpful-window-and-buffers)
  	(keymap-set map "SPC k i" 'my-kill-info-window-and-buffers)
  	(keymap-set map "SPC k k" 'my-kill-keybindings-window-and-buffers)
  	(keymap-set map "SPC k m" 'my-kill-manpage-window-and-buffers)
  	(keymap-set map "SPC k s" 'my-kill-shell-window-and-buffers)

  	;;
  	;; My function newline code util by '<leader>fn'
  	;;
  	(keymap-set map "SPC f n" 'my-function-newline-replacement)

  	;;
  	;; Jump back to 'dired buffer' corresponding to current buffer by 'C-c j'
  	;;
  	(keymap-set map "C-c j" 'my-dired-jump)

  	;;
  	;; Show keybinding of the current buffer by '<leader>sk'
  	;;
  	(keymap-set map "SPC s k" 'my-show-keybindings)

  	;;
  	;; Run 'gemini-cli' with selected text by '<leader>gs'
  	;;
  	(keymap-set map "SPC g s" 'my-gemini-search-on-selected-text)

  	;;
  	;; Update 'which-key'
  	;;
  	(if my-enable-which-key-customized-description
  	    (progn
  	        ;; (which-key-add-key-based-replacements "SPC q" "Save and exit")
  			(which-key-add-key-based-replacements "SPC 1"   "Delete other windows")
  			(which-key-add-key-based-replacements "SPC c l" "Command Log")
  			(which-key-add-key-based-replacements "SPC l t" "Load theme")
  			(which-key-add-key-based-replacements "SPC m"   "Man page search")
  			(which-key-add-key-based-replacements "SPC x"   "M-x command")
  			;; (which-key-add-key-based-replacements "SPC f"   "Find files")
  			(which-key-add-key-based-replacements "SPC b"   "Switch buffers")
  			(which-key-add-key-based-replacements "SPC SPC" "Last Buffer")
  			(which-key-add-key-based-replacements "SPC RET" "Toggle Focus mode")
  			(which-key-add-key-based-replacements "SPC i"   "iMenu/Insert")

  			(which-key-add-key-based-replacements "SPC d"   "Describe ...")
  			(which-key-add-key-based-replacements "SPC d f" "Function")
  			(which-key-add-key-based-replacements "SPC d v" "Variable")
  			(which-key-add-key-based-replacements "SPC d k" "Keys")
  			(which-key-add-key-based-replacements "SPC d m" "Mode")
  			(which-key-add-key-based-replacements "SPC d b" "Bindings")

  			(which-key-add-key-based-replacements "SPC e"   "Evalute/Emoji")
  			(which-key-add-key-based-replacements "SPC e i" "Insert emoji")
  			(which-key-add-key-based-replacements "SPC e b" "Buffer")
  			(which-key-add-key-based-replacements "SPC e s" "Selection")
  			(which-key-add-key-based-replacements "SPC e e" "Expression")
  			(which-key-add-key-based-replacements "SPC e p" "Expression and print")

  			(which-key-add-key-based-replacements "SPC p"   "Projects")
  			(which-key-add-key-based-replacements "SPC p f" "Fuzzy searching in project")
  			(which-key-add-key-based-replacements "SPC p d" "Open dired in project")
  			(which-key-add-key-based-replacements "SPC p b" "Switch buffer in project")
  			(which-key-add-key-based-replacements "SPC p s" "Switch to another project")
  			(which-key-add-key-based-replacements "SPC p c" "Project command")
  			(which-key-add-key-based-replacements "SPC p r" "Project rg search")

  			(which-key-add-key-based-replacements "SPC v"   "Vertical split")
  			(which-key-add-key-based-replacements "SPC v s" "Vertical split")

  			(which-key-add-key-based-replacements "SPC o"   "(Quick) open ....")
  			(which-key-add-key-based-replacements "SPC o a" "Agenda")
  			(which-key-add-key-based-replacements "SPC o c" "Configuration file")
  			(which-key-add-key-based-replacements "SPC o q" "Lisp quick manual")
  			(which-key-add-key-based-replacements "SPC o s f" "Snippet folder")
  			(which-key-add-key-based-replacements "SPC o t" "Todo list")

  			(which-key-add-key-based-replacements "SPC k" "Kill")
  			(which-key-add-key-based-replacements "SPC k i" "Info window and buffer")
  			(which-key-add-key-based-replacements "SPC k h" "Help window and buffer")
  			(which-key-add-key-based-replacements "SPC k d" "ElDoc window and buffer")
  			(which-key-add-key-based-replacements "SPC k e" "Embark window and buffer")
  			(which-key-add-key-based-replacements "SPC k k" "Keybindings window and buffer")
  			(which-key-add-key-based-replacements "SPC k m" "ManPage window and buffer")
  			(which-key-add-key-based-replacements "SPC k s" "Shell window and buffer")

  			(which-key-add-key-based-replacements "SPC s k" "Show keybindings")

  			(which-key-add-key-based-replacements "SPC g" "GEMINI CLI")
  			(which-key-add-key-based-replacements "SPC g s" "Run on selected text")
  		)
  	)

  )
#+END_SRC


**** Apply ~my-common-bindings~ to the followings modes

#+BEGIN_SRC emacs-lisp
  ;;
  ;; Now, this is the function will be called when the 'xxx-mode' is available.
  ;;
  ;; Inside this function, you should call the 'lmy-common-bindings' with the
  ;; 'evil-normal-state-local-map' to make sure your bindings are on the most top priority
  ;; in the bindings order that you've saw in the above example!!!
  ;;
  (defun my-xxx-mode-local-bindings ()
  	;;
  	;; Common bindings first
  	;;
  	(my-common-bindings evil-normal-state-local-map)
  	;; (message ">>> 'my-xxx-mode-local-bindings' runs")
  )

  ;;
  ;; Now, bind 'my-xxx-mode-local-bindings' to 'xxx-mode-hook'
  ;;
  (defun my-bind-common-bindings-to-these-mode-hooks ()
  	(dolist (hook '(
  		help-mode-hook
  		helpful-mode-hook
  		embark-collect-mode-hook
  		dired-mode-hook
  		shell-command-mode-hook
  		debugger-mode-hook
  		compilation-mode-hook
  		special-mode-hook
  		fundamental-mode-hook
  		edit-abbrevs-mode-hook
  		org-mode-hook
  		org-agenda-mode-hook
  		markdown-mode-hook
  		markdown-view-mode-hook
  		eww-mode-hook
  		eww-history-mode-hook
  		eww-bookmark-mode-hook
  		lisp-interaction-mode-hook
  		lisp-mode-hook
  		emacs-lisp-mode-hook
  		emacs-lisp-compilation-mode-hook
  		snippet-mode-hook
  		prog-mode-hook
  		text-mode-hook
  		;; c-mode-hook
  		;; c-ts-mode-hook
  		;; c++-mode-hook
  		;; c++-ts-mode-hook
  		;; zig-mode-hook
  		;; zig-ts-mode-hook
  		;; rust-mode-hook
  		;; rust-ts-mode-hook
  		;; typescript-ts-mode-hook
  		;; js-ts-mode-hook
  		;; java-ts-mode-hook
  		;; hare-mode-hook
  		;; hare-ts-mode-hook
  		))

  		(add-hook hook #'my-xxx-mode-local-bindings)
  		(message ">>> Add 'my-xxx-mode-local-bindings' to '%s'" hook)
  	)
  )

  ;;
  ;; Bind the special bindings to 'evil-visual-state-map'
  ;;
  (defun my-special-visual-state-bindings ()
  	(keymap-set evil-visual-state-map "C-a" 'my-increase-selected-number-in-visual-block-state)
  )

  (defun my-visual-mode-special-bindings ()
  	(dolist (hook '(
  			org-mode-hook
  			markdown-mode-hook
  			lisp-interaction-mode-hook
  			lisp-mode-hook
  			emacs-lisp-mode-hook
  			emacs-lisp-compilation-mode-hook
  			snippet-mode-hook
  			prog-mode-hook
  		))
  		(add-hook hook #'my-special-visual-state-bindings)
  		(message ">>> Add 'my-special-visual-state-bindings' to '%s'" hook)
  	)

  	;; (evil-define-key 'visual lisp-interaction-mode "C-a" 'my-increase-selected-number-in-visual-block-state)

  )

  ;;
  ;; The 'messages-buffer-mode' is super special:
  ;;
  ;; New 'messages-buffer-mode' in Emacs 24.4. [ 08 Jul 2014, by Artur Malabarba. ]:
  ;;
  ;; I've been using 24.4 for months now, yet only today I came to realise the *Messages* buffer
  ;; has been granted its own major-mode. The practical difference is that the buffer is now
  ;; 'read-only' and has a 'non-writing-oriented' key-map.
  ;;
  (defun my-bind-common-bindings-to-message-buffer ()
  	;; ;;
  	;; ;; This doesn't work, the 'messages-buffer-mode-hook' function won't be called!!!
  	;; ;;
  	;; (add-hook
  	;; 	'messages-buffer-mode-hook
  	;; 	#'my-bind-common-bindings-to-messages-buffer
  	;; )

  	;;
  	;; You have to get back the message buffer instance and run ;; 'my-common-bindings' 
  	;; on it!!!
  	;;
  	(when-let ((messages-buffer (get-buffer "*Messages*")))
  		(with-current-buffer messages-buffer
  			;; (evil-normalize-keymaps)
  			;; (message ">>> called 'evil-normalize-keymaps' on 'MessageBuffer'")
  			(my-common-bindings evil-normal-state-local-map)
  			(message ">>> called 'my-common-bindings' on 'MessageBuffer'")
  		)
  	)
  )



  ;;
  ;; 'my-bind-common-bindings-to-these-mode-hooks' has to be called when all 'xxx-mode-hook'
  ;; are avaiable. Otherwise, 'my-xxx-mode-local-bindings' won't be called for some modes!!!
  ;;
  ;; That's why you should call this function for the 'after-init-hook', as all 'xxx-mode-hook'
  ;; should be ready after the frame has been inited.
  ;;
  (add-hook
  	'after-init-hook
  	(lambda ()
  		(my-bind-common-bindings-to-message-buffer)
  		(message ">>> 'my-bind-common-bindings-to-message-buffer' has been called by 'after-init-hook'")

  		(my-bind-common-bindings-to-these-mode-hooks)
  		(message ">>> 'my-bind-common-bindings-to-these-mode-hooks' has been called by 'after-init-hook'")

  		(my-visual-mode-special-bindings)
  		(message ">>> 'my-visual-mode-special-bindings' has been called by 'after-init-hook'")
  	)
  )





#+END_SRC


*** LSP

**** Go to next or previous error by ~C-n~ or ~C-p~

#+BEGIN_SRC emacs-lisp
  (defun my-lsp-error-jumping-in-local-buffer()
  	(keymap-set evil-normal-state-local-map "C-n" 'flymake-goto-next-error)
  	(keymap-set evil-normal-state-local-map "C-p" 'flymake-goto-prev-error)
  	
  	(message ">>> [ my-lsp-error-jumping-in-local-buffer ] Set 'C-n' and 'C-p' to local buffer")
  )
#+END_SRC


**** Format buffer by ~<leader>ff~

#+BEGIN_SRC emacs-lisp
  (defun my-lsp-format-buffer()
  	;;(keymap-set evil-normal-state-local-map "<leader>ff" 'lsp-format-buffer)
  	
  	(keymap-set evil-normal-state-local-map "SPC f f" 'eglot-format-buffer)
  	
  	(message ">>> [ my-lsp-format-buffer ] Set '<leader>ff' to local buffer")
  )
#+END_SRC


**** Rename by ~<leader>rn~

#+BEGIN_SRC emacs-lisp
  (defun my-lsp-rename-buffer()
  	;; (keymap-set evil-normal-state-local-map "<leader>rn" 'lsp-rename)
  	
  	(keymap-set evil-normal-state-local-map "SPC r n" 'eglot-rename)
  	
  	(message ">>> [ my-lsp-rename-buffer ] Set '<leader>rn' to local buffer")
  )
#+END_SRC


**** Show error (diagnostics buffer) ~<leader>se~

#+BEGIN_SRC emacs-lisp
  (defun my-lsp-show-error()
  	(keymap-set evil-normal-state-local-map "SPC s e" 'flymake-show-buffer-diagnostics)
  	
  	(message ">>> [ my-lsp-show-error ] Set '<leader>se' to local buffer")
  )
#+END_SRC


**** Run code action ~<leader>ca~

#+BEGIN_SRC emacs-lisp
  (defun my-lsp-code-action()
  	;; (keymap-set evil-normal-state-local-map "<leader>ca" 'lsp-execute-code-action)
  	;; (keymap-set evil-normal-state-local-map "C-c c a" 'lsp-execute-code-action)
  	
  	(keymap-set evil-normal-state-local-map "SPC c a" 'eglot-code-action-quickfix)
  	
  	(message ">>> [ my-lsp-code-action ] Set '<leader>ca' to local buffer")
  )
#+END_SRC


**** Toggle inlay hints by ~<leader>th~

#+BEGIN_SRC emacs-lisp
  (defun my-lsp-toggle-inlay-hint()
  	(interactive)
  	(message ">>>>> called.")
  	(if eglot-inlay-hints-mode
  	    (progn
  	        (message ">>> [ my-lsp-toggle-inlay-hint ] Inlay hint is 'on', turn it 'off' now.")
  	        (eglot-inlay-hints-mode -1)
  	    )
  	    (progn
  	        (message ">>> [ my-lsp-toggle-inlay-hint ] Inlay hint is 'off', turn it 'on' now.")
  	        (eglot-inlay-hints-mode 1)
  	    )
  	)
  )

  (defun my-setup-toggle-inlay-hint()
      (keymap-set evil-normal-state-local-map "SPC t h" 'my-lsp-toggle-inlay-hint)

      (message ">>> [ my-setup-toggle-inlay-hint ] Set '<leader>th' to local buffer")
  )
#+END_SRC


**** Go to next or previous error by =C-n= or =C-p= in =compliaciton-mode=

#+BEGIN_SRC emacs-lisp
  (defun my-compilation-error-jumping-in-local-buffer()
  	(keymap-set evil-normal-state-local-map "C-n" 'compilation-next-error)
  	(keymap-set evil-normal-state-local-map "C-p" 'compilation-previous-error)
  	
  	(message ">>> [ my-compilation-error-jumping-in-local-buffer ] Set 'C-n' and 'C-p' to local buffer")
  )
#+END_SRC


**** +Open embark collect buffer by ~<leader>im~+

I regret the following way, as I think the default ~consult-imenu~ is still better than the ~embark-collect~!!!

#+BEGIN_SRC emacs-lisp :tangle no
  (defun my-lsp-mode-heading-catalog-local()
  	(keymap-set evil-normal-state-local-map "SPC i m" 'embark-collect)

  	(if my-enable-which-key-customized-description
  		(progn
  			(which-key-add-key-based-replacements "SPC i m" "LSP Catalog")
  		)
  	)
  )
#+END_SRC


**** Bind all bindings above in one shot

#+BEGIN_SRC emacs-lisp
  (defun my-lsp-bindings()
  	(my-lsp-error-jumping-in-local-buffer)
  	(my-lsp-format-buffer)
  	(my-lsp-rename-buffer)
  	(my-lsp-show-error)
  	(my-lsp-code-action)
  	(my-setup-toggle-inlay-hint)

  	(if my-enable-which-key-customized-description
  		(progn
  			(which-key-add-major-mode-key-based-replacements major-mode "SPC f" "Format")
  			(which-key-add-major-mode-key-based-replacements major-mode "SPC f f" "Format")
  			(which-key-add-major-mode-key-based-replacements major-mode "SPC r" "Rename")
  			(which-key-add-major-mode-key-based-replacements major-mode "SPC r n" "Rename")
  			(which-key-add-major-mode-key-based-replacements major-mode "SPC s" "Show errors")
  			(which-key-add-major-mode-key-based-replacements major-mode "SPC s e" "Show errors")
  			(which-key-add-major-mode-key-based-replacements major-mode "SPC c" "Code actions")
  			(which-key-add-major-mode-key-based-replacements major-mode "SPC c a" "Code actions")
  			(which-key-add-major-mode-key-based-replacements major-mode "SPC /" "Comment")
  			(which-key-add-major-mode-key-based-replacements major-mode "SPC t" "Toggle")
  			(which-key-add-major-mode-key-based-replacements major-mode "SPC t h" "Toggle hints")
  		))
  )

  (dolist (hook '(c-mode-hook
                  c-ts-mode-hook
                  c++-mode-hook
                  c++-ts-mode-hook
                  zig-mode-hook
                  zig-ts-mode-hook
                  rust-mode-hook
                  rust-ts-mode-hook
                  typescript-ts-mode-hook
                  js-ts-mode-hook
                  java-ts-mode-hook
                  python-ts-mode-hook
                  ))
  	(add-hook hook #'my-lsp-bindings)
  )

  (add-hook 'compilation-mode-hook #'my-compilation-error-jumping-in-local-buffer)
#+END_SRC


*** Org mode

#+BEGIN_SRC emacs-lisp
  (defun my-org-jump-to-next-heading ()
  	(interactive)
  	(org-forward-heading-same-level nil)
  	(evil-scroll-line-to-center nil)
  )

  (defun my-org-jump-to-previous-heading ()
  	(interactive)
  	(org-backward-heading-same-level nil)
  	(evil-scroll-line-to-center nil)
  )

  (defun my-org-jump-up-to-parent-heading ()
  	(interactive)
  	(outline-up-heading 1)
  	(evil-scroll-line-to-center nil)
  )

  ;;
  ;; My 'org-mode' bindings
  ;;
  (defun my-org-mode-bindings (map)
  	;;
  	;; Fold or unfold when cursor is on heading by '<RET>'
  	;;
  	(keymap-set map "RET" 'org-cycle)

  	;;
  	;; Open code edit by '<leader>ce'
  	;;
  	(keymap-set map "SPC c e" 'org-edit-special)

  	;;
  	;; Open embark collect buffer by '<leader>im' 
  	;; Use 'imenu' keybindings just easy for me to remember, nothing special:)
  	;;
  	(keymap-set map "SPC i m" 'embark-collect)

  	;;
  	;; Insert/edit a link by '<leader>il' and open a link by '<leader>ol' 
  	;;
  	(keymap-set map "SPC i l" 'org-insert-link)
  	(keymap-set map "SPC o l" 'org-open-at-point)

  	;;
  	;; Narrowing start and end by '<leader>ns' and '<leader>ne'
  	;;
  	(keymap-set map "SPC n i" 'org-narrow-to-subtree)
  	(keymap-set map "SPC n o" 'widen)

  	;;
  	;; Jump between same level headings by '<C-j>' and '<C-k>'
  	;;
  	(keymap-set map "C-j" 'my-org-jump-to-next-heading)
  	(keymap-set map "C-k" 'my-org-jump-to-previous-heading)

  	;;
  	;; Jump back to up 1 level heading by '<C-left>'
  	;;
  	(keymap-set map "C-<left>" 'my-org-jump-up-to-parent-heading)

  	;;
  	;; Cycle through the TODO state by '<C-Right>'
  	;;
  	(keymap-set map "C-<right>" 'org-todo)

  	(if my-enable-which-key-customized-description
  		(progn

  			(which-key-add-major-mode-key-based-replacements major-mode "SPC c e" "Code Edit")
  			(which-key-add-major-mode-key-based-replacements major-mode "SPC i m" "Org Heading Catalog")
  			(which-key-add-major-mode-key-based-replacements major-mode "SPC o l" "Link")
  			(which-key-add-major-mode-key-based-replacements major-mode "SPC i l" "Insert link")

              (which-key-add-major-mode-key-based-replacements major-mode "SPC n" "(Org) Narrowing")
              (which-key-add-major-mode-key-based-replacements major-mode "SPC n i" "Org Narrowing In")
              (which-key-add-major-mode-key-based-replacements major-mode "SPC n o" "Org Narrowing Out")
  		)
  	)
  )

  ;;
  ;; Call 'my-org-mode-binding' with 'evil-normal-state-local-map'
  ;;
  (defun my-org-mode-local-bindings ()
  	(my-org-mode-bindings evil-normal-state-local-map)
  )


  ;;
  ;; Then, add it to the 'org-mode-hook'
  ;;
  (add-hook 'org-mode-hook #'my-org-mode-local-bindings)
#+END_SRC



*** Markdown

#+BEGIN_SRC emacs-lisp
  (defun my-markdown-next-heading()
  	(interactive)
  	(outline-next-visible-heading 1)
  	(evil-scroll-line-to-center nil)
  )

  (defun my-markdown-previous-heading()
  	(interactive)
  	(outline-next-visible-heading -1)
  	(evil-scroll-line-to-center nil)
  )

  ;;
  ;; My 'markdown-mode' and 'markdown-view-mode' bindings
  ;;
  (defun my-markdown-mode-bindings (map)
  	;;
  	;; Fold or unfold when cursor is on heading by '<RET>'
  	;;
  	(keymap-set map "RET" 'markdown-cycle)

  	;;
  	;; Jump between same level headings by '<C-j>' and '<C-k>'
  	;;
  	(keymap-set map "C-j" 'my-markdown-next-heading)
  	(keymap-set map "C-k" 'my-markdown-previous-heading)
  )

  ;;
  ;; Call 'my-markdown-mode-binding' with 'evil-normal-state-local-map'
  ;;
  (defun my-markdown-mode-local-bindings ()
  	(my-markdown-mode-bindings evil-normal-state-local-map)
  )


  ;;
  ;; Then, add it to the related mode hooks
  ;;
  (dolist (hook '(
                 markdown-mode-hook
                 markdown-view-mode-hook
                 ))
  	(add-hook hook #'my-markdown-mode-local-bindings)
  )
#+END_SRC


*** Dired

#+BEGIN_SRC emacs-lisp
  (defun my-dired-yank-full-path ()
  	(interactive)
  	(dired-copy-filename-as-kill 0)
  )

  (defun my-dired-sort-by-time ()			(interactive) (dired-sort-other "-lht"))
  (defun my-dired-sort-by-size ()			(interactive) (dired-sort-other "-lhS"))
  (defun my-dired-sort-by-name ()			(interactive) (dired-sort-other "-lh"))
  ;; (defun my-dired-sort-by-directory ()	(interactive) (dired-sort-other "-l --group-directories-first"))

  (defun my-goto-home-directory()			(interactive) (dired "~/"))
  (defun my-goto-desktop-directory()		(interactive) (dired "~/Desktop"))
  (defun my-goto-sbzi-directory()			(interactive) (dired "~/sbzi"))
  (defun my-goto-emacs-directory()		(interactive) (dired "~/.config/emacs"))
  (defun my-goto-downloads-directory()	(interactive) (dired "~/Downloads"))

  (defun my-dired-add-file-or-directory ()

  "In 'dired-mode', press 'A' to show a prompt.
  If the filename end with '/' that means create diretory, otherwise, create an empty file.
  "

  	(interactive)
  	(let ((filename ""))
  		;;
  		;; Ask for the new file or directory name
  		;;
  		(setq filename  (completing-read
  			;;
  			;; The prompt
  			;;
  			"Create new file or directory: "

  			;;
  			;; List: can be either
  			;;
  			;; - A 'list' instance, e.g: (list "./configure.sh" "./run.sh" "./run-test.sh")
  			;; - A 'list' variable name, e.g: cmd-list
  			;; - A 'function': the function is solely responsible for performing completion; 'completion-read'
  			;;                 returns whatever this function returns. The function is called with three
  			;;                 arguments: 'string predicate nil'
  			;;
  			;;				   You can read more from 'Programmed completion':
  			;;				   https://www.gnu.org/software/emacs/manual/html_node/elisp/Programmed-Completion.html
  			;;
  			nil

  			;;
  			;; 'PREDICATE' function (not provided)
  			;;
  			nil

  			;;
  			;; 'REQUIRE-MATCH': input must match in the 'List'
  			;;
  			;; - t means that the user is not allowed to exit unless the input is (or
  			;;   completes to) an element of COLLECTION or is null.
  			;;
  			;; - nil means that the user can exit with any input.
  			;;
  			;; - confirm means that the user can exit with any input, but she needs
  			;;   to confirm her choice if the input is not an element of COLLECTION.
  			;;
  			'confirm

  			;;
  			;; 'INIT-INPUT': simulate you type in the input area
  			;;
  			nil

  			;;
  			;; 'HIST': History list (not provided)
  			;;
  			nil

  			;;
  			;; 'DEF': Default value, put it to the top position!!!
  			;;
  			""
  			))
  		(message ">>> Your file or directory name: %s" filename)

  		(if (not (string-empty-p filename))
  			(progn
  				(if (string-suffix-p "/" filename)
  					(dired-create-directory filename)
  					(dired-create-empty-file filename)
  				)
  			)
  		)
  	)
  )

  ;;
  ;; My 'dired-mode' bindings
  ;;
  (defun my-dired-mode-bindings (map)
  	;;
  	;; Jump back to 'dired buffer' corresponding to current buffer by 'C-c j'
  	;;
  	(keymap-set map "C-c j" 'my-dired-jump)

  	;;
  	;; Go up dir by 'h' and into dir or open file by 'l'
  	;;
  	(keymap-set map "h" 'dired-up-directory)
  	(keymap-set map "l" 'dired-find-file)

  	;;
  	;; Open file to other window by 'o'
  	;;
  	(keymap-set map "z" 'dired-do-compress-to)

  	;;
  	;; Compress file/files (marked or not) by 'z'
  	;;
  	(keymap-set map "o" 'dired-find-file-other-window)

  	;;
  	;; Toggle hidden files by 'sh'
  	;;
  	;; Before this can work, you have to make sure that you have the following settings
  	;; to show hidden files by default:
  	;;
  	;; '(setq dired-listing-switches "-lhta")'
  	;;
  	(setq dired-omit-files "^\\...+$")
  	(keymap-set map "s h" 'dired-omit-mode)

  	;;
  	;; Yank ful path by 'yp' 
  	;;
  	(keymap-set map "y p" 'my-dired-yank-full-path)

  	;;
  	;; Sort with different conditions by 'sX'
  	;;
  	(keymap-set map "s t" 'my-dired-sort-by-time)
  	(keymap-set map "s s" 'my-dired-sort-by-size)
  	(keymap-set map "s n" 'my-dired-sort-by-name)
  	;; (keymap-set map "s d" 'my-dired-sort-by-directory)

  	;;
  	;; Quickly go to particular directories by 'gX'
  	;;
  	;; - 'gh': Go home       '~/'
  	;; - 'gd': Go Desktop    '~/Desktop'
  	;; - 'gs': Go sbzi       '~/sbzi'
  	;; - 'ge': Go Emacs      '~/.config/emacs'
  	;;
  	(keymap-set map "g h" 'my-goto-home-directory)
  	(keymap-set map "g d" 'my-goto-desktop-directory)
  	(keymap-set map "g s" 'my-goto-sbzi-directory)
  	(keymap-set map "g e" 'my-goto-emacs-directory)

  	;;
  	;; Modify the READ-ONLY buffer by '<leader>m'
  	;;
  	;; After going into the 'wdired-change-to-wdired-mode', here are the default keybindgins
  	;; to accept or discard changes:
  	;; 
  	;; 'C-c C-c': Accept changes
  	;; 'C-c C-k': Discard changes
  	;;
  	(keymap-set map "SPC m" 'dired-toggle-read-only)

  	;;
  	;; Add file or directory by 'A'
  	;;
  	(keymap-set map "A" 'my-dired-add-file-or-directory)

  	(if my-enable-which-key-customized-description
  		(progn
  			(which-key-add-major-mode-key-based-replacements major-mode "SPC m"	"Modify mode")
  			(which-key-add-major-mode-key-based-replacements major-mode "s"	"Sort")
  			(which-key-add-major-mode-key-based-replacements major-mode "s t"	"Sort by time")
  			(which-key-add-major-mode-key-based-replacements major-mode "s s"	"Sort by size")
  			(which-key-add-major-mode-key-based-replacements major-mode "s n"	"Sort by name")
  			;; (which-key-add-key-based-replacements "s d"		"Sort by directory")
  			(which-key-add-major-mode-key-based-replacements major-mode "s h"	"(Toggle) show hidden")
  			(which-key-add-major-mode-key-based-replacements major-mode "y p"	"Yank path")
  		)
  	)
  )

  ;;
  ;; Call 'my-dired-mode-binding' with 'map'
  ;;
  (defun my-dired-mode-local-bindings ()
  	(my-dired-mode-bindings evil-normal-state-local-map)
  )

  ;;
  ;; Then, add it to the 'dired-mode-hook'
  ;;
  (add-hook 'dired-mode-hook #'my-dired-mode-local-bindings)
#+END_SRC


*** emacs-lisp-mode

#+BEGIN_SRC emacs-lisp
  ;;
  ;; My 'emacs-lisp-mode' bindings
  ;;
  (defun my-emacs-lisp-mode-bindings (map)
  	;;
  	;; Open embark collect buffer by '<leader>im' 
  	;; Use 'imenu' keybindings just easy for me to remember, nothing special:)
  	;;
  	(keymap-set map "SPC i m" 'embark-collect)

  	(if my-enable-which-key-customized-description
  		(progn
  			(which-key-add-major-mode-key-based-replacements major-mode "SPC i m" "Lisp embark list")
  		)
  	)
  )

  ;;
  ;; Call 'my-emacs-lisp-mode-binding' with 'evil-normal-state-local-map'
  ;;
  (defun my-emacs-lisp-mode-local-bindings ()
  	(my-emacs-lisp-mode-bindings evil-normal-state-local-map)
  )


  ;;
  ;; Then, add it to the 'emacs-lisp-mode-hook'
  ;;
  (add-hook 'emacs-lisp-mode-hook #'my-emacs-lisp-mode-local-bindings)
#+END_SRC


*** Image Dired

#+BEGIN_SRC emacs-lisp
  ;;
  ;; Fit the rendered image to window by '='
  ;;
  (evil-define-key '(normal) image-mode-map (kbd "=") 'image-transform-fit-to-window)
#+END_SRC


*** Embark

**** Run ~embark-act~ by ~C-e~

#+BEGIN_SRC emacs-lisp
  (keymap-set global-map "C-e" 'embark-act)
#+END_SRC


For the =GUI= version:

Because of I use =vertico-posframe= in =GUI= mode, but =Embark= doesn't work well with popup. That's why if you press =C-e=, then =Embark menu= shows under the popup which means you can't see part of it. In that situation, you can press =C-h=, then the =Embark help menu= will re-rendered inside the popup!!!


**** ~embark-collect-mode~ bindings

#+BEGIN_SRC emacs-lisp
  (defun my-embark-move-down-hit-enter()
  	(interactive)
  	(evil-next-line)
  	(push-button)
  )

  (defun my-embark-move-up-hit-enter()
  	(interactive)
  	(evil-previous-line)
  	(push-button)
  )

  ;;
  ;; My 'embark-collect-mode' bindings
  ;;
  (defun my-embark-collect-mode-bindings (map)
  	;;
  	;; '<C-j>' and '<C-k>' move up and down
  	;;
    	(keymap-set evil-normal-state-local-map "C-j" 'my-embark-move-down-hit-enter)
    	(keymap-set evil-normal-state-local-map "C-k" 'my-embark-move-up-hit-enter)
  )

  ;;
  ;; Call 'my-embark-collect-mode-binding' with 'evil-normal-state-local-map'
  ;;
  (defun my-embark-collect-mode-local-bindings ()
  	(my-embark-collect-mode-bindings evil-normal-state-local-map)
  )


  ;;
  ;; Then, add it to the 'embark-collect-mode-hook'
  ;;
  (add-hook 'embark-collect-mode-hook #'my-embark-collect-mode-local-bindings)
#+END_SRC


*** Increase or decrease font size by ~M--~ and ~M-=~ (only works for GUI mode)

#+BEGIN_SRC emacs-lisp
  (dolist (map (list
                evil-motion-state-map
                evil-normal-state-map
                ))
      (keymap-set map "M--" 'text-scale-decrease)
      (keymap-set map "M-=" 'text-scale-increase)
  )
#+END_SRC



*** +denote+

All the following bindings are disabled at this moment!!!

I'll upgarde them to the latest bindings pattern when I need =denote= again!!!

#+BEGIN_SRC emacs-lisp :tangle no
  ;;
  ;; Unbind my prefix-key
  ;;
  (keymap-set evil-normal-state-map "SPC n" nil)
  (dolist (map (list
                evil-motion-state-map
                evil-normal-state-map
                ))
    (keymap-set map "SPC n" nil)
    (keymap-set map "SPC n l" nil)
  )

  (dolist (map (list
                evil-motion-state-map
                ))
    (keymap-set map "SPC i m" 'consult-imenu)
    (keymap-set map "C-c i m" 'consult-imenu)

    (keymap-set map "SPC n c" 'denote)
    (keymap-set map "SPC n o" 'denote-open-or-create)
    (keymap-set map "SPC n f" 'denote-type)
    (keymap-set map "SPC n t" 'denote-template)
    (keymap-set map "SPC n r" 'denote-rename-file)

    (keymap-set map "SPC n l a" 'denote-link)
    (keymap-set map "SPC n l c" 'denote-link-or-create)
    (keymap-set map "SPC n l r" 'denote-add-links)
    (keymap-set map "SPC n l f" 'denote-find-link)
    (keymap-set map "SPC n l b" 'denote-backlinks)
  )

  ;;
  ;; 'which-key' description
  ;;
  (if my-enable-which-key-customized-description
      (progn
          (which-key-add-major-mode-key-based-replacements major-mode "SPC n" "Denote")
          (which-key-add-major-mode-key-based-replacements major-mode "SPC n c" "Create note")
          (which-key-add-major-mode-key-based-replacements major-mode "SPC n o" "Open (or create) note")
          (which-key-add-major-mode-key-based-replacements major-mode "SPC n f" "Create note by file-type")
          (which-key-add-major-mode-key-based-replacements major-mode "SPC n t" "Create note by template")
          (which-key-add-major-mode-key-based-replacements major-mode "SPC n r" "Rename")
          (which-key-add-major-mode-key-based-replacements major-mode "SPC n l" "Denote Links")
          (which-key-add-major-mode-key-based-replacements major-mode "SPC n l a" "Add link")
          (which-key-add-major-mode-key-based-replacements major-mode "SPC n l c" "Add (or create) link")
          (which-key-add-major-mode-key-based-replacements major-mode "SPC n l r" "Regexp links")
          (which-key-add-major-mode-key-based-replacements major-mode "SPC n l f" "Find links")
          (which-key-add-major-mode-key-based-replacements major-mode "SPC n l b" "Back-links")
      ))
#+END_SRC



*** eww

#+BEGIN_SRC emacs-lisp
  ;;
  ;; My 'eww-mode' bindings
  ;;
  (defun my-eww-mode-bindings (map)
  	;;
  	;; Disable the default keybindings
  	;;
    	;; (keymap-set map "SPC" nil)
    	(keymap-set map "w" nil)

  	;;
  	;; Rebind to 'Qutebrowser-liked' keybindings
  	;;
  	;; Here are the default bindings, for reference:
  	;;
  	;; (keymap-set evil-normal-state-local-map "y u" 'shr-maybe-probe-and-copy-url)
  	;; &		eww-browse-with-external-browser
  	;; H		eww-back-url
  	;; L		eww-forward-url
  	;; R
  	;; U		eww-top-url
  	;; ^		eww-up-url
  	;; d		eww-download
  	;; m		eww-add-bookmark
  	;; o		eww
  	;; q		quit-window
  	;; r		eww-readable
  	;; u		eww-up-url
  	;; DEL		eww-back-url
  	;; S-SPC		scroll-down-command
  	;; S-<return>	eww-browse-with-external-browser
  	;; <backtab>	shr-previous-link
  	;; <tab>		shr-next-link
  	;;
  	;; Z Q		quit-window
  	;; Z Z		quit-window
  	;;
  	;; [ [		eww-previous-url
  	;;
  	;; ] ]		eww-next-url
  	;;
  	;; z d		eww-toggle-paragraph-direction
  	;; z e		eww-set-character-encoding
  	;; z f		eww-toggle-fonts
  	;;
  	;; g b		eww-list-bookmarks
  	;; g c		url-cookie-list
  	;; g f		eww-view-source
  	;; g h		eww-list-histories
  	;; g j		eww-next-url
  	;; g k		eww-previous-url
  	;; g o		eww-browse-with-external-browser
  	;; g r		eww-reload
  	;; g t		eww-list-buffers
  	;;

  	; Open URL
  	(keymap-set map "o" 'eww)
  	(keymap-set map "O" 'eww-open-in-new-buffer)

  	; Reload
  	(keymap-set map "r" 'eww-reload)

  	; Toggle read list (remove all navigation menus parts)
  	(keymap-set map "R" 'eww-readable)

  	; Page up and down
  	(keymap-set map "u" 'evil-scroll-up)
  	(keymap-set map "d" 'evil-scroll-down)

  	; Add or update bookmark
  	(keymap-set map "m" 'consult-bookmark)

  	;;
  	;; Open embark collect buffer (kind of navigation URL list with title) by '<SPC i m>'
  	;;
  	(keymap-set map "SPC i m" 'embark-collect)
  )

  ;;
  ;; Call 'my-eww-mode-binding' with 'evil-normal-state-local-map'
  ;;
  (defun my-eww-mode-local-bindings ()
  	(my-eww-mode-bindings evil-normal-state-local-map)
  )

  ;;
  ;; Then, add it to the 'eww-mode-hook'
  ;;
  (add-hook 'eww-mode-hook #'my-eww-mode-local-bindings)



  ;;
  ;; My 'eww-history-mode' and 'eww-bookmark-mode' bindings
  ;;
  (defun my-eww-history-and-bookmark-modeb-indings (map)
  	;;
  	;; use '<C-j>' and '<C-k>' to move up and down
  	;;
  	(keymap-set map "C-j" 'evil-next-line)
  	(keymap-set map "C-k" 'evil-previous-line)
  )

  ;;
  ;; Call 'my-eww-mode-binding' with 'evil-normal-state-local-map'
  ;;
  (defun my-eww-history-and-bookmark-modeb-local-indings ()
  	(my-eww-history-and-bookmark-modeb-indings evil-normal-state-local-map)
  )


  ;;
  ;; Then, add it to the 'eww-mode-hook'
  ;;
  (add-hook 'eww-history-mode-hook #'my-eww-history-and-bookmark-modeb-local-indings)
  (add-hook 'eww-bookmark-mode-hook #'my-eww-history-and-bookmark-modeb-local-indings)

#+END_SRC


*** Org agenda mode

#+BEGIN_SRC emacs-lisp
  ;;
  ;; Here are the default bindings for 'org-agenda-mode', for reference:
  ;;
  ;; o		org-agenda-goto
  ;; C-k		org-agenda-kill
  ;; RET		org-agenda-switch-to
  ;; C-_		org-agenda-undo
  ;; SPC		org-agenda-show-and-scroll-up
  ;; !		org-agenda-toggle-deadlines
  ;; #		org-agenda-dim-blocked-tasks
  ;; $		org-agenda-archive
  ;; %		org-agenda-bulk-mark-regexp
  ;; *		org-agenda-bulk-mark-all
  ;; +		org-agenda-priority-up
  ;; ,		org-agenda-priority
  ;; -		org-agenda-priority-down
  ;; .		org-agenda-goto-today
  ;; /		org-agenda-filter
  ;; 0 .. 9		digit-argument
  ;; :		org-agenda-set-tags
  ;; ;		org-timer-set-timer
  ;; <		org-agenda-filter-by-category
  ;; =		org-agenda-filter-by-regexp
  ;; >		org-agenda-date-prompt
  ;; ?		org-agenda-show-the-flagging-note
  ;; A		org-agenda-append-agenda
  ;; B		org-agenda-bulk-action
  ;; C		org-agenda-convert-date
  ;; D		org-agenda-toggle-diary
  ;; E		org-agenda-entry-text-mode
  ;; F		org-agenda-follow-mode
  ;; G		org-agenda-toggle-time-grid
  ;; H		org-agenda-holidays
  ;; I		org-agenda-clock-in
  ;; J		org-agenda-clock-goto
  ;; L		org-agenda-recenter
  ;; M		org-agenda-phases-of-moon
  ;; N		org-agenda-next-item
  ;; O		org-agenda-clock-out
  ;; P		org-agenda-previous-item
  ;; Q		org-agenda-Quit
  ;; R		org-agenda-clockreport-mode
  ;; S		org-agenda-sunrise-sunset
  ;; T		org-agenda-show-tags
  ;; U		org-agenda-bulk-unmark-all
  ;; X		org-agenda-clock-cancel
  ;; [		org-agenda-manipulate-query-add
  ;; \		org-agenda-filter-by-tag
  ;; ]		org-agenda-manipulate-query-subtract
  ;; ^		org-agenda-filter-by-top-headline
  ;; _		org-agenda-filter-by-effort
  ;; a		org-agenda-archive-default-with-confirmation
  ;; b		org-agenda-earlier
  ;; c		org-agenda-goto-calendar
  ;; d		org-agenda-day-view
  ;; e		org-agenda-set-effort
  ;; f		org-agenda-later
  ;; g		org-agenda-redo-all
  ;; h		org-agenda-holidays
  ;; i		org-agenda-diary-entry
  ;; j		org-agenda-goto-date
  ;; k		org-agenda-capture
  ;; l		org-agenda-log-mode
  ;; m		org-agenda-bulk-mark
  ;; n		org-agenda-next-line
  ;; o		delete-other-windows
  ;; p		org-agenda-previous-line
  ;; q		org-agenda-quit
  ;; r		org-agenda-redo
  ;; s		org-save-all-org-buffers
  ;; t		org-agenda-todo
  ;; u		org-agenda-bulk-unmark
  ;; v		org-agenda-view-mode-dispatch
  ;; w		org-agenda-week-view
  ;; x		org-agenda-exit
  ;; y		org-agenda-year-view
  ;; z		org-agenda-add-note
  ;; {		org-agenda-manipulate-query-add-re
  ;; |		org-agenda-filter-remove-all
  ;; }		org-agenda-manipulate-query-subtract-re
  ;; ~		org-agenda-limit-interactively
  ;; DEL		org-agenda-show-scroll-down
  ;; C-/		org-agenda-undo
  ;; C-S-<left>	org-agenda-todo-previousset
  ;; C-S-<right>	org-agenda-todo-nextset
  ;; M-<down>	org-agenda-drag-line-forward
  ;; M-<up>		org-agenda-drag-line-backward
  ;; S-<down>	org-agenda-priority-down
  ;; S-<left>	org-agenda-do-date-earlier
  ;; S-<right>	org-agenda-do-date-later
  ;; S-<up>		org-agenda-priority-up
  ;; <backspace>	org-agenda-show-scroll-down
  ;; <down>		org-agenda-next-line
  ;; <mouse-2>	org-agenda-goto-mouse
  ;; <mouse-3>	org-agenda-show-mouse
  ;; <tab>		org-agenda-goto
  ;; <undo>		org-agenda-undo
  ;; <up>		org-agenda-previous-line
  ;; M-*		org-agenda-bulk-toggle-all
  ;; M-m		org-agenda-bulk-toggle
  ;; C-c C-a		org-attach
  ;; C-c C-c		org-agenda-ctrl-c-ctrl-c
  ;; C-c C-d		org-agenda-deadline
  ;; C-c C-n		org-agenda-next-date-line
  ;; C-c C-o		org-agenda-open-link
  ;; C-c C-p		org-agenda-previous-date-line
  ;; C-c C-q		org-agenda-set-tags
  ;; C-c C-s		org-agenda-schedule
  ;; C-c C-t		org-agenda-todo
  ;; C-c C-w		org-agenda-refile
  ;; C-c C-z		org-agenda-add-note
  ;; C-c $		org-agenda-archive
  ;; C-c ,		org-agenda-priority
  ;; C-x C-s		org-save-all-org-buffers
  ;; C-x C-w		org-agenda-write
  ;; C-x u		org-agenda-undo
  ;; <remap> <backward-paragraph>	org-agenda-backward-block
  ;; <remap> <forward-paragraph>	org-agenda-forward-block
  ;; <remap> <move-end-of-line>	org-agenda-end-of-line
  ;; C-c C-x C-a	org-agenda-archive-default
  ;; C-c C-x C-c	org-agenda-columns
  ;; C-c C-x C-e	org-clock-modify-effort-estimate
  ;; C-c C-x TAB	org-agenda-clock-in
  ;; C-c C-x C-j	org-clock-goto
  ;; C-c C-x C-o	org-agenda-clock-out
  ;; C-c C-x C-s	org-agenda-archive
  ;; C-c C-x C-x	org-agenda-clock-cancel
  ;; C-c C-x !	org-reload
  ;; C-c C-x <	org-agenda-set-restriction-lock-from-agenda
  ;; C-c C-x >	org-agenda-remove-restriction-lock
  ;; C-c C-x A	org-agenda-archive-to-archive-sibling
  ;; C-c C-x I	org-info-find-node
  ;; C-c C-x _	org-timer-stop
  ;; C-c C-x a	org-agenda-toggle-archive-tag
  ;; C-c C-x b	org-agenda-tree-to-indirect-buffer
  ;; C-c C-x e	org-agenda-set-effort
  ;; C-c C-x p	org-agenda-set-property
  ;; C-c C-x <down>	org-agenda-priority-down
  ;; C-c C-x <left>	org-agenda-do-date-earlier
  ;; C-c C-x <right>	org-agenda-do-date-later
  ;; C-c C-x <up>	org-agenda-priority-up
  ;; C-c C-x RET g	org-mobile-pull
  ;; C-c C-x RET p	org-mobile-push

  ;;
  ;; My 'org-agenda-mode' bindings
  ;;
  (defun my-org-agenda-mode-bindings (map)
    	;;
    	;; '<C-j>' and '<C-k>' jump between items
    	;;
    	(keymap-set map "C-j" 'org-agenda-next-line)
    	(keymap-set map "C-k" 'org-agenda-previous-line)

    	;;
    	;; 'u' to Undo
    	;;
    	(keymap-set map "u" 'org-agenda-undo)

    	;;
    	;; '/' to filter
    	;;
    	(keymap-set map "/" 'org-agenda-filter)

    	;;
    	;; 'RET' to open selected item
    	;;
    	(keymap-set map "RET" 'org-agenda-switch-to)

  )

  ;;
  ;; Call 'my-org-agenda-mode-binding' with 'evil-normal-state-local-map'
  ;;
  (defun my-org-agenda-mode-local-bindings ()
  	(my-org-agenda-mode-bindings evil-normal-state-local-map)
  )


  ;;
  ;; Then, add it to the 'org-agenda-mode-hook'
  ;;
  (add-hook 'org-agenda-mode-hook #'my-org-agenda-mode-local-bindings)
#+END_SRC


*** Minibuffer mode

#+BEGIN_SRC emacs-lisp
  (defun my-minibuffer-mode-local-bindings ()
  	(keymap-set minibuffer-mode-map "C-h" 'previous-history-element)
  	(keymap-set minibuffer-mode-map "C-l" 'next-history-element)
  )

  (add-hook 'minibuffer-setup-hook #'my-minibuffer-mode-local-bindings)
#+END_SRC
